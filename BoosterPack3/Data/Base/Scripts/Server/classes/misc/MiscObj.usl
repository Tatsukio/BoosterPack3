class CFirefly inherit CGameObj

    var ^CState m_pxNight;
    var ^CState m_pxDay;
    var ^CState m_pxInit;
    var int     m_iNight;
    var int     m_iDay;
    var bool    m_bLight;
    var real    m_fDelay;
    var real    m_fStartTime;

    export constructor()
        Random.Seed();
    endconstructor;

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
        SetSelectable(false);
        SetHitable(false);

        if(p_bLoad)then
            SetVisible(false);
        else
            SetVisible(true);
        endif;

        m_iNight            = 7;
        m_iDay          = 0;
        m_bLight            = false;
        m_fDelay            =0.0;

        var ^CFSM pxFSM         = InitFSM();
        var TStateClassID xUSLStateID="USLState";

        m_pxInit                    = CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,xUSLStateID);
        m_pxDay                 = CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,xUSLStateID);
        m_pxNight               = CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,xUSLStateID);

        m_pxInit^.m_xOnTick     = InitOnTick;

        m_pxDay^.m_xOnEnter     = DayOnEnter;
        m_pxDay^.m_xOnTick      = DayOnTick;
        m_pxNight^.m_xOnEnter   = NightOnEnter;
        m_pxNight^.m_xOnTick        = NightOnTick;

        GetFSM()^.ChangeState(m_pxInit);
    endproc;
/*
    proc bool ElapsedTime(real p_fInterval)
        var real fTime=CTimeMgr.Get().GetSeconds();
        return (fTime-m_fStartTime>p_fInterval);
    endproc;

    proc int GetRealTime()
        var int iTime=(CTimeMgr.Get().GetTime().GetMinute())%10;
        return (iTime);
    endproc;
*/
    proc void InitOnTick(int p_iTime)
/*      m_fDelay=(Random.GetInt()%40).ToReal();
        if(GetRealTime()<m_iDay)then
            GetFSM()^.ChangeState(m_pxNight);
        elseif(GetRealTime()<m_iNight)then
            GetFSM()^.ChangeState(m_pxDay);
        else
            GetFSM()^.ChangeState(m_pxNight);
        endif;*/
    endproc;

    proc void DayOnEnter(^CState p_pxFrom, ^CState p_pxTo)
/*      m_fStartTime=CTimeMgr.Get().GetSeconds();
        m_fDelay=(Random.GetInt()%70).ToReal();*/
    endproc;

    proc void DayOnTick(int p_iTime)
/*      if(m_bLight)then
            if(ElapsedTime(m_fDelay))then
                SetVisible(false);
                m_bLight=false;
                return;
            endif;
        elseif(GetRealTime()>=m_iNight)then
            GetFSM()^.ChangeState(m_pxNight);
        endif;*/
    endproc;

    proc void NightOnEnter(^CState p_pxFrom, ^CState p_pxTo)
/*      m_fStartTime=CTimeMgr.Get().GetSeconds();
        m_fDelay=(Random.GetInt()%70).ToReal();*/
    endproc;

    proc void NightOnTick(int p_iTime)
/*      if(!m_bLight)then
            if(ElapsedTime(m_fDelay))then
                SetVisible(true);
                m_bLight=true;
                return;
            endif;
        elseif(GetRealTime()>=m_iDay && GetRealTime()<m_iNight)then
            GetFSM()^.ChangeState(m_pxDay);
        endif;*/
    endproc;

endclass;

class CDefensePoint inherit CGameObj

    constructor()
    endconstructor;

    destructor()
    enddestructor;

    proc void OnInit(bool p_bLoad)
    	super.OnInit(p_bLoad);
        if(!p_bLoad)then
            SetType("WYPT");
            SetHitable(false);
            SetSelectable(false);
            SetVisible(false);
        endif;
    endproc;

endclass;

class CColoredBox inherit CGameObj

    constructor()
    endconstructor;

    destructor()
    enddestructor;

    proc void OnInit(bool p_bLoad)
        SetSelectable(true);
        SetHitable(true);
        SetVisible(true);
    endproc;

    export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
        if(p_sCommand=="StartCam")then
//          SetVisible(false);
//          SetHitable(false);
            SetSelectable(false);
            SetAnim("schweben",3);
        endif;
    endproc;


endclass;


class CLakeOfDamage inherit CGameObj

	var string	m_sTypes,m_sRegionName;
	var int		m_iDamage;
	const int	TIMER_DAMAGE	=2444;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
        if(!p_bLoad)then
            SetType("DMGL");
            SetHitable(false);
            SetSelectable(false);
            SetVisible(false);
			InitAttribs();
		else
			var ^CAttribs pxA = GetAttribs();
			if(pxA!=null) then
				m_sTypes=pxA^.GetValue("damage_types");
				m_iDamage=pxA^.GetValueInt("damage_per_tick");
				m_sRegionName=pxA^.GetValue("region_name");
			endif;
		endif;
		InitEvents();
		DeleteTimer(TIMER_DAMAGE);
		CreateTimer(TIMER_DAMAGE,CGameTimeSpan.OneSecond()*3.0,true);
	endproc;
	
    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
            if(p_rxEvtPtr.GetInt(0)==TIMER_DAMAGE)then
            	Damage();
			endif;
		endif;
	endproc;

	proc void Damage()
		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(m_sRegionName);
		if(pxRegion==null)then return; endif;
		var CObjList xObjList;
		var int i,iC=pxRegion^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			xObjList.AddEntry(pxRegion^.GetObject(i));
		endfor;
		iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFighter==null)then continue; endif;
			if(pxFighter^.GetTransportObj().IsValid())then continue; endif;
			if(!m_sTypes.IsEmpty() && m_sTypes.Find(pxFighter^.GetType().AsString())==-1)then continue; endif;
			pxFighter^.TakeDirectMeleeDmg(m_iDamage.ToReal());
		endfor;
	endproc;

endclass;

class CLakeOfHealing inherit CGameObj

	var string	m_sTypes,m_sRegionName;
	var int		m_iDamage;
	const int	TIMER_DAMAGE	=2444;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
        if(!p_bLoad)then
            SetType("DMGL");
            SetHitable(false);
            SetSelectable(false);
            SetVisible(false);
			InitAttribs();
		else
			var ^CAttribs pxA = GetAttribs();
			if(pxA!=null) then
				m_sTypes=pxA^.GetValue("damage_types");
				m_iDamage=pxA^.GetValueInt("damage_per_tick");
				m_sRegionName=pxA^.GetValue("region_name");
			endif;
		endif;
		InitEvents();
		DeleteTimer(TIMER_DAMAGE);
		CreateTimer(TIMER_DAMAGE,CGameTimeSpan.OneSecond()*3.0,true);
	endproc;
	
    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
            if(p_rxEvtPtr.GetInt(0)==TIMER_DAMAGE)then
            	Damage();
			endif;
		endif;
	endproc;

	proc void Damage()
		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(m_sRegionName);
		if(pxRegion==null)then return; endif;
		var CObjList xObjList;
		var int i,iC=pxRegion^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			xObjList.AddEntry(pxRegion^.GetObject(i));
		endfor;
		iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(pxFighter==null)then continue; endif;
			if(!m_sTypes.IsEmpty() && m_sTypes.Find(pxFighter^.GetType().AsString())==-1)then continue; endif;
			pxFighter^.HealMe(m_iDamage.ToReal());
		endfor;
	endproc;

endclass;

class CLightObj inherit CGameObj

    var real    m_fRange;
    var string  m_sDiffuse;
    var string  m_sAmbient;
    var string  m_sSpecular;
    var real    m_fAttenuationConst;
    var real    m_fAttenuationLinear;
    var real    m_fAttenuationSquared;

    export proc void OnInit(bool p_bLoad)
        if(!p_bLoad)then
            SetType("LGHT");
            SetHitable(false);
            SetSelectable(false);

            var ^CAttribs pxAttribs=InitAttribs();
            if(pxAttribs!=null)then
                /*
                pxAttribs^.SetValue("range",m_fRange.ToString());
                pxAttribs^.SetValue("diffuse",m_sDiffuse);
                pxAttribs^.SetValue("ambient",m_sAmbient);
                pxAttribs^.SetValue("specular",m_sSpecular);
                pxAttribs^.SetValue("attenuation_const",m_fAttenuationConst);
                pxAttribs^.SetValue("attenuation_linear",m_fAttenuationLinear);
                pxAttribs^.SetValue("attenuation_squared",m_fAttenuationSquared);
                */
                pxAttribs^.SetValue("range",(8.0).ToString());
                pxAttribs^.SetValue("diffuse","239 208 38");
                pxAttribs^.SetValue("ambient","148 48 37");
                pxAttribs^.SetValue("specular","242 238 208");
                pxAttribs^.SetValue("attenuation_const",(0.0).ToString());
                pxAttribs^.SetValue("attenuation_linear",(0.2).ToString());
                pxAttribs^.SetValue("attenuation_squared",(0.0).ToString());
            else
                CSrvWrap.LogError("LightObj","Could not read object attribs!" );
            endif;
        else
            var ^CAttribs pxAttribs=CheckAttribs();
            if(pxAttribs!=null)then
                m_fRange=pxAttribs^.GetValueFloat("range");
                m_sDiffuse=pxAttribs^.GetValue("diffuse");
                m_sAmbient=pxAttribs^.GetValue("ambient");
                m_sSpecular=pxAttribs^.GetValue("specular");
                m_fAttenuationConst=pxAttribs^.GetValueFloat("attenuation_const");
                m_fAttenuationLinear=pxAttribs^.GetValueFloat("attenuation_linear");
                m_fAttenuationSquared=pxAttribs^.GetValueFloat("attenuation_squared");
            else
                CSrvWrap.LogError("LightObj","Could not read object attribs!" );
            endif;
        endif;
    endproc;

    proc ^CAttribs CheckAttribs()
        var ^CAttribs pxAttribs=GetAttribs();
        if(pxAttribs==null)then pxAttribs=InitAttribs(); endif;
        if(!pxAttribs^.ContainsKey("range"))then
            pxAttribs^.SetValue("range",m_fRange);
        endif;
        if(!pxAttribs^.ContainsKey("diffuse"))then
            pxAttribs^.SetValue("diffuse",m_sDiffuse);
        endif;
        if(!pxAttribs^.ContainsKey("ambient"))then
            pxAttribs^.SetValue("ambient",m_sAmbient);
        endif;
        if(!pxAttribs^.ContainsKey("specular"))then
            pxAttribs^.SetValue("specular",m_sSpecular);
        endif;
        if(!pxAttribs^.ContainsKey("attenuation_const"))then
            pxAttribs^.SetValue("attenuation_const",m_fAttenuationConst);
        endif;
        if(!pxAttribs^.ContainsKey("attenuation_linear"))then
            pxAttribs^.SetValue("attenuation_linear",m_fAttenuationLinear);
        endif;
        if(!pxAttribs^.ContainsKey("attenuation_squared"))then
            pxAttribs^.SetValue("attenuation_squared",m_fAttenuationSquared);
        endif;
        return pxAttribs;
    endproc;

endclass;

class CRallyPoint inherit CGameObj

    export proc void OnInit(bool p_bLoad)
        if(!p_bLoad)then
            SetType("RALL");
            SetHitable(false);
            SetSelectable(false);
            SetVisible(true);
		endif;
    endproc;

endclass;
class CAtmoSoundObj inherit CGameObj

    export proc void OnInit(bool p_bLoad)
        if(!p_bLoad)then
            SetType("ATMO");
            SetHitable(false);
            SetSelectable(false);
            SetVisible(false);

            var ^CAttribs pxAttribs=InitAttribs();
            if(pxAttribs!=null)then
                pxAttribs^.SetValue("volume", 100);
                pxAttribs^.SetValue("pitch", 1.0);
                pxAttribs^.SetValue("minfadedist", 1.0);
                pxAttribs^.SetValue("maxfadedist", 25.0);
                pxAttribs^.SetValue("maxhearingdist", 25.0);
                pxAttribs^.SetValue("flags", 0);
                pxAttribs^.SetValue("innerconeangle", 30);
                pxAttribs^.SetValue("outerconeangle", 45);
                pxAttribs^.SetValue("coneoutsidevolume", 30);
            endif;

        endif;
    endproc;

endclass;



class CEAXEnvironmentObj inherit CGameObj

    export proc void OnInit(bool p_bLoad)
        if(!p_bLoad)then
            SetType("EAXE");
            SetHitable(false);
            SetSelectable(false);
            SetVisible(false);

            var ^CAttribs pxAttribs=InitAttribs();
            if(pxAttribs!=null)then
                pxAttribs^.SetValue("environmentname", "generic");
            endif;

        endif;
    endproc;

endclass;



class CDecoObj inherit CGameObj

    export constructor()
        SetVisInFOW(true);
    endconstructor;

    export proc void OnInit(bool p_bLoad)
    	SetType("DECO");
    	SetSelectable(false);
    	SetHitable(false);
    endproc;
endclass;

class CDecoAnimObj inherit CDecoObj
    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
		SetAnim("anim",3);
    endproc;
endclass;

class CBigCrater inherit CDecoObj

	const int 	TIMER_1=1905;
	const int 	TIMER_2=1906;
	const int 	TIMER_3=1907;

	export constructor()		
	endconstructor;
	
	 export proc void OnInit(bool p_bLoad)
    	SetType("BCRT");
		InitEvents();
    	if(!p_bLoad) then
			CreateTimer(TIMER_1,CGameTimeSpan.OneSecond()*30.0f, false);
			SetRot(Quat.RotationZ(Random.MTRandF(0.0f,Math.Pi()*2.0f)));
			AlignScape();
			SetRndInvMaskSingleFlagInv(6,true);
			SetRndInvMaskSingleFlagInv(7,true);
		else
			//old savegame compatibility, timers were not saved
			if(!HasTimer(TIMER_1)&&!HasTimer(TIMER_1)&&!HasTimer(TIMER_3)) then
				Delete();
			endif;		
		endif;
    endproc;

	export destructor()
	enddestructor;

    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
            if(p_rxEvtPtr.GetInt(0)==TIMER_1)then
				SetRndInvMaskSingleFlagInv(7,false);
                DeleteTimer(TIMER_1);
                CreateTimer(TIMER_2,CGameTimeSpan.OneSecond()*30.0f, false);
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_2)then
                SetRndInvMaskSingleFlagInv(6,false);
                DeleteTimer(TIMER_2);
                CreateTimer(TIMER_3,CGameTimeSpan.OneSecond()*60.0f, false);
            elseif(p_rxEvtPtr.GetInt(0)==1907)then
                Delete();
			endif;
		endif;
	endproc;

endclass;

class CFX inherit CGameObj

	const int TIMER_CFXE = 3425;

	var CObjHndl	m_xParent;
	var string		m_sFXClass;

	export constructor()
	endconstructor;

	export destructor()
	enddestructor;
	
	proc void OnInit(bool p_bLoad)	
    	super.OnInit(p_bLoad);
    	InitEvents();
        if(!p_bLoad)then
            SetType("CFXE");            
        endif;    
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if (iTimerID == TIMER_CFXE) then
				DeleteTimer(TIMER_CFXE);
				var ^CFightingObj pxObj = cast<CFightingObj>(m_xParent.GetObj());
				if(pxObj==null || !pxObj^.RemoveFX(m_sFXClass))then
					Delete();
				endif;
				return;
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="CFXE";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		(pxArc^) << m_sFXClass;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="CFXE")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1) then
				m_xParent.DoKArc(pxArc^);
				(pxArc^) << m_sFXClass;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnPostLoad()
		super.OnPostLoad();

		var string sEffectName = GetName();
		var string sParentName = "Invalid";
		var string sEffectPos = GetPos().ToString();
		if(m_xParent.IsValid())then
			sParentName = m_xParent.GetObj()^.GetName();
		endif;
		var string sMessage ="Effect name='"+sEffectName+"' parent='"+sParentName+"' pos='"+sEffectPos+"'";
		if(!m_xParent.IsValid())then
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			System.Assert(pxLevel!=null);
			if(pxLevel^.IsEditable())then
				var bool bIgnore=(sEffectName.Find("fx_holy_forest")!=-1);//WT1171
				if(!bIgnore)then
					Windows.DbgPrint("DETECTED orphant effect: "+sMessage);
					if(Windows.MessageBox("Orphant effect detected",sMessage+"\n\n    Delete Object?",050004h)==6)then
						Windows.DbgPrint("DELETED orphant effect: "+sMessage);
						Delete();
					endif;
				endif;				
			endif;
		endif;
	endproc;

	export proc void SetTimer(real p_fTime)
		if(p_fTime > 0.0)then
			DeleteTimer(TIMER_CFXE);
			CreateTimer(TIMER_CFXE, CGameTimeSpan.OneSecond() * p_fTime, true);
		endif;
	endproc;

	export proc void SetFXClass(string p_sFXClass)
		m_sFXClass = p_sFXClass;
	endproc;

	export proc ref string GetFXClass()
		return m_sFXClass;
	endproc;

	export proc void SetParent(CObjHndl p_xParent)
		m_xParent = p_xParent;
	endproc;

	export proc ref CObjHndl GetParent()
		return m_xParent;
	endproc;
	
endclass;

class CSign inherit CGameObj

    const int       UPDATE_TIMER=199;
    const int       TIMER_ID=200;
    var CObjHndl    m_xTarget;

    export constructor()
    endconstructor;

    export destructor()
    enddestructor;

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
        InitEvents();
    endproc;

    export proc void SetCountDown(real p_fTime, CObjHndl p_xTarget)
        //Windows.DbgPrint("CountDown("+p_fTime.ToString()+")");
        m_xTarget = p_xTarget;
        CreateTimer(TIMER_ID, CGameTimeSpan.OneSecond() * p_fTime, false);
        CreateTimer(UPDATE_TIMER, CGameTimeSpan.OneSecond() * 0.1, true);
    endproc;

    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        //Windows.DbgPrint("HandleEvent() CSign");
        if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
            if (p_rxEvtPtr.GetInt(0) == TIMER_ID ) then
//              Windows.DbgPrint("Delete()");
                DeleteTimer(UPDATE_TIMER);
                Delete();
            elseif( p_rxEvtPtr.GetInt(0) == UPDATE_TIMER )then
                if(m_xTarget.IsValid())then
                    SetPos(m_xTarget.GetObj()^.GetPos()+{0.0,0.0,3.0});
                else
                    DeleteTimer(UPDATE_TIMER);
                    DeleteTimer(TIMER_ID);
                    Delete();
                endif;
            else
                super.HandleEvent(p_rxEvtPtr);
            endif;
        else
            super.HandleEvent(p_rxEvtPtr);
        endif;
    endproc;

endclass;

class CColObj inherit CGameObj

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
    	SetType("COLL");
        CSrvWrap.GetPathfinder().AddPFBlocker(this);
    	SetSelectable(false);
    	SetHitable(false);
    endproc;

endclass;

class CDecoColObj inherit CGameObj

	constructor()
        SetVisInFOW(true);
	endconstructor;

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
    	SetType("DCCO");
        CSrvWrap.GetPathfinder().AddPFBlocker(this);
        SetPlaceBlocker(true);
    	SetSelectable(false);
    	SetHitable(false);
    endproc;

endclass;


class CDecoColAnimObj inherit CDecoColObj

	constructor()
        SetVisInFOW(true);
	endconstructor;

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
		SetAnim("anim",3);
    endproc;

endclass;


class CSeasHQLavaObj inherit CDecoColObj

	constructor()
        SetVisInFOW(true);
	endconstructor;

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
		SetAnim("seq_anim",0,150);
    endproc;

endclass;


class CAnimObj inherit CGameObj

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
    	SetSelectable(false);
    	SetHitable(false);
		SetAnim("anim",1);
    endproc;

endclass;

class CUpgradeObj inherit CGameObj

    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
        SetVisible(true);
        SetSelectable(false);
        SetHitable(false);
    endproc;

endclass;

class CRegionObj inherit CGameObj

    var string m_sRegionName;

    export constructor()
    endconstructor;

    export destructor()
    enddestructor;

    export proc void OnInit(bool p_bLoad);
        if(!p_bLoad) then
            SetType("ZONE");
            SetSelectable(false);
            SetHitable(false);
            var ^CAttribs pxAttribs=InitAttribs();
            pxAttribs^.SetValue("name",m_sRegionName);
//          Windows.DbgPrint("CRegion: OnInit()--> new");
        else
            var ^CAttribs pxAttribs=CheckAttribs();
            if(pxAttribs!=null)then
                m_sRegionName=pxAttribs^.GetValue("name");
//              Windows.DbgPrint("CRegion: OnInit()--> load");
            else
//              Windows.DbgPrint("ERROR: Could not read object attribs!" );
            endif;
        endif;
    endproc;

    proc ^CAttribs CheckAttribs()
        var ^CAttribs pxAttribs=GetAttribs();
        if(pxAttribs==null)then pxAttribs=InitAttribs();endif;
        if(!pxAttribs^.ContainsKey("name"))then
            pxAttribs^.SetValue("name",m_sRegionName);
        endif;
        return pxAttribs;
    endproc;

    export proc void SetAttrib(string p_sName, string p_sValue)
        if(p_sName=="name")then
            m_sRegionName=p_sValue;
        else
            super.SetAttrib(p_sName,p_sValue);
        endif;
    endproc;

    export proc void SetName(string p_sRegionName)
        if(m_sRegionName==p_sRegionName)then return; endif;
        m_sRegionName=p_sRegionName;
        GetAttribs()^.SetValue("name",m_sRegionName);
    endproc;

    proc void   HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
//      Windows.DbgPrint("GamePlayCommand: "+p_sCommand+" "+p_vPos.ToString()+" "+p_sMiscParams);
    endproc;
endclass;

class CShowFOWObj inherit CGameObj

    const int KILL_TIMER=200;

    export proc void OnInit(bool p_bLoad);
        super.OnInit(p_bLoad);
        SetSelectable(false);
        SetHitable(false);
        SetType("OTHR");
        SetVisible(true);
        InitEvents();
    endproc;

    export proc void SetFOWRange(real p_fFOW)
        SetFOW(p_fFOW);
    endproc;

    export proc void SetKillTimer( real p_fDuration )
        CreateTimer(KILL_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
    endproc;

    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
            if (p_rxEvtPtr.GetInt(0) == KILL_TIMER ) then
                Delete();
            endif;
        else
            super.HandleEvent(p_rxEvtPtr);
        endif;
    endproc;

	export proc void OnActionEnd(bool p_bBroken)
		Delete();
	endproc;
endclass;


class CLifeTimeObj inherit CGameObj

    const int KILL_TIMER	=200;
    const int CHECK_TIMER	=201;
    var CObjHndl			m_xParent;

    export proc void OnInit(bool p_bLoad);
        super.OnInit(p_bLoad);
        if(!p_bLoad)then
	        SetSelectable(false);
	        SetHitable(false);
	        SetType("OTHR");
	        SetVisible(true);
	    endif;
        InitEvents();
    endproc;

    export proc void SetKillTimer( real p_fDuration, CObjHndl p_xParent)
        CreateTimer(KILL_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
        if(p_xParent.IsValid())then
        	m_xParent=p_xParent;
	        CreateTimer(CHECK_TIMER,CGameTimeSpan.OneSecond() * 1.0, true);
        endif;
    endproc;

    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
            if (p_rxEvtPtr.GetInt(0) == KILL_TIMER ) then
                Delete();
			elseif (p_rxEvtPtr.GetInt(0) == CHECK_TIMER ) then
				if(!m_xParent.IsValid())then
					DeleteTimer(KILL_TIMER);
					DeleteTimer(CHECK_TIMER);
                	Delete();
                endif;
            endif;
        else
            super.HandleEvent(p_rxEvtPtr);
        endif;
    endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="Life";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Life")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xParent.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

endclass;


class CFireWorkObj inherit CShowFOWObj

    export proc void OnInit(bool p_bLoad);
        super.OnInit(p_bLoad);
        SetVisible(true);
		SetFOWRange(100.0);
		SetAnim("anim",1);
		SetKillTimer(10.0);
	endproc;

endclass;

class CDummySoundObj inherit CGameObj

    var int m_iStartRandom, m_iEndRandom;
    var string m_sAnim_day;
    var string m_sAnim_night;
    var string m_sAnim;
    var bool m_bNight;
    
    const int TIMER_ID=196;
    const int RANDOM_TIMER=200;


    export proc void OnInit(bool p_bLoad);
        super.OnInit(p_bLoad);
        SetSelectable(false);
        SetHitable(false);
        SetVisible(true);
        SetGFX("Dummy_SoundObj");
        InitEvents();
        SetFOW(0.0);
        var string sName = GetName();
        var array string asTokens;
        sName.Split(asTokens, ";", true);
        if(asTokens.NumEntries()==5)then
            m_iStartRandom = asTokens[1].ToInt();
            m_iEndRandom = asTokens[2].ToInt();
            m_sAnim_day = asTokens[3];
            m_sAnim = asTokens[3];
            m_sAnim_night = asTokens[4];
        else
            m_sAnim = "";
            m_sAnim_day = "";
            m_sAnim_night = "";
            m_iStartRandom = 30;
            m_iEndRandom = 120;
        endif;
        CreateRandomTimer(m_iStartRandom, m_iEndRandom);
        CreateTimer(TIMER_ID,CGameTimeSpan.OneSecond()*15.0f,true);
    endproc;

    export proc void CreateRandomTimer( int p_iStart, int p_iEnd )
        var real fDuration = (Random.GetInt()%(p_iEnd - p_iStart) + p_iStart).ToReal();
        CreateTimer(RANDOM_TIMER,CGameTimeSpan.OneSecond() * fDuration, false);
    endproc;

    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
            if (p_rxEvtPtr.GetInt(0) == RANDOM_TIMER ) then
                if(m_sAnim!="")then
                    SetAnim(m_sAnim,1);
                endif;
                CreateRandomTimer(m_iStartRandom, m_iEndRandom);
            elseif(p_rxEvtPtr.GetInt(0)==TIMER_ID)then
                var real fDayTime=(CTimeMgr.Get().GetVirtualTime()/CTimeMgr.Get().GetVirtualDayLength());
                fDayTime-=(fDayTime.ToInt()).ToReal();
                var bool bNight = false;
                //L CSrvWrap.LogInfo("Building","daytime: "+fDayTime.ToString());
                if((fDayTime>CTimeMgr.Get().GetVirtualNightOffset())||(fDayTime<CTimeMgr.Get().GetVirtualDayOffset()))then
                    bNight=true;
                endif;
                if(m_bNight != bNight)then
                    m_bNight=bNight;
                    if(m_bNight && m_sAnim_night!="")then
                        m_sAnim = m_sAnim_night;
                    elseif (!m_bNight)then
                        m_sAnim = m_sAnim_day;
                    endif;
                endif;
            endif;
        else
            super.HandleEvent(p_rxEvtPtr);
        endif;
    endproc;


endclass;



class CFlyingTraderMgr

    export static var CObjHndl ms_xFlyingTrader;

    //Resource prices
    static var real                 ms_fWoodPrice;
    static var real                 ms_fStonePrice;
    static var real                 ms_fIronPrice;
    static var real                 ms_fBonePrice;
    static var real                 ms_fHidePrice;
    static var real                 ms_fResinPrice;

    static var real                 ms_fWoodPriceModifier;
    static var real                 ms_fStonePriceModifier;
    static var real                 ms_fIronPriceModifier;
    static var real                 ms_fBonePriceModifier;
    static var real                 ms_fHidePriceModifier;
    static var real                 ms_fResinPriceModifier;

    static var real                 ms_fMaxPriceRatio;
    static var real                 ms_fMinPriceRatio;

    export static proc void OnInit()
        //Resource prices and modifiers, should come from TT
        ms_fWoodPrice=1.5;
        ms_fStonePrice=2.0;
        ms_fIronPrice=4.0;
        ms_fBonePrice=2.0;
        ms_fHidePrice=2.0;
        ms_fResinPrice=4.0;

        ms_fWoodPriceModifier=0.0f;
        ms_fStonePriceModifier=0.0f;
        ms_fIronPriceModifier=0.0f;
        ms_fBonePriceModifier=0.0f;
        ms_fHidePriceModifier=0.0f;
        ms_fResinPriceModifier=0.0f;

        //Resource price ist capped to ms_fMaxPriceRatio * resource price
        ms_fMaxPriceRatio=10.0f;
        //Resource price ist limited to resource price / ms_fMinPriceRatio
        ms_fMinPriceRatio=0.5f;

    endproc;


    export static proc ^CFlyingTrader GetFlyingTrader()
        if (!ms_xFlyingTrader.IsValid()) then
            //Create a FlyingTrade obj.
            var ^CObjMgrHost pxObjMgr=CSrvWrap.GetObjMgr();
            var ^CFlyingTrader pxTrader = cast<CFlyingTrader>(pxObjMgr^.CreateObj( "FlyingTrader", -1, {0.0, 0.0, 0.0}));
            if (pxTrader!=null) then
                ms_xFlyingTrader = pxTrader^.GetHandle();
            else
                ms_xFlyingTrader = CObjHndl.Invalid();
                KLog.LogError("FlyingTraderMgr", "Could not create FlyingTrader obj!");
                return null;
            endif;
        endif;
        return cast<CFlyingTrader>(ms_xFlyingTrader.GetObj());
    endproc;

    //Returns the price of the resource
    export static proc real GetResourcePrice(string p_sType)
        if(p_sType=="food")then
            return(1.0);
        elseif(p_sType=="wood")then
            return(ms_fWoodPrice+ms_fWoodPriceModifier);
        elseif(p_sType=="stone")then
            return(ms_fStonePrice+ms_fStonePriceModifier);
        elseif(p_sType=="iron")then
            return(ms_fIronPrice+ms_fIronPriceModifier);
        elseif(p_sType=="bone")then
            return(ms_fBonePrice+ms_fBonePriceModifier);
        elseif(p_sType=="hide")then
            return(ms_fHidePrice+ms_fHidePriceModifier);
        elseif(p_sType=="resin")then
            return(ms_fResinPrice+ms_fResinPriceModifier);
        endif;
        return(0.0f);
    endproc;


    //Adjusts modifier accoring to the amount of resource traded
    export static proc bool SetResourcePrice(string p_sType,real p_fAmount)

        if(p_fAmount==0.0)then return(false);endif;
        var real fChange=(p_fAmount/1000.0f);
        if(p_sType=="wood")then
            ms_fWoodPriceModifier=ms_fWoodPriceModifier+fChange;
            ms_fWoodPriceModifier=Math.Clamp(ms_fWoodPriceModifier,-(ms_fWoodPrice*ms_fMinPriceRatio),ms_fWoodPrice*ms_fMaxPriceRatio);
        elseif(p_sType=="stone")then
            ms_fStonePriceModifier=ms_fStonePriceModifier+fChange;
            ms_fStonePriceModifier=Math.Clamp(ms_fStonePriceModifier,-(ms_fStonePrice*ms_fMinPriceRatio),ms_fStonePrice*ms_fMaxPriceRatio);
        elseif(p_sType=="iron")then
            ms_fIronPriceModifier=ms_fIronPriceModifier+fChange;
            ms_fIronPriceModifier=Math.Clamp(ms_fIronPriceModifier,-(ms_fIronPrice*ms_fMinPriceRatio),ms_fIronPrice*ms_fMaxPriceRatio);
        elseif(p_sType=="bone")then
            ms_fBonePriceModifier=ms_fBonePriceModifier+fChange;
            ms_fBonePriceModifier=Math.Clamp(ms_fBonePriceModifier,-(ms_fBonePrice*ms_fMinPriceRatio),ms_fBonePrice*ms_fMaxPriceRatio);
        elseif(p_sType=="hide")then
            ms_fHidePriceModifier=ms_fHidePriceModifier+fChange;
            ms_fHidePriceModifier=Math.Clamp(ms_fHidePriceModifier,-(ms_fHidePrice*ms_fMinPriceRatio),ms_fHidePrice*ms_fMaxPriceRatio);
        elseif(p_sType=="resin")then
            ms_fResinPriceModifier=ms_fResinPriceModifier+fChange;
            ms_fResinPriceModifier=Math.Clamp(ms_fResinPriceModifier,-(ms_fResinPrice*ms_fMinPriceRatio),ms_fResinPrice*ms_fMaxPriceRatio);
        endif;

		UpdateAttribs();

        return(true);
    endproc;



    //Called by the deflation timer. Adjusts the modifier ==> 0.0f
    export static proc bool Deflate()
		if(ms_fWoodPriceModifier!=0.0f)then
			if(ms_fWoodPriceModifier>0.0f)then
				ms_fWoodPriceModifier=ms_fWoodPriceModifier-0.01f;
			else
				ms_fWoodPriceModifier=ms_fWoodPriceModifier+0.01f;
			endif;
		endif;
		if(ms_fStonePriceModifier!=0.0f)then
			if(ms_fStonePriceModifier>0.0f)then
				ms_fStonePriceModifier=ms_fStonePriceModifier-0.01f;
			else
				ms_fStonePriceModifier=ms_fStonePriceModifier+0.01f;
			endif;
		endif;
		if(ms_fIronPriceModifier!=0.0f)then
			if(ms_fIronPriceModifier>0.0f)then
				ms_fIronPriceModifier=ms_fIronPriceModifier-0.01f;
			else
				ms_fIronPriceModifier=ms_fIronPriceModifier+0.01f;
			endif;
		endif;
		if(ms_fBonePriceModifier!=0.0f)then
			if(ms_fBonePriceModifier>0.0f)then
				ms_fBonePriceModifier=ms_fBonePriceModifier-0.01f;
			else
				ms_fBonePriceModifier=ms_fBonePriceModifier+0.01f;
			endif;
		endif;
		if(ms_fHidePriceModifier!=0.0f)then
			if(ms_fHidePriceModifier>0.0f)then
				ms_fHidePriceModifier=ms_fHidePriceModifier-0.01f;
			else
				ms_fHidePriceModifier=ms_fHidePriceModifier+0.01f;
			endif;
		endif;

		if(ms_fResinPriceModifier!=0.0f)then
			if(ms_fResinPriceModifier>0.0f)then
				ms_fResinPriceModifier=ms_fResinPriceModifier-0.01f;
			else
				ms_fResinPriceModifier=ms_fResinPriceModifier+0.01f;
			endif;
		endif;

		UpdateAttribs();

		return(true);
	endproc;

	export static proc void UpdateAttribs()

    	var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
    	if(pxLevel==null)then return; endif;

    	var int i, iC = 8;
    	for(i=0)cond(i<iC)iter(i++)do
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(i);
			if(pxPlayer==null)then continue; endif;
			var ^CAttribs pxAttr = pxPlayer^.GetAttribs();
			if(pxAttr==null)then continue; endif;
			pxAttr^.SetValue("wood_price",((100.0 * (ms_fWoodPrice+ms_fWoodPriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("stone_price",((100.0 * (ms_fStonePrice+ms_fStonePriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("iron_price",((100.0 * (ms_fIronPrice+ms_fIronPriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("bone_price",((100.0 * (ms_fBonePrice+ms_fBonePriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("hide_price",((100.0 * (ms_fHidePrice+ms_fHidePriceModifier))+0.5).ToInt());
			pxAttr^.SetValue("resin_price",((100.0 * (ms_fResinPrice+ms_fResinPriceModifier))+0.5).ToInt());
    	endfor;

	endproc;

endclass;

class CFlyingTrader inherit CFightingObj
    var CObjList                m_xWarehouses;
    var CObjHndl                m_xCurrentWarehouse;
    var CObjList                m_xPlayerWarehouses;
    var CGameTime               m_xLastTick;
    var int                     m_iCurrentPlayerTarget;
    var int                     m_iLastOwner;
    var array int               m_aiPlayerOrder;

    const int              		DEFLATION_TIMER=9999;

    export constructor()
        m_aiPlayerOrder=8;
    endconstructor;

    export destructor()
    enddestructor;
    
	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xType="FlTr";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xWarehouses.DoKArc(pxArc^);
		m_xCurrentWarehouse.DoKArc(pxArc^);
		m_xPlayerWarehouses.DoKArc(pxArc^);
		m_xLastTick.DoKArc(pxArc^);
		(pxArc^) << m_iCurrentPlayerTarget;
		(pxArc^) << m_iLastOwner;
		
		var int i,iC=m_aiPlayerOrder.NumEntries();
		(pxArc^) << iC;
		for(i=0) cond(i<iC) iter(i++) do
			(pxArc^) << m_aiPlayerOrder[i];
		endfor;
		pxWalk^.Close();
		
		xType="FTMg";
		pxWalk=p_pxWriterNode^.AddSubChunk(xType,1);
		pxArc=^(pxWalk^.GetArc());
		CFlyingTraderMgr.ms_xFlyingTrader.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FlTr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWarehouses.DoKArc(pxArc^);
			m_xCurrentWarehouse.DoKArc(pxArc^);
			m_xPlayerWarehouses.DoKArc(pxArc^);
			m_xLastTick.DoKArc(pxArc^);
			(pxArc^) << m_iCurrentPlayerTarget;
			(pxArc^) << m_iLastOwner;

			var int i,iC;
			(pxArc^) << iC;
			m_aiPlayerOrder=iC;
			for(i=0) cond(i<iC) iter(i++) do
				(pxArc^) << m_aiPlayerOrder[i];
			endfor;
		elseif(p_pxReaderNode^.GetType()=="FTMg")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			CFlyingTraderMgr.ms_xFlyingTrader.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
        if(p_sCommand=="Action") then
        	if(p_sMiscParams.Find("/Walk")>=0) then
        		SetVisible(true);

		        var ^CFlyingTrade pxTask = cast<CFlyingTrade>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FlyTra"));
		        pxTask^.Init(GetHandle(), p_vPos);
		        m_pxTaskMgr^.SetTask(pxTask);
        	else
        		super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
        	endif;
        else
        	super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
        endif;
    endproc;

    export proc void RegisterTradeBuilding(^CBuilding p_pxBuilding)
        if (p_pxBuilding==null) then return; endif;
        //L CSrvWrap.LogSpam("FlyingTrader","Enter: RegisterTradeBuilding()"+p_pxBuilding^.GetName());
        m_xWarehouses.Include(p_pxBuilding^.GetHandle());
    endproc;


	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;


    export proc void DeRegisterTradeBuilding(^CBuilding p_pxBuilding)
        if (p_pxBuilding==null) then return; endif;
        //L CSrvWrap.LogSpam("FlyingTrader","Enter: DeRegisterTradeBuilding()");
        m_xWarehouses.RemEntry(p_pxBuilding^.GetHandle());
    endproc;

    export proc void OnInit(bool p_bLoad);
        //L CSrvWrap.LogSpam("FlyingTrader","Enter: OnInit()");
        //if(p_bLoad) then Delete(); return; endif;
        super.OnInit(p_bLoad);

        if(!p_bLoad) then
	        SetSelectable(false);
	        SetHitable(true);
	        InitEvents();
	        SetFOW(10.0);
	        SetVisInFOW(true);   //the trader and fow did not work very well together... change this when fixed.

	        m_iCurrentPlayerTarget = -1;
	        m_iLastOwner = -1;
        
        	Hide();

    	    m_xLastTick=CTimeMgr.Get().GetTime();
	        m_xCurrentWarehouse = CObjHndl.Invalid();
        endif;

        var ^CFSM pxFSM=GetFSM();
		if(p_bLoad) then
			m_pxIdleState=pxFSM^.FindSubStateRecursive("idle");
		endif;
		if(m_pxIdleState==null) then
	    	m_pxIdleState=CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,"idle");
	    endif;        
        m_pxIdleState^.m_xOnEnter=OnIdleEnter;
        m_pxIdleState^.m_xOnTick=OnIdleTick;
        m_pxIdleState^.m_xOnLeave=OnIdleLeave;
        m_pxTaskMgr^.SetReturnState(m_pxIdleState);

	    if(pxFSM^.GetCurState()==null) then
			pxFSM^.ChangeState(m_pxIdleState);
		endif;

        var CGameTimeSpan xTS=CGameTimeSpan.OneSecond()*60.0f;
        CreateTimer(DEFLATION_TIMER,xTS,true);
    endproc;

    proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
            if (p_rxEvtPtr.GetInt(0)==DEFLATION_TIMER) then
                CFlyingTraderMgr.Deflate();
            endif;
        endif;
        super.HandleEvent(p_rxEvtPtr);
    endproc;

    proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
        var ^CAttribs pxAttr = GetAttribs();
        if(pxAttr != null && pxAttr^.GetValue("CurTask")!="Idle")then
            pxAttr^.SetValue("CurTask","Idle");
        endif;
    endproc;

    proc void StartFlyTask()
        var bool bNewOwner = true;
        if (m_iLastOwner==m_xCurrentWarehouse.GetObj()^.GetOwner()) then
            bNewOwner = false;
        endif;
        m_iLastOwner = m_xCurrentWarehouse.GetObj()^.GetOwner();

        var bool bLastWarehouse = false;
        //if (m_xPlayerWarehouses.NumEntries()==0) then
        bLastWarehouse = true;
        //endif;

        SetVisible(true);

        var ^CFlyingTrade pxTask = cast<CFlyingTrade>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FlyTra"));
        pxTask^.Init(GetHandle(), m_xCurrentWarehouse, bNewOwner, bLastWarehouse);
        m_pxTaskMgr^.SetTask(pxTask);

        //Send feedback to player that the trader is on his way...
        //CFeedback.Print("The Flying Trader is on his way to you!", m_iLastOwner);
    endproc;


    proc void OnIdleTick(int p_iTime)
        //L CSrvWrap.LogSpam("FlyingTrader","Enter: OnIdleTick:");

        if (m_iCurrentPlayerTarget==-2) then
            m_iCurrentPlayerTarget=-1;
            m_xLastTick=CTimeMgr.Get().GetTime();
            Hide();
            return;
        endif;

        if (m_xCurrentWarehouse.IsValid()) then
            //maybe we were attacked on the way, so try again..
            //L CSrvWrap.LogSpam("FlyingTrader","Trying to reach building again");

            StartFlyTask();
            return;
        endif;

        if (m_iCurrentPlayerTarget<0) then
            //we are away... look if it is time to spawn

            var CGameTime xNow=CTimeMgr.Get().GetTime();
            var real fDiff = (xNow-m_xLastTick).GetSecondsF();
//          CSrvWrap.LogSpam("FlyingTrader","TimeDiff:"+fDiff.ToString());

            if ( fDiff > 10.0) then   //wait a bit here...
                //L CSrvWrap.LogSpam("FlyingTrader","Time to trade");
                m_iCurrentPlayerTarget=0;
                SpawnAtMapEdge();

                var int i;
                for(i=0)cond(i<8)iter(i++)do
                    m_aiPlayerOrder[i]=i;
                endfor;
                var int iTemp;
                for(i=0)cond(i<8)iter(i++)do
                    var int iRandom = Random.GetInt()%8;
                    iTemp = m_aiPlayerOrder[i];
                    m_aiPlayerOrder[i]=m_aiPlayerOrder[iRandom];
                    m_aiPlayerOrder[iRandom]=iTemp;
                endfor;

//              for(i=0)cond(i<8)iter(i++)do
//                  CSrvWrap.LogSpam("FlyingTrader","Order:"+m_aiPlayerOrder[i].ToString());
//              endfor;
            else
                //L CSrvWrap.LogSpam("FlyingTrader","Sleep.");
                return;
            endif;
        endif;

        //check what player to visit or if we should go away...
        if (m_iCurrentPlayerTarget>7) then
            //GoToMapEdge();
            m_iLastOwner=-1;
            Hide();
            m_iCurrentPlayerTarget=-2;
            //L CSrvWrap.LogSpam("FlyingTrader","All visited, go away.");
            return;
        endif;


        if (m_xPlayerWarehouses.NumEntries()>0) then
            //still have places to visit at this player.

            m_xPlayerWarehouses.Validate();

            var int iIndex = m_xPlayerWarehouses.FindNearest(GetPos());
            if (iIndex>=0) then
                m_xCurrentWarehouse = m_xPlayerWarehouses[iIndex];
                //m_xPlayerWarehouses.DeleteEntry(iIndex);

                StartFlyTask();
            endif;

            //if (m_xPlayerWarehouses.NumEntries()==0) then
            m_iCurrentPlayerTarget++;
            //endif;
            return;
        endif;

        m_xWarehouses.Validate();

        //find warehouse that belongs to player.
        while (m_iCurrentPlayerTarget<8) do
            var int i;
            for(i=0)cond(i<m_xWarehouses.NumEntries())iter(i++)do
                var CObjHndl xObj = m_xWarehouses[i];
                if (!xObj.IsValid()) then
                    //should have been deleted above, but just in case.
                    continue;
                endif;

                var ^CGameObj pxObj = xObj.GetObj();
                if ( pxObj^.GetOwner()== m_aiPlayerOrder[m_iCurrentPlayerTarget] ) then

                    var ^CBuilding pxBuilding = cast<CBuilding>(pxObj);
                    if (pxBuilding!=null) then
                        if (!pxBuilding^.IsBuildMode()) then
                            m_xPlayerWarehouses.Include(pxObj^.GetHandle());
                        endif;
                    endif;
                endif;
            endfor;

            if (m_xPlayerWarehouses.NumEntries()==0) then
                m_iCurrentPlayerTarget++;
            else
                break;
            endif;
        endwhile;
    endproc;

    proc void OnIdleLeave(^CState p_pxFrom, ^CState p_pxTo)
        var ^CAttribs pxAttr = GetAttribs();
        if(pxAttr != null && pxAttr^.GetValue("CurTask")=="Idle")then
            pxAttr^.SetValue("CurTask","");
        endif;
    endproc;

    proc bool IsIdle()
        var ^CFSM pxFSM = GetFSM();
        if(pxFSM!=null)then
            return (pxFSM^.GetCurState()==m_pxIdleState);
        endif;
        return true;
    endproc;

    export proc void WarehouseVisited()
        m_xPlayerWarehouses.Validate();

        var bool bTraded = false;

        var int i;
        for(i=0)cond(i<m_xPlayerWarehouses.NumEntries())iter(i++)do
            var CObjHndl xObj = m_xPlayerWarehouses[i];
            if (!xObj.IsValid()) then
                //should have been deleted above, but just in case.
                continue;
            endif;

            var ^CGameObj pxWarehouse = xObj.GetObj();
            if (pxWarehouse==null) then continue; endif;

            var ^CWarehouse pxBuilding = cast<CWarehouse>(pxWarehouse);
            if (pxBuilding!=null) then
                if (pxBuilding^.TraderArrived()) then
                    bTraded = true;
                    //Set LastEventPos
                    var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
                    if (pxLevel!=null) then
                        var ^CPlayer pxPlayer=pxLevel^.GetPlayer(pxBuilding^.GetOwner());
                        if (pxPlayer!=null) then
                            var ^CAttribs pxAttribs = pxPlayer^.GetAttribs();
                            if(pxAttribs==null)then return();endif;
                            pxAttribs^.SetValue("lastevent",pxBuilding^.GetPos().ToString());
                        endif;
                    endif;
                endif;
            else
                CSrvWrap.LogWarning("FlyingTrade","Failed cast to CWarehouse, no trade performed.");
            endif;
        endfor;

        if (bTraded) then
            //CFeedback.Print("Trader visited and resources have been traded.",m_iLastOwner);
        else
            //CFeedback.Print("Trader visited, but there was nothing to trade.",m_iLastOwner);
        endif;

        m_xCurrentWarehouse = CObjHndl.Invalid();
        m_xPlayerWarehouses.Clear();  //only visit one of the warehouses.
    endproc;

    proc void Hide()
        var vec3 vPos = GetRandomMapEdge();
        vPos.SetZ(50.0f);
        SetPos(vPos);
        SetVisible(false);
    endproc;

    proc void SpawnAtMapEdge()
        var vec3 vPos = GetRandomMapEdge();
        vPos.SetZ(50.0f);
        SetPos(vPos);
        SetVisible(true);
    endproc;

    proc void GoToMapEdge()
        var vec3 vMyPos = GetPos();
        var real fHeight = CSrvWrap.GetScapeMgr().GetHeight( vMyPos.GetX(), vMyPos.GetY());
        if ((vMyPos.GetZ()-fHeight)<29.0) then //this is just for safety
            vMyPos.SetZ(fHeight+30.0);
            SetPos(vMyPos);
        endif;
        var vec3 vPos = GetRandomMapEdge();
        vPos.SetZ(50.0f);
        //WalkAction(vPos, 3, false, false);
    endproc;

    proc vec3 GetRandomMapEdge()
        var real fHeight = CSrvWrap.GetScapeMgr().GetMapHeight().ToReal();
        var real fWidth = CSrvWrap.GetScapeMgr().GetMapWidth().ToReal();

        var int iRandom = Random.GetInt()%4;
        if (iRandom==0) then
            var vec3 vPos;
            vPos.SetXYZ(0.0, Random.MTRandF(0.0, fHeight), 0.0);
            return vPos;
        elseif (iRandom==1) then
            var vec3 vPos;
            vPos.SetXYZ(fWidth, Random.MTRandF(0.0, fHeight), 0.0);
            return vPos;
        elseif (iRandom==2) then
            var vec3 vPos;
            vPos.SetXYZ(Random.MTRandF(0.0, fWidth), 0.0, 0.0);
            return vPos;
        else
            var vec3 vPos;
            vPos.SetXYZ(Random.MTRandF(0.0, fWidth), fHeight, 0.0);
            return vPos;
        endif;
    endproc;

endclass;

class CInsectsObj inherit CGameObj

	const int			START_TIMER=201;
	const int			EAT_TIMER=200;
	var int				m_iEatCount;
	var CObjHndl 		m_xOwner;
	var CObjHndl		m_xTarget;
	var CGameTimeSpan	m_xTime;
	var CGameTime		m_xStartTime;

	constructor()		
	endconstructor;

	destructor()
	enddestructor;

	proc void OnActionStart()
		//L CSrvWrap.LogInfo("Arrow",GetName()+" CArrow: Zisch. Losgeflogen!");
	endproc;

	proc void OnActionEnd(bool p_bBroken)
		if(m_xTarget.IsValid())then
			//TODO: Insert effect/animation
			m_xStartTime = CTimeMgr.Get().GetTime();
			CreateTimer(EAT_TIMER, CGameTimeSpan.OneSecond() * 1.0, true);
			SetGfxNew();
		else
			Delete();
		endif;
	endproc;

	proc void SetGfxNew()
		SetGFX("Hu_Insects");
	endproc;

	export proc void OnInit(bool p_bLoad)
		InitEvents();
		if(!p_bLoad)then
			SetType("PROD");
		else
    	endif;
		SetHitable(false);
		SetSelectable(false);
		SetVisible(false);
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			if (p_rxEvtPtr.GetInt(0) == START_TIMER ) then
				Shoot();
			elseif (p_rxEvtPtr.GetInt(0) == EAT_TIMER ) then
				if(!Eat())then
					Delete();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	export proc void Set(CObjHndl p_xTarget, CGameTimeSpan p_xTime, int p_iEatCount,CObjHndl p_xOwner)
		SetGFX("WoodLog");
		m_xTarget = p_xTarget;
		m_xOwner=p_xOwner;
		m_xTime = p_xTime;
		m_iEatCount = p_iEatCount;
		CreateTimer(START_TIMER, CGameTimeSpan.OneSecond() * 1.0, false);
	endproc;

	export proc void Shoot()
		SetVisible(true);
		if(HasTimer(START_TIMER))then DeleteTimer(START_TIMER);endif;
		if(m_xTarget.IsValid())then
			BallisticAction(m_xTarget.GetObj()^.GetPos(),20.0,3.0);
			if (!HasAction()) then
				Delete();
			endif;
		else
			Delete();
		endif;
	endproc;

	proc bool Eat()

		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;

		if(!m_xTarget.IsValid())then
			return false;
		endif;

		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return false; endif;
		var ^CAttribs pxAttr = pxPlayer^.GetAttribs();
		if(pxAttr==null)then return false; endif;

		var int iValue = pxAttr^.GetValueInt("food");
		iValue = Math.Max((iValue-m_iEatCount),0);

		pxAttr^.SetValue("food",iValue);

		if(iValue==0)then
			return false;
		endif;
		CheckAttackMessage();
		return true;

	endproc;
	
	proc void CheckAttackMessage()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CGameObj pxEnemy=m_xOwner.GetObj();
		var ^CGameObj pxTarget=m_xTarget.GetObj();
		
		if(pxEnemy!=null && pxTarget!=null &&pxLevel != null) then
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(pxTarget^.GetOwner());
			if (pxPlayer != null) then
				var ^CBasePlayer pxBasePlayer = cast<CBasePlayer>(pxPlayer);
				if(pxBasePlayer != null)then					
					pxBasePlayer^.IWasAttacked(pxTarget^.GetHandle(), pxEnemy^.GetHandle());					
				endif;
			endif;
		endif;
	endproc;

endclass;

class CTermitesObj inherit CInsectsObj
	
	var int m_iTermitesOwner;
	
	proc void SetGfxNew()
		SetGFX("Aje_Termites");
	endproc;
	
	export proc void Set(CObjHndl p_xTarget, CGameTimeSpan p_xTime, int p_iEatCount,CObjHndl p_xOwner)
		super.Set(p_xTarget,p_xTime,p_iEatCount,p_xOwner);
		m_iTermitesOwner=-1;
		var ^CGameObj pxOwner=m_xOwner.GetObj();
		if(pxOwner!=null)then			
			m_iTermitesOwner=pxOwner^.GetOwner();
		endif;
		
	endproc;

	proc bool Eat()
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;

		var ^CBuilding pxBuilding = cast<CBuilding>(m_xTarget.GetObj());

		if(pxBuilding==null)then
			return false;
		endif;
		
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return false; endif;
		
		pxBuilding^.TakeDirectMeleeDmg(m_iEatCount.ToReal(),m_iTermitesOwner);
		CheckAttackMessage();
		return true;

	endproc;

endclass;

class CTornadoObj inherit CGameObj

	const int			RAGE_TIMER=201;

	//START TUNING VALUES
	const real			RANGE			=10.0;
	const real			TIME			=10.0;
	const real			PRC_DAMAGE		=0.50;
	const real			PRC_DAMAGE_BLDG	=0.25;
	const real			MIN_DAMAGE		=300.0;
	const real			MAX_DAMAGE		=2000.0;
	//END TUNING VALUES
	
	var vec3			m_vTarget;
	var CObjList		m_xMovableTargets;
	var CObjList		m_xNonMovableTargets;
	var CGameTimeSpan	m_xTime;
	var CGameTime		m_xStartTime;

	export proc void OnInit(bool p_bLoad)
		InitEvents();
		if(!p_bLoad)then
		else
    	endif;
		SetHitable(false);
		SetSelectable(false);
		SetVisible(true);
	endproc;

	export proc void Set(vec3 p_vTarget)
		m_vTarget = p_vTarget;
		m_xTime = TIME;
		m_xStartTime = CTimeMgr.Get().GetTime();

		m_xMovableTargets.Clear();
		m_xNonMovableTargets.Clear();

		var CObjList xList;

		if(GetOwner()>=0)then

			var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
			if(pxEnemies==null) then return; endif;

			pxEnemies^.CopySorted(xList, p_vTarget, RANGE+20.0);

			var CObjQuery xQuery;
			xQuery.SetOwner(-1);
			xQuery.SetType("CHTR");
			xQuery.SetType("SHIP",true);
			xQuery.SetType("ANML",true);
			xQuery.SetType("VHCL",true);
			xQuery.SetType("NEST",true);
			xQuery.SetType("FGHT",true);

			xQuery.RegionCircle(p_vTarget, RANGE+20.0);

			var CObjList xQueryList;
			if(xQuery.Execute(xQueryList))then
				xList.Include(xQueryList);
			endif;

			var int i, iC;
			iC = xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do

				var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());

				if(pxFight==null)then continue;	endif;
				var real fDistance=(pxFight^.GetPos()-GetPos()).Abs2();
				fDistance-=pxFight^.GetCollisionRadius();
				if(fDistance>RANGE)then continue; endif;

				if(pxFight^.IsAbleToWalk())then
					m_xMovableTargets.Include(xList[i]);
					pxFight^.SetTrapped(GetHandle());
				else
					m_xNonMovableTargets.Include(xList[i]);
					pxFight^.SetTrapped(GetHandle());
				endif;

			endfor;

		endif;

		SetAnim("swirl",3);

		Swirl();

		CreateTimer(RAGE_TIMER, CGameTimeSpan.OneSecond() * 1.0, true);

	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			if (p_rxEvtPtr.GetInt(0) == RAGE_TIMER ) then
				if(!Swirl())then
					DeleteTimer(RAGE_TIMER);
					FreeVictims();
					Delete();
				endif;
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	proc void FreeVictims()

		var int i, iC = m_xMovableTargets.NumEntries();
		var CObjHndl xInvalid = CObjHndl.Invalid();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xMovableTargets[i].GetObj());
			if(pxFight!=null)then
				pxFight^.SetTrapped(xInvalid);
			endif;
		endfor;

		iC = m_xNonMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xNonMovableTargets[i].GetObj());
			if(pxFight!=null)then
				pxFight^.SetTrapped(xInvalid);
			endif;
		endfor;

	endproc;

	proc bool Swirl()
	
		var int iOwner=GetOwner();

		var CGameTime xNow = CTimeMgr.Get().GetTime();
		if((xNow - m_xStartTime) > m_xTime)then
			return false;
		endif;

		var real fALLDmg=(PRC_DAMAGE/m_xTime.GetSecondsF());
		var real fBLDGDmg=(PRC_DAMAGE_BLDG/m_xTime.GetSecondsF());
		
		var real fMinDmg=MIN_DAMAGE/m_xTime.GetSecondsF();
		var real fMaxDmg=MAX_DAMAGE/m_xTime.GetSecondsF();

		var int i, iC = m_xMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xMovableTargets[i].GetObj());
			if(pxFight!=null)then
				var real fDmg=Math.Clamp(pxFight^.GetHitpoints()*fALLDmg,fMinDmg,fMaxDmg);
				pxFight^.TakeDirectMeleeDmg(fDmg,iOwner);
			endif;
		endfor;

		iC = m_xNonMovableTargets.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(m_xNonMovableTargets[i].GetObj());
			if(pxFight!=null)then
				var real fDmg=Math.Clamp(pxFight^.GetHitpoints()*fBLDGDmg,fMinDmg,fMaxDmg);
				pxFight^.TakeDirectMeleeDmg(fDmg,iOwner);
			endif;
		endfor;

		return true;

	endproc;

endclass;

class CUniversalCorpse inherit CGameObj

	class CSource
		
		export var string	m_sClass;
		export var int		m_iLevel;
		export var CFourCC	m_xType;
		export var int		m_iMaxHP;

		export constructor()
		endconstructor;
		
		export destructor()
		enddestructor;
		
		export proc ref CUniversalCorpse.CSource op_Assign( ^CGameObj p_pxOther )
			if(p_pxOther!=null)then
				m_sClass = p_pxOther^.GetClassName();
				var ^CAttribs pxAttr = p_pxOther^.GetAttribs();
				if(pxAttr!=null)then
					m_iLevel = pxAttr^.GetValueInt("level");
					m_xType = p_pxOther^.GetType();
					m_iMaxHP = pxAttr^.GetValueInt("maxhitpoints");
				endif;
			endif;
			return this^;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc)
			var int iVersion=1;
			p_rxArc << iVersion;
			p_rxArc << m_sClass;
			p_rxArc << m_iLevel;
			
			var string sType=m_xType.AsString();
			p_rxArc << sType;
			m_xType=sType;
			
			p_rxArc << m_iMaxHP;
		endproc;
		
	endclass;

	export const int					TIMER_DELETE=123;
	var string							m_sAnim;
	var int								m_iPlayMode;
	var array CUniversalCorpse.CSource	m_axSources;
	var int								m_iOrgMaxHP;
	var CObjHndl						m_xFood;
	var int								m_iHPPercent;

	export constructor()
		SetHitable(true);
		SetSelectable(false);		
		m_iPlayMode = 1;
		m_iHPPercent=100;
	endconstructor;

	export destructor()
	enddestructor;

    export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="UCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		// version 3
		var int i,iC=m_axSources.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axSources[i].DoKArc(pxArc^);
		endfor;
		// version 3
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="UCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion==1)then
				var bool bAutoRespawn;
				pxArc^ << bAutoRespawn;
				var int i,iC=m_axSources.NumEntries();
				pxArc^ << iC;
				m_axSources=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axSources[i].DoKArc(pxArc^);
				endfor;
			endif;
			if(iVersion==2)then
				var bool bAutoRespawn;
				pxArc^ << bAutoRespawn;
				var int i,iC=m_axSources.NumEntries();
				pxArc^ << iC;
				m_axSources=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axSources[i].DoKArc(pxArc^);
				endfor;
				var CObjHndl xPyCO;
				xPyCO.DoKArc(pxArc^);
			endif;
			if(iVersion>=3)then
				var int i,iC=m_axSources.NumEntries();
				pxArc^ << iC;
				m_axSources=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axSources[i].DoKArc(pxArc^);
				endfor;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad)then
			SetDynamicBBox(true);
			SetType("OTHR");
			InitAttribs();
		endif;
		super.OnInit(p_bLoad);
		InitEvents();
	endproc;
	
	export proc void SetHPPercent(int p_iPercent)
		m_iHPPercent = p_iPercent;
	endproc;
	
	export proc void SetFoodObj(CObjHndl p_xFood)
		m_xFood = p_xFood;
	endproc;
	
	export proc void SetSource(^CGameObj p_pxSource)
		var CUniversalCorpse.CSource xSource = p_pxSource;
		begin SetLevelAttrib;
			var ^CAttribs pxAttribs = GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("level",xSource.m_iLevel);
				pxAttribs^.SetValue("class",xSource.m_sClass);
			endif;
		end SetLevelAttrib;
		m_axSources.AddEntry(xSource);
	endproc;
	
	export proc string GetSourceClass()
		if(m_axSources.NumEntries()>0)then
			return m_axSources[0].m_sClass;
		endif;
		return "";
	endproc;

	export proc void SetDieAnim(string p_sAnim, bool p_bPlayAnim)
		m_sAnim = p_sAnim;
		if(p_bPlayAnim)then
			m_iPlayMode = 1;
		else
			m_iPlayMode = 0;
		endif;
	endproc;

	export proc void Init(string p_sGfx, string p_sName, real p_fDuration)
		SetGFX(p_sGfx);
		SetName(p_sName);
		InvokeGenericSCEvent(40,4.0);
		PlayAnim(m_iPlayMode);
		if(p_fDuration>0.0)then
			CreateTimer(TIMER_DELETE, CGameTimeSpan.OneSecond()*p_fDuration,false);
		endif;
	endproc;
	
	

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if (iTimerID == TIMER_DELETE) then
				Delete();
			endif;
		endif;
	endproc;

	proc void PlayAnim(int p_iMode)
	endproc;

	export proc int GetLevel()
		var int i, iC = m_axSources.NumEntries();
		var int iMaxLevel = 0;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axSources[i].m_iLevel > iMaxLevel)then
				iMaxLevel = m_axSources[i].m_iLevel;
			endif;
		endfor;
		return iMaxLevel;
	endproc;

endclass;

class CTrainingDummy inherit CGameObj
    export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);
    	SetSelectable(false);
    	SetHitable(false);
    endproc;
    export proc void StartTraining(string p_sGFX) StartTraining(p_sGFX,"farm_anim_1"); endproc;
    export proc void StartTraining(string p_sGFX,string p_sAnim)
    	SetGFX(p_sGFX);
    	AnimAction(p_sAnim);
	endproc;
	export proc void OnActionEnd(bool p_bBroken)
		Delete();
	endproc;
endclass;


class CFountain inherit CGameObj

	class CHealRequest //obsolete
		
		export proc void DoKArc(^CArc p_pxArc)
			var bool bInvalid;
			p_pxArc^ << bInvalid;
			var int iInvalid;
			p_pxArc^ << iInvalid;
			var CObjHndl xInvalid;
			xInvalid.DoKArc(p_pxArc^);
			var CObjList xInvalidList;
			xInvalidList.DoKArc(p_pxArc^);
		endproc;
		
	endclass;

	var real m_fRefillDuration;
	var int m_iMaxHealAmount;
	var CGameTime m_xAvailable;

	const int REFILL_TIMER=911;
	var CGameTime	m_xLastRefillTick;
	var real		m_fFillState;

	
	export constructor()
		m_xAvailable = CGameTime.GetInvalidTime();
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		if(!p_bLoad) then
			SetType("FNTN");
			InitAttribs();
			SetSelectable(true);
			SetHitable(true);
		else
			var ^CAttribs pxA = GetAttribs();
			if(pxA!=null) then
				m_iMaxHealAmount=pxA^.GetValueInt("maxhitpoints");
				m_fRefillDuration=pxA^.GetValueInt("refill_dur").ToReal();
				m_fFillState=pxA^.GetValueInt("hitpoints").ToReal();
			endif;
		endif;
		InitEvents();
		SetAnim("base_anim",3);
	endproc;
	
	export proc real GetRefillDuration()
		return m_fRefillDuration;
	endproc;
	
	export proc int GetMaxHealAmount()
		return m_iMaxHealAmount;
	endproc;
	
	export proc void SetRefillDuration(real p_fRefillDur)
		m_fRefillDuration = p_fRefillDur;
		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null) then
			pxA^.SetValue("refill_dur", m_fRefillDuration);
		endif;
	endproc;
	
	export proc void SetMaxHealAmount(int p_iMaxHeal)
		m_iMaxHealAmount = p_iMaxHeal;
		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null) then
			pxA^.SetValue("heal_amount", m_iMaxHealAmount);
			pxA^.SetValue("maxhitpoints", m_iMaxHealAmount);
			pxA^.SetValue("hitpoints", m_iMaxHealAmount);
			if(HasTimer(REFILL_TIMER))then
				DeleteTimer(REFILL_TIMER);
			endif;
		endif;
	endproc;
	
	export proc bool StartRefillTimer()
		if(HasTimer(REFILL_TIMER))then return false; endif;
		m_xLastRefillTick=CTimeMgr.Get().GetTime();
		CreateTimer(REFILL_TIMER, CGameTimeSpan.OneSecond()*1.0, true);
		return true;
	endproc;
	
	export proc void StopRefillTimer()
		if(!HasTimer(REFILL_TIMER))then return; endif;
		DeleteTimer(REFILL_TIMER);
	endproc;
	
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
            if(p_rxEvtPtr.GetInt(0)==REFILL_TIMER)then
            	var CGameTime xNow=CTimeMgr.Get().GetTime();
            	Refill(xNow-m_xLastRefillTick);
            	m_xLastRefillTick=xNow;
            else
            	super.HandleEvent(p_rxEvtPtr);
            endif;
        else
	    	super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;
	
	proc void Refill(CGameTimeSpan p_xDiff)
		var real fDuration=p_xDiff.GetSecondsF();
		var real fMaxAmount=m_iMaxHealAmount.ToReal();
		if(fDuration<=0.0)then
			fDuration=1.0;
		endif;
		var real fDiff=(fDuration/Math.Max(1.0,m_fRefillDuration))*fMaxAmount;
		m_fFillState+=fDiff;
		if(m_fFillState>=fMaxAmount)then
			m_fFillState=fMaxAmount;
			StopRefillTimer();
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("hitpoints",(m_fFillState+0.5).ToInt());
		endif;
	endproc;

	export proc void ObjArrived(CObjHndl p_xObj)
		var ^CFightingObj pxObj=cast<CFightingObj>(p_xObj.GetObj());
		if(pxObj==null)then return; endif;
		var real fHitpoints=pxObj^.GetHitpoints();
		var real fMaxHitpoints=pxObj^.GetMaxHitpoints();
		var real fDiff=m_fFillState-(fMaxHitpoints-fHitpoints);
		if(fDiff>=0.0)then
			pxObj^.FullHeal();
		else
			pxObj^.HealMe(m_fFillState);
			fDiff=0.0;
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("hitpoints",(fDiff+0.5).ToInt());
		endif;
		m_fFillState=fDiff;
		StartRefillTimer();
		if(HasAnim("fill_anim"))then
			InvokeGenericSCEvent(23,0.0);
		endif;
	endproc;
    
    export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Fntn";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_fRefillDuration;
		pxArc^ << m_iMaxHealAmount;
		m_xAvailable.DoKArc(pxArc^);
		m_xLastRefillTick.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Fntn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion==0)then
				var CHealRequest xInvalid;
				xInvalid.DoKArc(pxArc);
			endif;
			pxArc^ << m_fRefillDuration;
			pxArc^ << m_iMaxHealAmount;
			m_xAvailable.DoKArc(pxArc^);
			if(iVersion>=1)then
				m_xLastRefillTick.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
endclass;

class CDelayedArmySpawn inherit CGameObj
	
	class CSpawnJob
		export var string m_sClass;
		export var int m_iLevel;
		
		export constructor()
		endconstructor;
		
		/*export constructor(ref CDelayedArmySpawn.CSpawnJob p_rxRhs)
			m_sClass = p_rxRhs.m_sClass;
			m_iLevel = p_rxRhs.m_iLevel;
		endconstructor;
		
		export proc ref CDelayedArmySpawn.CSpawnJob op_Assign(ref CDelayedArmySpawn.CSpawnJob p_rxRhs)
			m_sClass = p_rxRhs.m_sClass;
			m_iLevel = p_rxRhs.m_iLevel;
			return this^;
		endproc;*/
	endclass;
	
	class CJobQueue
		var array CSpawnJob m_axJobs;
		
		export proc void Push(CDelayedArmySpawn.CSpawnJob p_xJob)
			m_axJobs.AddEntry(p_xJob);
		endproc;
		
		export proc ^CDelayedArmySpawn.CSpawnJob Push()
			return ^(m_axJobs.NewEntryRef());
		endproc;
		
		export proc CDelayedArmySpawn.CSpawnJob Pop()
			var CSpawnJob xJob = m_axJobs[0];
			m_axJobs.DeleteEntry(0);
			return xJob;			
		endproc;
		
		export proc int NumEntries()
			return m_axJobs.NumEntries();
		endproc;
		
		export proc bool IsEmpty()
			return m_axJobs.NumEntries()<=0;
		endproc;
		
		export proc void DoKArc(ref CArc p_rxArc)
			var int iC = m_axJobs.NumEntries();
			p_rxArc << iC;
			m_axJobs = iC;
			
			var int i;
			for(i=0) cond(i<iC) iter(++i) do
				p_rxArc << m_axJobs[i].m_sClass;
				p_rxArc << m_axJobs[i].m_iLevel;
			endfor;
		endproc;
	endclass;
	
	var CJobQueue m_xJobs;
	var real m_fSpawnDelay;
	var vec3 m_vSpawnPos;
	var vec3 m_vExitPos;
	var vec3 m_vDestination;
	var CObjHndl m_xGroup;
	var CObjHndl m_xSource;
	
	const int TIMER_ID = 98908;
	const int TIMER_START = 98907;
	
	
	export constructor()
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		InitEvents();
		SetVisible(false);
	endproc;
	
	export proc void SetSpawnDelay(real p_fDelay)
		m_fSpawnDelay = p_fDelay;
	endproc;
	
	export proc void SetSpawnPos(vec3 p_vPos)
		m_vSpawnPos = p_vPos;
	endproc;
	
	export proc void SetExitPos(vec3 p_vPos)
		m_vExitPos = p_vPos;
	endproc;
	
	export proc void SetDestinationPos(vec3 p_vPos)
		m_vDestination = p_vPos;
	endproc;
	
	export proc void SetGroup(CObjHndl p_xGroupHndl)
		m_xGroup = p_xGroupHndl;
	endproc;
	
	export proc void SetSourceObj(CObjHndl p_xSource)
		m_xSource=p_xSource;
	endproc;
	
	export proc void AddJob(string p_sClass, int p_iLevel)
		var ^CSpawnJob pxJob = m_xJobs.Push();
		pxJob^.m_sClass = p_sClass;
		pxJob^.m_iLevel = p_iLevel;
	endproc;

	export proc void StartAnim()
		var real fWait=OpenDoor();
		if(fWait>0.0)then
			DeleteTimer(TIMER_START);
			CreateTimer(TIMER_START, CGameTimeSpan.OneSecond() * fWait, true);
		else
			StartSpawn();
		endif;
	endproc;
	
	export proc void StartSpawn()
		Spawn();
		DeleteTimer(TIMER_ID);
		CreateTimer(TIMER_ID, CGameTimeSpan.OneSecond() * m_fSpawnDelay, true);
	endproc;
	
	export proc void Spawn()
    	if(!m_xJobs.IsEmpty()) then
			var CSpawnJob xJob = m_xJobs.Pop();
			
			// create obj
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj(xJob.m_sClass, GetOwner(), m_vSpawnPos);
			
			// set level
			var ^CFightingObj pxFightingObj = cast<CFightingObj>(pxO);
			if(pxFightingObj!=null) then
				pxFightingObj^.SetLevelClean(xJob.m_iLevel);
			endif;		
			
			// add to group
			if(m_xGroup.IsValid()) then
				var ^CGroupObj pxGroup = cast<CGroupObj>(m_xGroup.GetObj());
				if(pxGroup!=null) then
					pxGroup^.AddMember(pxO^.GetHandle());
				endif;
			endif;
			
			// let's go
			if(m_xSource.IsValid())then
				var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("CTheLite");
				xEvt.SetObjHandle(0,m_xSource);
				pxO^.HandleEvent(xEvt);
			else
				var ^CFightingObj pxFO = cast<CFightingObj>(pxO);
				if(pxFO!=null) then
					var ^CWalkToPos pxWalkTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxFO^.GetFSM(),"Walk2Pos"));
					pxWalkTask^.Init(pxFO^.GetHandle(),m_vExitPos, pxFO^.GetDefaultSpeed(), false, true, false, true);
			    	pxWalkTask^.SetUserCommand(true);
				    pxFO^.AddTask(pxWalkTask,false);
					
					pxWalkTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxFO^.GetFSM(),"Walk2Pos"));
					pxWalkTask^.Init(pxFO^.GetHandle(),m_vDestination, pxFO^.GetDefaultSpeed(), true, true, false, true);
			    	pxWalkTask^.SetUserCommand(true);
				    pxFO^.AddTask(pxWalkTask,true);
				endif;
			endif;
		else
			CloseDoor();
			DeleteTimer(TIMER_ID);
			Delete();
		endif;
	endproc;
	
	export proc real OpenDoor()
		if(!m_xSource.IsValid())then return 0.0; endif;
		var ^CGameObj pxObj=m_xSource.GetObj();
		if(!pxObj^.HasAnim("open"))then return 0.0; endif;
		pxObj^.SetAnim("open",1);
		return pxObj^.GetCurrentAnimLength();
	endproc;
	
	export proc void CloseDoor()
		if(!m_xSource.IsValid())then return; endif;
		var ^CGameObj pxObj=m_xSource.GetObj();
		if(!pxObj^.HasAnim("close"))then return; endif;
		pxObj^.SetAnim("close",1);
	endproc;
	
	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
            if(p_rxEvtPtr.GetInt(0)==TIMER_ID)then
				Spawn();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_START)then
				StartSpawn();
			endif;
		endif;
	endproc;

 	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="DeAS";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xJobs.DoKArc(pxArc^);
		pxArc^<< m_fSpawnDelay;
		pxArc^<< m_vSpawnPos;
		pxArc^<< m_vExitPos;
		pxArc^<< m_vDestination;
		m_xGroup.DoKArc(pxArc^);
		m_xSource.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DeAS")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xJobs.DoKArc(pxArc^);
			pxArc^<< m_fSpawnDelay;
			pxArc^<< m_vSpawnPos;
			pxArc^<< m_vExitPos;
			pxArc^<< m_vDestination;
			m_xGroup.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xSource.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
endclass;

class CDeleteMeDummy inherit CGameObj
	export constructor()
    	Delete();
	endconstructor;
endclass;

class CMiscNonIdiObj inherit CGameObj

	export proc void OnInit(bool p_bLoad)
        super.OnInit(p_bLoad);        
        SetSelectable(false);
        SetHitable(false);
        if(!p_bLoad)then
            SetType("MNIO");
        endif;
    endproc;

endclass;

/** A CPyramidCardObject will displayed within client pyramid. Use it to force display of information within pyramid */
class CPyramidCardObject inherit CGameObj

	var CObjHndl	m_xBaseObj;

	export constructor()
	endconstructor;

	export proc bool Init(^CGameObj p_pxGameObj)
		m_xBaseObj = p_pxGameObj^.GetHandle();
		SetPos(p_pxGameObj^.GetPos());

		var ^CAttribs pxAttr = GetAttribs();
		var ^CAttribs pxGameObjAttr = p_pxGameObj^.GetAttribs();
		if(pxAttr!=null && pxGameObjAttr!=null)then
			pxAttr^.SetValue("level", pxGameObjAttr^.GetValueInt("level"));
			pxAttr^.SetValue("hitpoints", pxGameObjAttr^.GetValueInt("hitpoints"));
			pxAttr^.SetValue("maxhitpoints", pxGameObjAttr^.GetValueInt("maxhitpoints"));
			pxAttr^.SetValue("CurTask", pxGameObjAttr^.GetValue("CurTask"));
			pxAttr^.SetValue("clientpyramid_slotid", pxGameObjAttr^.GetValue("clientpyramid_slotid"));
			pxAttr^.SetValue("ObjPath", pxGameObjAttr^.GetValue("ObjPath"));
			pxAttr^.SetValue("dead", true);
			pxAttr^.SetValue("TaskDescription", "");
			pxAttr^.SetValue("unit_count", true);
			pxAttr^.SetValue("Equip_Slot_0", pxGameObjAttr^.GetValue("Equip_Slot_0"));
			pxAttr^.SetValue("max_passengers", pxGameObjAttr^.GetValueInt("max_passengers"));
			pxAttr^.SetValue("can_attack", pxGameObjAttr^.GetValueInt("can_attack"));
			pxAttr^.SetValue("damage", pxGameObjAttr^.GetValueInt("damage"));
		endif;
		return true;
	endproc;

	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;

	export proc void SetClientPyramidSlotID(int p_iID)
		GetAttribs()^.SetValue("clientpyramid_slotid", p_iID);
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("PyCO");
			InitAttribs();
            SetHitable(false);
            SetSelectable(false);
            SetVisible(false);
		endif;
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
	endproc;

 	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="PyCO";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		
		m_xBaseObj.DoKArc(pxArc^);

		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="PyCO")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			
			m_xBaseObj.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;
endclass;

class CActionEffectObj inherit CGameObj
	
	const int TIMER_EFFECT = 112233;
	static var CPropDB ms_xParticleDB;	
		
	export constructor()		
	endconstructor;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetType("EFFO");
			InitAttribs();			
            SetHitable(false);
            SetSelectable(false);            
		endif;
		InitEvents();
	endproc;
	
	export proc void Init(string p_sEffectPath, int p_iNumLoops)
		if(ms_xParticleDB.GetRoot().NumSubs()==0)then
			var string sPath=CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Game/sequencer/particles.txt";
			if(!ms_xParticleDB.Load(sPath))then
				KLog.LogError("CActionEffectObj","ms_xParticleDB.Load() failed");
			endif;
		endif;
		
		p_sEffectPath.TrimLeft("/");
		p_sEffectPath.TrimRight("/");
		var ^CPropDB.CNode pxEffectNode=^(ms_xParticleDB[p_sEffectPath]);
		if(pxEffectNode^.Value().IsEmpty())then
			Delete();			
			return;
		endif;		
		SetGFX(pxEffectNode^.Value());		
		SetSLEAnim("anim",p_iNumLoops);		
		if(p_iNumLoops>0)then
			var real fAnimLength=pxEffectNode^.GetValueR("length",4.0f);		
			DeleteTimer(TIMER_EFFECT);
			CreateTimer(TIMER_EFFECT,CGameTimeSpan.OneSecond()*(fAnimLength*p_iNumLoops.ToReal()),false);
		endif;
	endproc;
	
	 proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
        if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
            if(p_rxEvtPtr.GetInt(0)==TIMER_EFFECT)then            	
            	Delete();
			endif;		
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;		
		
	endproc;

endclass;