class CFightingObj inherit CGameObj

	//========================================================================================
	//=== START MEMBER CLASSES ===============================================================
	//========================================================================================

	class CActionObj

		var CGameTime				m_xStartTime;
		var real					m_fDuration;
		export var string					m_sTTPath;
		export var procref <bool,string>	m_xOnCheckConditions;
		export var procref <void,string>	m_xOnStartAction;

		export constructor()
		endconstructor;

		export destructor()
		enddestructor;

		export proc void SetStartTime(CGameTime p_xStartTime)
			m_xStartTime = p_xStartTime;
		endproc;

		export proc ref CGameTime GetStartTime()
			return m_xStartTime;
		endproc;

		export proc void SetDuration(real p_fDuration)
			m_fDuration = p_fDuration;
		endproc;

		export proc ref real GetDuration()
			return m_fDuration;
		endproc;

		export proc void SetTTPath(string p_sTTPath)
			m_sTTPath = p_sTTPath;
		endproc;

		export proc ref string GetTTPath()
			return m_sTTPath;
		endproc;

		export proc bool op_Equal(ref CFightingObj.CActionObj p_rxObj)
			return (m_sTTPath == p_rxObj.m_sTTPath);
		endproc;

		export proc bool CheckConditions()
			if(!m_xOnCheckConditions.IsNull())then
				return m_xOnCheckConditions.Call(m_sTTPath);
			else
				return false;
			endif;
		endproc;

		export proc void StartAction()
			if(!m_xOnStartAction.IsNull())then
				m_xOnStartAction.Call(m_sTTPath);
			endif;
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			m_xStartTime.DoKArc(p_rxArc);
			p_rxArc << m_fDuration;
			p_rxArc << m_sTTPath;
		endproc;

	endclass;

	//========================================================================================

	class CDmgTimer

		export constructor()
		endconstructor;

		export destructor()
			if(m_pxTick!=null)then delete m_pxTick; endif;
		enddestructor;

		var CObjHndl	m_xSource;
		var int			m_iTimer;
		var real		m_fDmg;
		var ^CTimerIDTick	m_pxTick;
		var bool		m_bProjectile;
		var real		m_fPoisonDmg;
		var int			m_iMaxTickCount;

		export proc void Init(int p_iTimer, real p_fDmg, CObjHndl p_xSource, ^CTimerIDTick p_pxTick, bool p_bProjectile, real p_fPoisonDmg, int p_iTickCount)
			m_xSource		= p_xSource;
			m_fDmg			= p_fDmg;
			m_iTimer		= p_iTimer;
			m_pxTick		= p_pxTick;
			m_bProjectile	= p_bProjectile;
			m_fPoisonDmg	= p_fPoisonDmg;
			m_iMaxTickCount	= p_iTickCount;
		endproc;

		export proc ref int GetTimer()
			return m_iTimer;
		endproc;

		export proc ref real GetDmg()
			return m_fDmg;
		endproc;

		export proc ref CObjHndl GetSource()
			return m_xSource;
		endproc;

		export proc ^CTimerIDTick GetTick()
			return m_pxTick;
		endproc;

		export proc ref bool IsProjectile()
			return m_bProjectile;
		endproc;

		export proc ref real GetPoisonDmg()
			return m_fPoisonDmg;
		endproc;

		export proc ref int GetPoisonMaxTickCount()
			return m_iMaxTickCount;
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			m_xSource.DoKArc(p_rxArc);
			p_rxArc << m_iTimer;
			p_rxArc << m_fDmg;
			p_rxArc << m_bProjectile;
			p_rxArc << m_fPoisonDmg;
			p_rxArc << m_iMaxTickCount;

			if(m_pxTick==null)then
				m_pxTick=new CTimerIDTick();
			endif;
			m_pxTick^.DoKArc(p_rxArc);
		endproc;

		export proc void SetParentProcRef(procref <void,int> p_xProcRef)
			if(m_pxTick!=null)then
				m_pxTick^.m_xOnTickID=p_xProcRef;
			endif;
		endproc;

	endclass;

	//========================================================================================

	class CCamouflageLayer

		export var CFourCC	m_xType;
		export var int		m_iCount;
		export var bool		m_bDisabled;
		export var CObjList	m_xSrcObjs;

		export constructor()
		endconstructor;

		export destructor()
		enddestructor;

		export proc bool IsValid()
			return m_iCount>0;
		endproc;

		export proc void Inc()
			m_iCount++;
		endproc;

		export proc void SetType(string p_sType)
			m_xType=p_sType;
		endproc;

		export proc void Dec()
			m_iCount--;
			if(m_iCount<0)then
				m_iCount=0;
			endif;
		endproc;

		export proc void SetDisabled(bool p_bValue)
			m_bDisabled=p_bValue;
		endproc;

		export proc void AddSrcObj(CObjHndl p_xObj)
			m_xSrcObjs.AddEntry(p_xObj);
		endproc;

		export proc void RemSrcObj(CObjHndl p_xObj)
			var int iIdx=m_xSrcObjs.FindEntry(p_xObj);
			if(iIdx!=-1)then
				m_xSrcObjs.DeleteEntry(iIdx);
			endif;
		endproc;

		export proc bool op_Equal(string p_sOther)
			return (m_xType==p_sOther);
		endproc;

		export proc bool op_Equal(ref CFightingObj.CCamouflageLayer p_rxObj)
			return (m_xType==p_rxObj.m_xType);
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			var int iVersion=2;
			p_rxArc << iVersion;
			var string sType=m_xType.AsString();
			p_rxArc << sType;
			m_xType=sType;
			p_rxArc << m_iCount;
			if(iVersion>=2)then
				p_rxArc << m_bDisabled;
			endif;
		endproc;

	endclass;

	//========================================================================================

	class CPoisonTick inherit CEvtSink

		var int		m_iTimer;
		var real	m_fDmgPerTick;
		var int		m_iTickCount;
		var int		m_iMaxTickCount;
		export var procref <void, real> m_xOnTick;
		export var procref <void> m_xOnDecay;

		export constructor()
			m_xOnTick = OnTick;
			m_xOnDecay = OnDecay;
			m_iTimer = -1;
			m_iTickCount = 0;
		endconstructor;

		export destructor()
			if(m_iTimer!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
			endif;
		enddestructor;

		export proc bool op_LessEqual(real p_fOther)
			return m_fDmgPerTick<=p_fOther;
		endproc;

		export proc bool op_LessEqual(int p_iOther)
			return (m_iMaxTickCount-m_iTickCount)<=p_iOther;
		endproc;

		export proc bool op_GreaterEqual(real p_fOther)
			return m_fDmgPerTick>=p_fOther;
		endproc;

		export proc bool op_GreaterEqual(int p_iOther)
			return (m_iMaxTickCount-m_iTickCount)>=p_iOther;
		endproc;

		export proc ref CFightingObj.CPoisonTick op_Assign(ref CFightingObj.CPoisonTick p_rxOther)
			SetPoison(p_rxOther.GetDmgPerTick(), p_rxOther.GetMaxTickCount(), p_rxOther.GetCurTickCount());
			return(this^);
		endproc;

		proc void OnTick(real p_fReal)
		endproc;

		proc void OnDecay()
		endproc;

		export proc bool OnPush(ref CEvtPointer  p_rxEP)
			m_xOnTick.Call(m_fDmgPerTick);
			m_iTickCount++;
			if(m_iTickCount >= m_iMaxTickCount)then
				Reset();
				m_xOnDecay.Call();
			endif;
			return true;
		endproc;

		export proc void SetPoison(real p_fDmg, int p_iMaxTickCount, int p_iCurTickCount)
			if(m_iTimer==-1)then
				m_iTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 3.0, true);
				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
			endif;
			m_fDmgPerTick = p_fDmg;
			m_iMaxTickCount = p_iMaxTickCount;
			m_iTickCount = p_iCurTickCount;
		endproc;

		export proc ref int GetCurTickCount()
			return m_iTickCount;
		endproc;

		export proc int GetTicksLeft()
			return (m_iMaxTickCount - m_iTickCount);
		endproc;

		export proc ref int GetMaxTickCount()
			return m_iMaxTickCount;
		endproc;

		export proc ref real GetDmgPerTick()
			return m_fDmgPerTick;
		endproc;

		export proc void Reset()
			if(m_iTimer!=-1)then
				CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
				m_iTimer = -1;
			endif;
			m_iTickCount = 0;
			m_iMaxTickCount = 0;
			m_fDmgPerTick = 0.0;
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			var bool bTimerStart=(m_iTimer==-1);

			p_rxArc << m_iTimer;
			p_rxArc << m_fDmgPerTick;
			p_rxArc << m_iTickCount;
			p_rxArc << m_iMaxTickCount;

			if(m_iTimer!=-1 && bTimerStart)then
				m_iTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 3.0, true);
				CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
			endif;
		endproc;

	endclass;

	//========================================================================================

	class CFightAnim

		export constructor()
			m_bIsComboAnim = false;
			m_fProjectileTimeOutStart = -1.0;
			m_fProjectileTimeOutEnd = -1.0;
		endconstructor;

		export destructor()
		enddestructor;

		export proc void Clear()
			m_sAnim = "";
			m_fDelay = 0.0;
			m_sFollowAnim = "";
			m_fShootDelay = 0.0;
			m_bIsComboAnim = false;
			m_fProjectileTimeOutStart = -1.0;
			m_fProjectileTimeOutEnd = -1.0;
		endproc;

		export var string	m_sAnim;
		export var real		m_fDelay;
		export var real		m_fShootDelay;
		export var string	m_sFollowAnim;
		export var bool		m_bIsComboAnim;
		export var real		m_fProjectileTimeOutStart;
		export var real		m_fProjectileTimeOutEnd;

	endclass;

	//========================================================================================

	class CSpecialAbility

		class CAbilityData

			export constructor()
			endconstructor;

			export constructor(string p_sKey)
				m_sKey=p_sKey;
			endconstructor;

			export constructor(string p_sKey, string p_sValue)
				m_sKey=p_sKey;
				m_sValue=p_sValue;
			endconstructor;

			export constructor(ref CFightingObj.CSpecialAbility.CAbilityData p_rxRhs)
				m_sKey=p_rxRhs.m_sKey;
				m_sValue=p_rxRhs.m_sValue;
			endconstructor;

			export proc string 	GetKey() 				return m_sKey; 				endproc;
			export proc string 	GetValueS() 			return m_sValue; 			endproc;
			export proc int 	GetValueI() 			return m_sValue.ToInt(); 	endproc;
			export proc real 	GetValueF() 			return m_sValue.ToReal(); 	endproc;
			export proc bool 	GetValueB() 			return m_sValue=="true"; 	endproc;

			export proc void	SetKey(string p_sKey)	m_sKey=p_sKey;				endproc;
			export proc void 	SetValue(string p_sVal)	m_sValue=p_sVal; 			endproc;
			export proc void 	SetValue(int p_iVal) 	m_sValue=p_iVal.ToString(); endproc;
			export proc void 	SetValue(real p_fVal) 	m_sValue=p_fVal.ToString(); endproc;
			export proc void 	SetValue(bool p_bVal) 	m_sValue=p_bVal.ToString(); endproc;

			var string	m_sKey;
			var string	m_sValue;

		endclass;

		export constructor()
		endconstructor;

		export constructor(string p_sName)
			m_sName=p_sName;
		endconstructor;

		export constructor(^CTechTree.CNode p_pxNode)
			Initialize(p_pxNode);
		endconstructor;

		export proc bool Initialize(^CTechTree.CNode p_pxNode)
			if(p_pxNode==null) then return false; endif;
			m_axData=0;
			m_sName = p_pxNode^.GetName();
			m_bEnabled = p_pxNode^.GetSubValue("enabled", "false")=="true";

			var ^CTechTree.CNode pxIter=null;
			var int i, iC = p_pxNode^.NumSubs();
			for(i=0) cond(i<iC) iter(++i) do
				pxIter = p_pxNode^.GetSub(i);
				if(pxIter==null || pxIter^.GetName()=="enabled") then continue; endif;

				var ^CAbilityData pxData = ^(m_axData.NewEntryRef());
				pxData^.SetKey(pxIter^.GetName());
				pxData^.SetValue(pxIter^.GetValue());
			endfor;
			return true;
		endproc;

		proc ^CFightingObj.CSpecialAbility.CAbilityData GetValue(string p_sKey)
			var int i, iC=m_axData.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				if(m_axData[i].GetKey()==p_sKey) then
					return ^(m_axData[i]);
				endif;
			endfor;
			return null;
		endproc;

		export proc string		GetName()		return m_sName; 		endproc;
		export proc bool		IsEnabled()		return m_bEnabled; 		endproc;

		export proc void		SetEnabled(bool p_bOn) m_bEnabled=p_bOn;endproc;

		export proc string GetValueS(string p_sKey)
			var ^CAbilityData pxD = GetValue(p_sKey);
			if(pxD!=null) then
				return pxD^.GetValueS();
			endif;
			return "";
		endproc;

		export proc int GetValueI(string p_sKey)
			var ^CAbilityData pxD = GetValue(p_sKey);
			if(pxD!=null) then
				return pxD^.GetValueI();
			endif;
			return 0;
		endproc;

		export proc real GetValueF(string p_sKey)
			var ^CAbilityData pxD = GetValue(p_sKey);
			if(pxD!=null) then
				return pxD^.GetValueF();
			endif;
			return 0.0f;
		endproc;

		export proc bool GetValueB(string p_sKey)
			var ^CAbilityData pxD = GetValue(p_sKey);
			if(pxD!=null) then
				return pxD^.GetValueB();
			endif;
			return false;
		endproc;

		var string				m_sName;
		var bool				m_bEnabled;
		var array CAbilityData	m_axData;

	endclass;

	//========================================================================================

	class CSpecialAbilitiesContainer

		var array CSpecialAbility m_axAbilities;

		export constructor()
		endconstructor;

		export proc void Clear()
			m_axAbilities=0;
		endproc;

		export proc bool AddAbilities(^CTechTree.CNode p_pxAbsNode)
			if(p_pxAbsNode==null || p_pxAbsNode^.GetName()!="special_abilities") then
				return false;
			endif;

			var ^CTechTree.CNode pxIter = null;
			var int i, iC = p_pxAbsNode^.NumSubs();
			for(i=0) cond(i<iC) iter(++i) do
				pxIter = p_pxAbsNode^.GetSub(i);
				if(!m_axAbilities.NewEntryRef().Initialize(pxIter)) then
					KLog.LogWarn("Character", "Failed to Initialize Abilities");
					return false;
				endif;
			endfor;
			return true;
		endproc;

		export proc bool AddAbilities(^CTechTree.CNode p_pxAbsNode, bool p_bClearFirst)
			if(p_bClearFirst) then Clear(); endif;
			return AddAbilities(p_pxAbsNode);
		endproc;

		// Returns the SpecialAbility with passed name. Will be null if no ability with
		// such a name was found.
		export proc ^CFightingObj.CSpecialAbility GetAbility(string p_sName)
			var int i, iC = m_axAbilities.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				if(m_axAbilities[i].GetName()==p_sName) then
					return ^(m_axAbilities[i]);
				endif;
			endfor;
			return null;
		endproc;


		// Returns the SpecialAbility with passed name. Will be null if no ability with
		// such a name was found. If p_bOnlyIfEnabled is set to true the returned pointer will
		// also be null if the ability is not enabled.
		export proc ^CFightingObj.CSpecialAbility GetAbility(string p_sName, bool p_bOnlyIfEnabled)
			var ^CSpecialAbility pxA = GetAbility(p_sName);
			if(!p_bOnlyIfEnabled || (pxA!=null && pxA^.IsEnabled())) then
				return pxA;
			endif;
			return null;
		endproc;

	endclass;

	//========================================================================================

	class CPatrolInfo

		export var array vec3 	m_avWaypoints;
		export var int 			m_iMode;
		export var int 			m_iCurIdx;
		export var int 			m_iLastIdx;
		var int 		m_iSpeed;
		var bool		m_bPointReached;

		export constructor()
			m_iMode=0;
			m_iLastIdx=-1;
			m_iCurIdx=0;
			m_iSpeed=1;
			m_bPointReached=false;
		endconstructor;

		export constructor(ref array vec3 p_ravWaypoints,int p_iMode,int p_iSpeed)
			m_avWaypoints=p_ravWaypoints;
			m_iMode=p_iMode;
			m_iLastIdx=-1;
			m_iCurIdx=0;
			m_iSpeed=p_iSpeed;
			m_bPointReached=false;
		endconstructor;

		export proc int GetSpeed()
			return m_iSpeed;
		endproc;

		export proc ^vec3 GetNextWaypoint(vec3 p_vCurPos)
			var ^vec3 pvCurWP=null;
			if(m_iCurIdx>=0 && m_iCurIdx<m_avWaypoints.NumEntries())then
				pvCurWP= ^(m_avWaypoints[m_iCurIdx]);
			endif;
			if(pvCurWP==null)then
				return null;
			endif;
			if(!m_bPointReached)then
				return pvCurWP;
			endif;

			if(m_iMode==0)then// 0 = 1 2 3 4
				m_iCurIdx++;
			elseif(m_iMode==1)then// 1 = Circular Patrol ... Ex.: 1 2 3 4 1 2 3 4 1 ....
				m_iCurIdx++;
				m_iCurIdx=(m_iCurIdx%m_avWaypoints.NumEntries());
			else// 2 = Linear Patrol ... Ex.: 1 2 3 4 3 2 1 2 3 ....
				if(m_iCurIdx>m_iLastIdx)then
					m_iLastIdx=m_iCurIdx;
					m_iCurIdx++;
					if(m_iCurIdx>=m_avWaypoints.NumEntries())then
						m_iCurIdx=m_iLastIdx-1;
					endif;
				else
					m_iLastIdx=m_iCurIdx;
					m_iCurIdx--;
					if(m_iCurIdx<0)then
						m_iCurIdx=m_iLastIdx+1;
					endif;
				endif;
			endif;
			if(m_iCurIdx>=0 && m_iCurIdx<m_avWaypoints.NumEntries())then
				return ^(m_avWaypoints[m_iCurIdx]);
			endif;
			return null;
		endproc;

		export proc void PatrolPointReached()
			m_bPointReached = true;
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			var int iVersion=1;
			p_rxArc << iVersion;

			var int i,iC=m_avWaypoints.NumEntries();
			p_rxArc << iC;
			m_avWaypoints=iC;
			for(i=0)cond(i<iC)iter(i++)do
				p_rxArc << (m_avWaypoints[i]);
			endfor;

			p_rxArc << m_iMode;
			p_rxArc << m_iCurIdx;
			p_rxArc << m_iLastIdx;
			p_rxArc << m_iSpeed;
			if(iVersion==1)then
				p_rxArc << m_bPointReached;
			endif;
		endproc;

	endclass;

	//========================================================================================

	class CWeaponCache

		export constructor()
		endconstructor;

		export destructor()
		enddestructor;

		export var string		m_sWeaponPath;
		export var int			m_iWeaponSizeClass;
		export var string		m_sProjectile;
		export var real			m_fProjectileFallOff;
		export var real			m_fProjectileSpeed;
		export var real			m_fProjectileJitter;
		export var real			m_fWeaponDuration;
		export var array CFightingObj.CFightAnim	m_axAnims;

		export var real			m_fDmg;
		export var real			m_fProtection;
		export var real			m_fRangedProtection;
		export var real			m_fArmorPiercing;
		export var real			m_fMinAttackRange;
		export var bool			m_bPenetration;
		export var real			m_fPenetrationAngle;
		export var real			m_fHitRange;
		export var real			m_fEndDmg;
		export var real			m_fPoisonDmg;
		export var int			m_iPoisonMaxTickCount;
		export var real			m_fAttackRange;
		export var CBonus		m_xAttackBoni;
		export var CBonus		m_xDefenseBoni;

	endclass;

	//========================================================================================

	class CTempSortString

		export constructor()
		endconstructor;

		export destructor()
		enddestructor;

		export var string m_sString;
		export var real	m_fReal;

		export proc bool op_Greater(ref CFightingObj.CTempSortString p_rxOther)
			return (m_fReal<p_rxOther.m_fReal);
		endproc;

		export proc void op_Assign(string p_sVal)
			m_sString=p_sVal;
		endproc;

		export proc void op_Assign(real p_fVal)
			m_fReal=p_fVal;
		endproc;
	endclass;

	//========================================================================================

	class CTakeDmgCache
		export var ^CFightingObj	m_pxLastEnemy;
		export var real 			m_fDamage;
	endclass;

	//========================================================================================

	class CEnemyListSorter

		export var CObjHndl	m_xObj;
		export var int		m_iType;
		export var int		m_iAttackType;
		export var int		m_iIndex;
		export var bool		m_bCurrentTarget;
		export var bool		m_bInCombatRange;
		export var bool		m_bInPriorityList;
		export var bool		m_bPrioTarget;
		export var int		m_iValue;

		export var real		m_fDmg;

		export constructor()
		endconstructor;

		export destructor()
		enddestructor;

		export proc void CalculateValue()

			//Priorisierung: Units -> T³rme/Bunker -> Hõuser -> Mauern

			var ^CGameObj pxObj = m_xObj.GetObj();
			if(pxObj==null)then return; endif;
			var CFourCC xType = pxObj^.GetType();

			if(m_iAttackType==1)then
				//building attack unit
				if(xType=="CHTR" || xType=="ANML" || xType=="VHCL" || xType=="SHIP" || xType=="FIGHT")then
					m_iType = 3;
				elseif(xType=="BLDG")then
					if(cast<CTower>(pxObj)!=null)then
						m_iType = 0;
					elseif(cast<CWall>(pxObj)!=null)then
						m_iType = 2;
					else
						m_iType = 1;
					endif;
				else
					m_iType = 99;
				endif;
			else
				//standard
				if(xType=="CHTR" || xType=="ANML" || xType=="VHCL" || xType=="SHIP" || xType=="FIGHT")then
					m_iType = 0;
				elseif(xType=="BLDG")then
					if(cast<CTower>(pxObj)!=null)then
						m_iType = 1;
					elseif(cast<CWall>(pxObj)!=null)then
						m_iType = 3;
					else
						m_iType = 2;
					endif;
				else
					m_iType = 99;
				endif;
			endif;

			m_iValue=0;
			
			if(!m_bPrioTarget)then
				m_iValue+=100000;
			endif;

			m_iValue+=(m_iType*10000);
			
			if(!m_bInPriorityList)then
				m_iValue+=1000;
			endif;
			
			if(!m_bInCombatRange || !m_bCurrentTarget)then
				m_iValue+=500;
			endif;

			m_iValue+=m_iIndex;

		endproc;

		export proc bool op_Greater(ref CFightingObj.CEnemyListSorter p_rxOther)
			return m_iValue > p_rxOther.m_iValue;
		endproc;

	endclass;

	//========================================================================================
	//=== END MEMBER CLASSES =================================================================
	//========================================================================================


	//flags from P4://3DLib/Tools/KO/ObjTypes.txt
	export const int VIS_FLAG_BLDG_NIGHTMODE	=20;
	export const int VIS_FLAG_BLDG_INIGHTMODE	=17;
	export const int VIS_FLAG_ANML_PARTYCOL		=5;
	export const int VIS_FLAG_ANML_SADDLE		=6;
	export const int VIS_FLAG_ANML_HELMET		=7;
	export const int VIS_FLAG_ANML_ARMOR		=8;
	export const int VIS_FLAG_ANML_STANDARTE	=9;
	export const int VIS_FLAG_ANML_ARMORSADDLE	=10;
	export const int VIS_FLAG_ANML_MISC			=11;
	export const bitset VIS_FLAG_ANML_PLAYER_ALL =00000000000000000000111111100000b;

	export const bitset VIS_FLAG_ANML_WOUND_ALL =00001111111100000000000000000000b;
	export const int VIS_FLAG_ANML_WOUND_ARMLI	=20;
	export const int VIS_FLAG_ANML_WOUND_ARMRE	=21;
	export const int VIS_FLAG_ANML_WOUND_LEGLI	=22;
	export const int VIS_FLAG_ANML_WOUND_LEGRE	=23;
	export const int VIS_FLAG_ANML_WOUND_BELLI	=24;
	export const int VIS_FLAG_ANML_WOUND_BELRE	=25;
	export const int VIS_FLAG_ANML_WOUND_HEAD	=26; //das nur wenn der Kopf fehlt
	export const int VIS_FLAG_ANML_WOUND_TAIL	=27;

	export const int VIS_FLAG_BLDG_ECONOMY		=29;
	export const int VIS_FLAG_BLDG_DEFENSE		=30;
	export const int VIS_FLAG_BLDG_COMBAT		=31;
	export const int VIS_FLAG_VHCL_RAM_LOW		=5;
	export const int VIS_FLAG_VHCL_RAM_HIGH		=6;
	export const int VIS_FLAG_BLDG_SCARECROW	=5;
	export const int VIS_FLAG_CHTR_ACTIVATED	=16; //used for healer staffs

	export const bitset EFFECT_NONE					= 0b;
	export const bitset EFFECT_MEGALO_DRUMS 		= 01b;
	export const bitset EFFECT_RHINO_PENNANT		= 010b;
	export const bitset EFFECT_CHTR_WARCRY_3		= 0100b;
	export const bitset EFFECT_CHTR_WARCRY_4		= 01000b;
	export const bitset EFFECT_CHTR_WARCRY_5		= 010000b;
	export const bitset EFFECT_WILDBOAR_RAGE		= 0100000b;
	export const bitset EFFECT_MAMMOTH_TRUMPET		= 01000000b;
	export const bitset EFFECT_TRICERATOPS_PAW		= 010000000b;
	export const bitset EFFECT_AJE_WARPAINT_3		= 0100000000b;
	export const bitset EFFECT_AJE_WARPAINT_4		= 01000000000b;
	export const bitset EFFECT_AJE_WARPAINT_5		= 010000000000b;
	export const bitset EFFECT_ITEM_STONED			= 0100000000000b;
	export const bitset	EFFECT_ITEM_RING			= 01000000000000b;
	export const bitset EFFECT_ITEM_AMULETT1		= 010000000000000b;
	export const bitset EFFECT_SMOKER_INVIS			= 0100000000000000b;
	export const bitset EFFECT_AJE_CAMOUFLAGE		= 01000000000000000b;
	export const bitset EFFECT_ADA_SLOWHAND			= 010000000000000000b;
	export const bitset EFFECT_NO_ANIMAL_AGGRO		= 0100000000000000000b;
	export const bitset EFFECT_NINIGI_CAULDRON		= 01000000000000000000b;
	export const bitset EFFECT_KLEEMANN_AURA		= 010000000000000000000b;
	export const bitset EFFECT_SKULL_PROTECTOR		= 0100000000000000000000b;
	export const bitset EFFECT_KLEEMANN_DAMAGEBOOST	= 01000000000000000000000b;
	export const bitset EFFECT_DAS_ENDE				= 010000000000000000000000000000000b;



	export const int	BONUS_MAXHITPOINTS		= 0;
	export const int	BONUS_FOWRANGE			= 1;
	export const int	BONUS_DEFENSE			= 2;
	export const int	BONUS_DAMAGE			= 3;
	export const int	BONUS_MAXRESINV			= 4;
	export const int	BONUS_PRODSPEED_ANML	= 5;
	export const int	BONUS_DEFAULTSPEED		= 6;
	export const int	BONUS_XPGAIN			= 7;
	export const int	BONUS_RANGEDDEFENSE		= 8;
	export const int 	BONUS_RANGE				= 9;
	export const int	BONUS_DAMAGE_BLDG		= 10;
	export const int	BONUS_MELEEDAMAGE		= 11;
	export const int	BONUS_RANGEDAMAGE		= 12;
	export const int	NUM_BONUS_TYPES			= 13;	// << Update this one everytime a new type was added
	export const int	TIMER_EXPLOSION			= 1905;

	// values for statistics
//	export const int 	COLLECTED_SKULLS	= 5;
//	export const int  	KILLED_ENEMIES		= 6;
//	export const int 	KILLED_ANIMALS		= 7;
//	export const int 	DESTROYED_BUILDINGS = 8;
//	export const int	LOST_UNITS			= 9;
//	export const int	LOST_BUILDINGS		= 10;
//	export const int 	MAX_WORKER			= 16;
//	export const int	COLLECTED_WOOD		= 17;
//	export const int 	COLLECTED_STONE		= 18;
//	export const int	COLLECTED_FOOD		= 19;

	export const int	TIMER_AGGRO					=133;
	const int			TIMER_PREAGGRO				=156;
	const int			TIMER_ALARM					=134;
	export const int	TIMER_FLAGS					=135;
	export const int	TIMER_FLAGS2				=137;
	const int			TIMER_GETHITREACTION		=8192;
	const int			TIMER_MAMMOTH_TRUMPET		=460;
	const int			TIMER_TRICERATOPS_PAW		=461;
	const int			TIMER_INVUL					=10;
	const int			TIMER_STONED				=23;
	const int			TIMER_FROST					=24;
	const int			TIMER_FROSTIMMUNITY			=25;
	const int			TIMER_DUNDEED				=26;
	const int			TIMER_FINISHINGMOVE			=1337;
	const int			TIMER_ANML_IMMUNITY			=1357;
	const int			TIMER_HELPSHOUT				=268;
	export const int	CAMO_TIMER					=339;
	const int			TIMER_CHECK_HEAL			=783;
	export const int	TIMER_LEVELUP_INV			=579;
	export const int	TIMER_ISGETTINGHEALED		=580;
	export const int	TIMER_ISGETTINGHEALED_FX	=581;
	const int			TIMER_SELFHEAL				=28369;
	
	export const bitset	DIR_INVALID				=00000000h;
	export const bitset	DIR_FRONT				=00000001h;
	export const bitset	DIR_BACK				=00000002h;
	export const bitset	DIR_LEFT				=00000004h;
	export const bitset	DIR_RIGHT				=00000008h;
	export const bitset	DIR_FRONT_LEFT			=00000009h;
	export const bitset	DIR_FRONT_RIGHT			=0000000Ah;
	export const bitset	DIR_BACK_LEFT			=0000000Bh;
	export const bitset	DIR_BACK_RIGHT			=0000000Ch;

	//see RT#2341 for details
	const real			FALLOFFCONE_VAL			=0.5;	//bonus range per meter height difference

	//maximal path length for autoprod	
	const int			MAX_AUTOPROD_DIST = 96;

	//flag weapon damage type
	// synchronize with flags in CAttribIcon (Client)
	const bitset dwMELEE_PIERCE	= 0000001b;
	const bitset dwMELEE_POISON	= 0000010b;
	const bitset dwMELEE_AREA	= 0000100b;
	const bitset dwRANGE_PIERCE	= 0001000b;
	const bitset dwRANGE_POISON	= 0010000b;
	const bitset dwRANGE_AREA	= 0100000b;
	
	export static var real	ms_fDurationFactor;
	export var real			m_fDurationFactor;

	var bitset				m_dwEffectFlags;
	var array int			m_aiEffectFlags;

	var CGameTime			m_xLastFunctionTime;	// last Time an automatic Function has been called
	var CObjQuery			m_xFunctionUnits;		// Characters on which the Function is calling

	export var array CFightingObj.CWeaponCache	m_axWeaponCaches;
	export var CTakeDmgCache					m_xDmgCache;
	var real				m_fDefenseFactor;
	var real				m_fAttackFactor;

	var CRegionSink 		m_xSink;
	var CGuid				m_xRegionGuid;
	var CObjList			m_xRegionObjects;
	var CObjHndl			m_xProduceUnit;

	var int					m_iLastDamage;
	var CObjHndl			m_xGroup;
	var ^CPatrolInfo		m_pxPatrolInfo;


	var CFightingObj.CFightAnim			m_xCurrentFightAnim;
	var array CFightingObj.CFightAnim	m_axFightAnims;
	var array string					m_asFightAnims;

	var int 							m_iFinishingMoveIdx;
	var array CFightingObj.CActionObj	m_axAutoSpecialMoves;

	var CFightingObj.CPoisonTick		m_xPrimaryPoison;
	var CFightingObj.CPoisonTick		m_xSecondaryPoison;

	var array CFightingObj.CCamouflageLayer	m_axCamouflageLayers;

	var ^CWeaponMgr			m_pxWeaponMgr;
	var string				m_sCurrentWeapon;

	var real				m_fAlarmRange;
	var real				m_fDamage;
	var real				m_fFOWRange;
	var real				m_fProtection;
	var real				m_fRangedProtection;
	var real				m_fWeaponDuration;
	var real				m_fMinDamage;
	var int					m_iDefaultSpeed;
	var int					m_iMaxSpeed;
	var real				m_fArmorPiercing;

	var string				m_sProjectile;
	var string				m_sRealProjectile;
	var real				m_fProjectileDelay;
	var real				m_fProjectileFallOff;
	var real				m_fProjectileSpeed;
	var real				m_fProjectileJitter;
	var bool				m_bPenetration;
	var real				m_fPenetrationAngle;
	var real				m_fAttackDirection;
	var real				m_fHitDelay;
	var real 				m_fPoisonDmg;
	var int					m_iPoisonMaxTickCount;
	var int					m_iWeaponSizeClass;

	var real				m_fAttackRange;
	var real				m_fRealAttackRange;
	var real				m_fSecRangeM;
	var real				m_fRealSecRangeM;
	var real				m_fSecRangeS;
	var real				m_fRealSecRangeS;
	var real				m_fMinAttackRange;
	var real				m_fRealMinAttackRange;
	var real				m_fHitRange;
	var real				m_fRealHitRange;
	var real 				m_fEndDmg;
	var int					m_iAttackType;

	var real				m_fHitpoints;
	var real				m_fMaxHitpoints;
	
	var real				m_fHitTimeOut;

	var CFourCC				m_xWalkSet;
	var CFourCC				m_xHumpWalkSet;

	export var CTechTree	m_xTechTree;
	var bool				m_bTechTreeInitialized;

	var string				m_sTribe;
	var string				m_sObjPath;
	var string				m_sMyBuildAction;
	var int					m_iLevel;
	var CObjList			m_xPotEnemies;
	var CObjList			m_xPriorityList;
	var vec2				m_vFormationPriority;
	var CObjHndl			m_xTransportObj;
	var bool				m_bIsTrapped;
	var CObjHndl			m_xTrap;

	var CObjHndl			m_xReturnEnemy;
	var bool				m_bReturnNoUserBerserkerMode;
	var bool				m_bReturnUserCommand;

	var CObjHndl			m_xLastEnemy;

	var CObjList			m_xFXObjects;

	var bool				m_bStinaSlowhand;

	var vec3				m_vRallyPos;
	var CObjHndl			m_xRallyTarget;

	var bool				m_bMovableInFight;

	var int 				m_iAggressionState;	// 0 - stand ground
												// 1 - defensive, follow enemy in 20m circle
												// 2 - aggressive, follow enemy until death
												// -1 - stand ground / defensiv


	export var bool			m_bDoingFinishingMove;
	export var bool			m_bIsGettingFinished;

	var bool				m_bPatrolWalk;
	var bool				m_bStoppingPatrol;
	var bool 				m_bStraightWalkPatrol;

	var bool 				m_bAggressionWalk;
	var bool				m_bAggrTNoAnml;
	var vec3				m_vAggressionPos;

	var array CDmgTimer		m_axDmgTimer;
	var ^CTimerTick			m_pxTimeOnTick;
	var ^CTimerTick			m_pxTimeOffTick;

	var bool				m_bRotateSLEAction;
	var bool				m_bRotateAction;

	var bool				m_bIsCheckInUnit;

	var bool				m_bFeignDeath;
	var int					m_iInvulnerable;	//object is not vulnerable, TakeDmg and TakeDirectDmg do not affect health -1 = off, 0 = on;
	var bool				m_bFinished;		//object is kinda dead already, because a finishing move is initialized, all enemies should abort fight with this object
	var bool				m_bIntendedCamouflage;
	var bool				m_bLevelUpInvulnerable;

	var array int			m_aiActionTimerIDs;
	var array CActionObj	m_axActionObj;

	var int					m_iEntrenchState;	// 0 - not entrenched
												// 1 - entrenched
												// 2 - digging

	var vec3 				m_vHitReactionDir;
	export var int			m_iSizeClass;	//0 - can't throw/won't be thrown
											//1 - small (can be thrown/can't trow)	(this is a white JuDo belt)
											//10 - big (can throw/won't be thrown)	(and this is the black one)

	var CObjHndl			m_xCurEnemy;
	var CObjHndl			m_xLastFinishingVictim;
	var CGameTime			m_xLastHitDone;

	var ^CTaskMgr			m_pxTaskMgr;
	var ^CState				m_pxIdleState;

	var CBonus									m_xAttackBoni;
	var CBonus									m_xDefenseBoni;
	var array CBoniBucket						m_axBoni;
	export var CSpecialAbilitiesContainer		m_xAbilities;


	var bitset				m_dwLastHitDirection;

	//Misc flags
	export var bool			m_bIsBerserker;
	var bool				m_bInvisibleFlag;
	var bool				m_bDefensiveMode;
	export var bool			m_bGodMode;
	var bool				m_bRage;
	var bool				m_bIsRageUnit;
	export static var bool	ms_bToggleGodMode; //no need to save
	var bool				m_bScalpsGiven;
	var bool				m_bBLDGResBack;
	var bool				m_bSHIPResBack;
	var bool				m_bWeaponHasChanged;
	var bool				m_bOwnWeaponHasChanged;
	var bool				m_bHelpShoutDefend;
	var CObjHndl			m_xHelpShoutEnemy;
	var bool				m_bLDInvulnerable;

	var CGameTime			m_xLastHelpShout;
	export var bool			m_bIsHelpShout;
	var CObjList			m_xHelpDefendEnemies;
	var CObjList			m_xHelpAttackEnemies;
	var CGameTime			m_xChangeTargetTime;
	var real				m_fSelfHealAmount;
	var CObjHndl			m_xInvalid;



	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="FOba"; //FightingObj base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,21);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iAggressionState;
		(pxArc^) << m_sTribe;
		m_xTransportObj.DoKArc(pxArc^);
		m_xFXObjects.DoKArc(pxArc^);

		var int i, iC = m_aiActionTimerIDs.NumEntries();
		(pxArc^) << iC;
		for(i=0)cond(i<iC)iter(i++)do
			(pxArc^) << m_aiActionTimerIDs[i];
			m_axActionObj[i].DoKArc(pxArc^);
		endfor;

		m_xReturnEnemy.DoKArc(pxArc^);
		var bool bPatrolInfo=(m_pxPatrolInfo!=null);
		(pxArc^) << bPatrolInfo;
		if(bPatrolInfo)then
			m_pxPatrolInfo^.DoKArc(pxArc^);
		endif;

		pxArc^ << m_xRegionGuid;
		m_xProduceUnit.DoKArc(pxArc^);
		m_xRegionObjects.DoKArc(pxArc^);

		if(CSrvWrap.GetGame().IsLevelEd()) then
			//flush AggressionPos
			m_vAggressionPos=GetPos();
		endif;
		pxArc^ << m_vAggressionPos;

		pxArc^ << m_bInvisibleFlag;
		pxArc^ << m_bDefensiveMode;
		pxArc^ << m_bGodMode;
		pxArc^ << m_bScalpsGiven;
		pxArc^ << m_bBLDGResBack;
		pxArc^ << m_bSHIPResBack;
		pxArc^ << m_bWeaponHasChanged;
		pxArc^ << m_bOwnWeaponHasChanged;
		m_xLastHelpShout.DoKArc(pxArc^);
		pxArc^ << m_bIsHelpShout;
		m_xHelpDefendEnemies.DoKArc(pxArc^);
		m_xHelpAttackEnemies.DoKArc(pxArc^);
		pxArc^ << m_iEntrenchState;
		m_xCurEnemy.DoKArc(pxArc^);
		m_xLastFinishingVictim.DoKArc(pxArc^);
		pxArc^ << m_bFinished;
		pxArc^ << m_iInvulnerable;
		pxArc^ << m_bFeignDeath;
		pxArc^ << m_bRotateSLEAction;
		pxArc^ << m_bRotateAction;
		pxArc^ << m_bAggressionWalk;
		pxArc^ << m_bAggrTNoAnml;
		pxArc^ << m_bStraightWalkPatrol;
		pxArc^ << m_bStoppingPatrol;
		pxArc^ << m_bPatrolWalk;
		pxArc^ << m_bIsGettingFinished;
		pxArc^ << m_bDoingFinishingMove;
		m_xRallyTarget.DoKArc(pxArc^);
		pxArc^ << m_bStinaSlowhand;
		m_xLastEnemy.DoKArc(pxArc^);
		m_xReturnEnemy.DoKArc(pxArc^);
		pxArc^ << m_bReturnNoUserBerserkerMode;
		pxArc^ << m_bReturnUserCommand;
		pxArc^ << m_bIsTrapped;
		m_xTrap.DoKArc(pxArc^);
		m_xPotEnemies.DoKArc(pxArc^);
		pxArc^ << m_sMyBuildAction;
		pxArc^ << m_sObjPath;
		pxArc^ << m_bTechTreeInitialized;
		m_xPrimaryPoison.DoKArc(pxArc^);
		m_xSecondaryPoison.DoKArc(pxArc^);
		pxArc^ << m_iLastDamage;
		
		var bitset dwSavedFXFlags=m_dwEffectFlags&EFFECT_AJE_CAMOUFLAGE;
		pxArc^ << dwSavedFXFlags;
		
//				Maybe dont save this values, regions will update all units within by themselfs
/*		pxArc^ << m_dwEffectFlags;
		iC=m_aiEffectFlags.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^ << m_aiEffectFlags[i];
		endfor;
*/
		iC=m_axDmgTimer.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axDmgTimer[i].DoKArc(pxArc^);
		endfor;

		pxArc^ << m_bHelpShoutDefend;
		pxArc^ << m_bLDInvulnerable;

		iC=m_axCamouflageLayers.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			m_axCamouflageLayers[i].DoKArc(pxArc^);
		endfor;
		pxArc^ << m_bIntendedCamouflage;
		pxArc^ << m_iAttackType;
		pxArc^ << m_fHitTimeOut;

		m_xPriorityList.DoKArc(pxArc^);
		
		m_xChangeTargetTime.DoKArc(pxArc^);
		
		pxArc^ << m_bRage;
		pxArc^ << m_bIsRageUnit;
		
		pxArc^ << m_fSelfHealAmount;
		
		pxWalk^.Close();
	endproc;


	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="FOba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				(pxArc^) << m_iAggressionState;
			endif;
			if(iVersion>=2)then
				(pxArc^) << m_sTribe;
			endif;
			if(iVersion>=3)then
				m_xTransportObj.DoKArc(pxArc^);
			endif;
			if(iVersion>=4)then
				m_xFXObjects.DoKArc(pxArc^);
			endif;
			if(iVersion>=5)then
				var int i, iC;
				(pxArc^) << iC;
				for(i=0)cond(i<iC)iter(i++)do
					var int iValue;
					(pxArc^) << iValue;
					m_aiActionTimerIDs.AddEntry(iValue);
					var ^CFightingObj.CActionObj pxObj = ^(m_axActionObj.NewEntryRef());
					pxObj^.DoKArc(pxArc^);
				endfor;
			endif;
			if(iVersion>=6)then
				m_xReturnEnemy.DoKArc(pxArc^);
			endif;
			if(iVersion>=7)then
				delete m_pxPatrolInfo;
				var bool bPatrolInfo=false;
				(pxArc^) << bPatrolInfo;
				if(bPatrolInfo)then
					m_pxPatrolInfo=new CPatrolInfo();
					m_pxPatrolInfo^.DoKArc(pxArc^);
				endif;
			endif;
			if(iVersion>=8)then
				pxArc^ << m_xRegionGuid;

				m_xProduceUnit.DoKArc(pxArc^);
				m_xRegionObjects.DoKArc(pxArc^);
			endif;
			if(iVersion>=9)then
				pxArc^ << m_vAggressionPos;
			endif;
			if(iVersion>=10)then
				pxArc^ << m_bInvisibleFlag;
				pxArc^ << m_bDefensiveMode;
				pxArc^ << m_bGodMode;
				pxArc^ << m_bScalpsGiven;
				pxArc^ << m_bBLDGResBack;
				pxArc^ << m_bSHIPResBack;
				pxArc^ << m_bWeaponHasChanged;
				pxArc^ << m_bOwnWeaponHasChanged;
				m_xLastHelpShout.DoKArc(pxArc^);
				pxArc^ << m_bIsHelpShout;
				m_xHelpDefendEnemies.DoKArc(pxArc^);
				m_xHelpAttackEnemies.DoKArc(pxArc^);
				pxArc^ << m_iEntrenchState;
				m_xCurEnemy.DoKArc(pxArc^);
				m_xLastFinishingVictim.DoKArc(pxArc^);
				pxArc^ << m_bFinished;
				pxArc^ << m_iInvulnerable;
				pxArc^ << m_bFeignDeath;
				pxArc^ << m_bRotateSLEAction;
				pxArc^ << m_bRotateAction;
				pxArc^ << m_bAggressionWalk;
				if(iVersion>=19) then pxArc^ << m_bAggrTNoAnml; endif;
				pxArc^ << m_bStraightWalkPatrol;
				pxArc^ << m_bStoppingPatrol;
				pxArc^ << m_bPatrolWalk;
				pxArc^ << m_bIsGettingFinished;
				pxArc^ << m_bDoingFinishingMove;
				m_xRallyTarget.DoKArc(pxArc^);
				pxArc^ << m_bStinaSlowhand;
				m_xLastEnemy.DoKArc(pxArc^);
				m_xReturnEnemy.DoKArc(pxArc^);
				pxArc^ << m_bReturnNoUserBerserkerMode;
				pxArc^ << m_bReturnUserCommand;
				pxArc^ << m_bIsTrapped;
				m_xTrap.DoKArc(pxArc^);
				m_xPotEnemies.DoKArc(pxArc^);
				pxArc^ << m_sMyBuildAction;
				pxArc^ << m_sObjPath;
				pxArc^ << m_bTechTreeInitialized;
				m_xPrimaryPoison.DoKArc(pxArc^);
				m_xSecondaryPoison.DoKArc(pxArc^);
				pxArc^ << m_iLastDamage;
			
				if(iVersion>=21)then	
					var bitset dwSavedFXFlags;
					pxArc^ << dwSavedFXFlags;
					
					if((dwSavedFXFlags&EFFECT_AJE_CAMOUFLAGE)!=0d) then
						//KLog.LogWarn("CHP","SavedFX Cam:"+GetName());
						SetEffectFlag(EFFECT_AJE_CAMOUFLAGE, true);
					endif;
				endif;

//				Maybe dont save this values, regions will update all units within by themselfs
/*				pxArc^ << m_dwEffectFlags;
				var int i,iC;
				pxArc^ << iC;
				m_aiEffectFlags=iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxArc^ << m_aiEffectFlags[i];
				endfor;
*/			endif;
			if(iVersion>=11)then
				var int i,iC;
				pxArc^ << iC;
				for(i=0)cond(i<iC)iter(i++)do
					var ^CDmgTimer pxTimer=^(m_axDmgTimer.NewEntryRef());
					pxTimer^.DoKArc(pxArc^);
					pxTimer^.SetParentProcRef(ProvideDmg);
				endfor;
			endif;
			if(iVersion>=12)then
				pxArc^ << m_bHelpShoutDefend;
			endif;
			if(iVersion>=13)then
				pxArc^ << m_bLDInvulnerable;
			endif;
			if(iVersion>=14)then
				var int i,iC;
				pxArc^ << iC;
				m_axCamouflageLayers=iC;
				for(i=0)cond(i<iC)iter(i++)do
					m_axCamouflageLayers[i].DoKArc(pxArc^);
				endfor;
				pxArc^ << m_bIntendedCamouflage;
			endif;
			if(iVersion>=15)then
				pxArc^ << m_iAttackType;
			endif;
			if(iVersion>=16)then
				pxArc^ << m_fHitTimeOut;
			endif;
			if(iVersion>=17)then
				m_xPriorityList.DoKArc(pxArc^);
			endif;
			if(iVersion>=18)then
				m_xChangeTargetTime.DoKArc(pxArc^);
			endif;
			if(iVersion>=20)then
				pxArc^ << m_bRage;
				pxArc^ << m_bIsRageUnit;
				pxArc^ << m_fSelfHealAmount;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		SetAggressionState(m_iAggressionState);
		m_pxWeaponMgr^.UpdateAll();
		UpdateEquipment();
		UpdateFightFactors();

		if(!m_xRegionGuid.IsNull())then
			var int iIdx = CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
			if (iIdx>=0) then
				var ^CRegion pxRegion = CSrvWrap.GetRegionMgr().GetRegion(iIdx);
				if (pxRegion!=null) then
					m_xSink.SetRegion(pxRegion);
					pxRegion^.BindToObj(GetHandle());
					m_xSink.Subscribe();
				endif;
			else
				var CGuid xG; m_xRegionGuid = xG;
			endif;
		endif;

		if(m_xProduceUnit.IsValid())then
			var ^CVirtualProduceUnit pxUnit = cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
			if(pxUnit!=null)then
				pxUnit^.Init(GetHandle());
			endif;
		endif;

		var ^CInventory pxInv = GetInventory();
		if (pxInv!=null) then
			var int i, iC = pxInv^.Count();
			var CObjList xList;
			for(i=0) cond(i<iC) iter(++i) do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if (xList[i].IsValid()) then
					var ^CGameObj pxItem = xList[i].GetObj();
					var ^CItem pxI = cast<CItem>(pxItem);
					if (pxI != null) then
						RemoveItem(pxI^.GetHandle());
						AddItem(pxI^.GetHandle());
					endif;
				endif;
			endfor;
		endif;

		UpdateCamouflageLayers();

	endproc;
	
	export proc void SetLastDamage(int p_iOwner)
		m_iLastDamage=p_iOwner;
	endproc;
	
	export proc int GetLastDamage()
		return m_iLastDamage;
	endproc;


	// CHEAT for testing
	export static proc void ToggleGodModeForAllObjects()
		ms_bToggleGodMode = !ms_bToggleGodMode;
		var CObjQuery xQuery;
		var CObjList xList;
		xQuery.Execute(xList);
		var int i,iC=xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
			if(pxObj!=null)then
				pxObj^.SetGodMode(ms_bToggleGodMode);
			endif;
		endfor;
	endproc;

	export proc void AddItemName(string p_sName)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			if(p_sName.IsEmpty() && !pxAttr^.GetValue("inventory_item_name").IsEmpty())then
				RemoveFX("fx_unique_pickup");
			elseif(!p_sName.IsEmpty() && pxAttr^.GetValue("inventory_item_name").IsEmpty())then
				var CObjHndl xHndl=AddFX("fx_unique_pickup",-1.0);
				var CFourCC xLink;
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
				//xHndl.GetObj()^.SetAnim("anim");
			endif;
			pxAttr^.SetValue("inventory_item_name",p_sName);
		endif;
	endproc;

	export proc void AddItem(CObjHndl p_xItem)
		var ^CInventory pxInv = GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.AddItem(pxItem^.GetHandle());
		var CFourCC xLink="INVE";
		pxItem^.LinkAction(GetHandle(), xLink);
		pxItem^.SetVisible(false);
		pxItem^.OnTaken(this);
		AddItemName(pxItem^.GetName());
		InvokeGenericSCEvent(38,0.6f);
	endproc;

	export proc void RemoveItem(CObjHndl p_xItem)
		var ^CInventory pxInv = GetInventory();
		if(pxInv==null)then return; endif;
		var ^CItem pxItem=cast<CItem>(p_xItem.GetObj());
		if(pxItem==null)then return; endif;
		pxInv^.RemItem(pxItem^.GetHandle());
		pxItem^.OnDropped(this);
		pxItem^.TerminateAction();
		AddItemName("");
	endproc;
	
	export proc int AddProdQueueItem(string p_sClass)

		var int iID=-1;

		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());

		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return iID; endif;

		var string sProdQueue=pxAttr^.GetValue("ProdQueue");
		if(sProdQueue.GetLength()>400)then return iID;endif;

		if(pxPlayer!=null) then
			var ^CTechTree.CNode pxTTNode=pxPlayer^.GetPlayerTechTree().FindNode(p_sClass);
			if(pxTTNode!=null)then
				iID=pxTTNode^.GetHashValue();
			endif;
		endif;
		if(iID!=-1)then
			sProdQueue+=":"+iID.ToString();
			pxAttr^.SetValue("ProdQueue",sProdQueue);
		endif;

		return iID;

	endproc;
	
	export proc void RemoveProdQueueItem(int p_iID)

		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var string sProdQueue=pxAttr^.GetValue("ProdQueue");
		var array string asTokens;
		sProdQueue.Split(asTokens,":",true);
		var int i,iC=asTokens.NumEntries();
		var string sProdID=p_iID.ToString();
		for(i=0)cond(i<iC)iter(i++)do
			if(asTokens[i]==sProdID)then
				asTokens.DeleteEntry(i);
				sProdQueue.Empty();
				var int iK,iKC=asTokens.NumEntries();
				for(iK=0)cond(iK<iKC)iter(iK++)do
					sProdQueue+=asTokens[iK]+":";
				endfor;
				pxAttr^.SetValue("ProdQueue",sProdQueue);
				break;
			endif;
		endfor;

	endproc;

	export proc void SetGodMode(bool p_bState)
		m_bGodMode=p_bState;
	endproc;

	export proc real GetBonusSum(int p_iType)
		var ^CBoniBucket pxB = GetBoniBucket(p_iType);
		var int i, iC = pxB^.NumEntries();
		var real fSum = 0.0f;
		for (i=0) cond(i<iC) iter(++i) do
			fSum += pxB^[i].m_fBonus;
		endfor;
		return fSum;
	endproc;

	export proc void ForceBoniUpdate()
		if (GetHitpoints() <= 0.0f) then return; endif;
		ChangeMaxHitpoints(GetTechTreeHitpoints());
		UpdateFOW();
		UpdateRangeNDamageInformation();
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
		AddTemporaryAttackBoni(GetDmg());
		AddTemporaryRangeBoni();
		ClearDamageCache();
	endproc;

	export proc void AddCamouflageEffect(string p_sType)
		AddCamouflageEffect(p_sType,CObjHndl.Invalid());
	endproc;

	export proc void AddCamouflageEffect(string p_sType, CObjHndl p_xSrcObj)

		if(p_sType=="disg")then
			if(HasTimer(CAMO_TIMER))then
				m_bIntendedCamouflage=true;
				return;
			endif;
		endif;

		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1)then
			m_axCamouflageLayers[iIdx].Inc();
			m_axCamouflageLayers[iIdx].SetType(p_sType);
			if(p_xSrcObj.IsValid())then
				m_axCamouflageLayers[iIdx].AddSrcObj(p_xSrcObj);
			endif;
		else
			var ^CFightingObj.CCamouflageLayer pxLayer=^(m_axCamouflageLayers.NewEntryRef());
			pxLayer^.Inc();
			pxLayer^.SetType(p_sType);
			if(p_xSrcObj.IsValid())then
				pxLayer^.AddSrcObj(p_xSrcObj);
			endif;
		endif;

		UpdateCamouflageLayers();

	endproc;

	export proc bool HasCamouflageEffect(string p_sType)
		var CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		return (iIdx>-1);
	endproc;

	export proc bool HasValidCamouflageEffect(string p_sType)
		var CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		return (iIdx>-1 && m_axCamouflageLayers[iIdx].IsValid());
	endproc;

	export proc void RemoveCamouflageEffect(string p_sType)
		RemoveCamouflageEffect(p_sType,CObjHndl.Invalid());
	endproc;

	export proc void RemoveCamouflageEffect(string p_sType, CObjHndl p_xSrcObj)
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType(p_sType);
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1)then
			m_axCamouflageLayers[iIdx].Dec();
			if(p_sType=="disg") then m_axCamouflageLayers[iIdx].m_iCount=0; endif; //don't refcount "disg" (ninigi_ninja)
			m_axCamouflageLayers[iIdx].RemSrcObj(p_xSrcObj);
		endif;

		UpdateCamouflageLayers();

	endproc;

	export proc void Reveal()
		var int i,iC=m_axCamouflageLayers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axCamouflageLayers[i]=="")then
				m_axCamouflageLayers.DeleteEntry(i);i--;iC--;
				continue;
			endif;
			if(m_axCamouflageLayers[i]=="disg")then
				m_axCamouflageLayers.DeleteEntry(i);i--;iC--;
				continue;
			endif;
			if(m_axCamouflageLayers[i]=="entr")then
				m_axCamouflageLayers.DeleteEntry(i);i--;iC--;
				continue;
			endif;
		endfor;
		if(CanDisguise())then
			ResetCamouflageTimer();
			AddCamouflageEffect("disg");
		endif;
		UpdateCamouflageLayers();
	endproc;

	export proc void UpdateCamouflageLayers()
		var bool bCamouflage=false;
		var int i,iC=m_axCamouflageLayers.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axCamouflageLayers[i].IsValid() && !m_axCamouflageLayers[i].m_bDisabled)then
				bCamouflage=true;
			endif;
		endfor;
		SetCamouflage(bCamouflage);
	endproc;

	export proc void SetCamouflage(bool p_bValue, bool p_bVisible)
		super.SetCamouflage(p_bValue, p_bVisible);
	endproc;

	export proc void SetCamouflage(bool p_bValue)
		if(GetCamouflage()==p_bValue)then return; endif;
		if(GetTransportObj().IsValid() && !IsOnOpenTransporter())then return; endif;

		if(CanDisguise())then
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("active_disguise",p_bValue);
			endif;
			if(p_bValue)then
				var CObjHndl xHndl = AddFX("fx_ninja_disguise",-1.0);
				AddRangedBuff("is_camouflaged");
				if(xHndl.IsValid())then
					var CFourCC xLink = "";
					xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
				endif;
			else
				RemoveFX("fx_ninja_disguise");
				RemoveRangedBuff("is_camouflaged");
			endif;
		endif;
		if(p_bValue && HasTimer(CAMO_TIMER))then
			return;
		endif;
		super.SetCamouflage(p_bValue);
	endproc;

	export proc void OnReveal()
	endproc;

	///////
	//	SetEffectFlag()
	///////
	export proc void SetEffectFlag(bitset p_dwFlag, bool p_bOn)

		var int iIndex = -1;

		if(p_dwFlag==EFFECT_MEGALO_DRUMS)then
			iIndex = 0;
		elseif(p_dwFlag==EFFECT_RHINO_PENNANT)then
			iIndex = 1;
		elseif(p_dwFlag==EFFECT_CHTR_WARCRY_3)then
			iIndex = 2;
		elseif(p_dwFlag==EFFECT_CHTR_WARCRY_4)then
			iIndex = 3;
		elseif(p_dwFlag==EFFECT_CHTR_WARCRY_5)then
			iIndex = 4;
		elseif(p_dwFlag==EFFECT_WILDBOAR_RAGE)then
			iIndex = 5;
		elseif(p_dwFlag==EFFECT_TRICERATOPS_PAW)then
			iIndex = 6;
		elseif(p_dwFlag==EFFECT_NINIGI_CAULDRON)then
			iIndex = 7;
		elseif(p_dwFlag==EFFECT_AJE_WARPAINT_3)then
			iIndex = 9;
		elseif(p_dwFlag==EFFECT_AJE_WARPAINT_4)then
			iIndex = 10;
		elseif(p_dwFlag==EFFECT_AJE_WARPAINT_5)then
			iIndex = 11;
		elseif(p_dwFlag==EFFECT_ITEM_STONED) then
			iIndex = 12;
		elseif(p_dwFlag==EFFECT_ITEM_RING) then
			iIndex = 13;
		elseif(p_dwFlag==EFFECT_ITEM_AMULETT1) then
			iIndex = 14;
		elseif(p_dwFlag==EFFECT_SMOKER_INVIS) then
			if(p_bOn)then
				AddCamouflageEffect("smok");
			else
				RemoveCamouflageEffect("smok");
			endif;
			iIndex = 15;
		elseif(p_dwFlag==EFFECT_AJE_CAMOUFLAGE) then
			iIndex = 16;
		elseif(p_dwFlag==EFFECT_MAMMOTH_TRUMPET) then
			iIndex = 17;
		elseif(p_dwFlag==EFFECT_ADA_SLOWHAND)then
			iIndex = 18;
		elseif(p_dwFlag==EFFECT_NO_ANIMAL_AGGRO)then
			iIndex = 19;
		elseif(p_dwFlag==EFFECT_KLEEMANN_AURA)then
			iIndex = 20;
		elseif(p_dwFlag==EFFECT_SKULL_PROTECTOR)then
			iIndex = 21;
		endif;

		if(iIndex!=-1)then

			if(p_bOn)then
				if(m_aiEffectFlags[iIndex]==0)then
					//new effect
					if(iIndex==2 || iIndex==3 || iIndex==4)then
						//warcry
						var ^CGameObj pxObj = AddFX("fx_warcry",2.0).GetObj();
						if(pxObj!=null)then
							var CFourCC xLink;
							pxObj^.LinkAction(GetHandle(),xLink);
						endif;
						pxObj = AddFX("fx_warcry_lite",-1.0).GetObj();
						if(pxObj!=null)then
							var CFourCC xLink;
							pxObj^.LinkAction(GetHandle(),xLink);
						endif;
					elseif(iIndex==9 || iIndex==10 || iIndex==11)then
						AddRangedBuff("less_damage");
					elseif(iIndex==18)then
						AddRangedBuff("less_attack_speed");
					elseif(iIndex==19)then
						AddRangedBuff("no_animal_aggro");
					elseif(iIndex==20)then
						//Kleemann Aura Effect
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter(CHero.KLEEMANN_AURA_PATH);
						endif;
						//AddRangedBuff("no_animal_aggro");
					elseif(iIndex==21)then
						//skull protector aura effect
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.EnableFilter(CSkullProtector.PATH);
						endif;
						//AddRangedBuff("");
					endif;
				endif;
				m_aiEffectFlags[iIndex]++;
			else
				m_aiEffectFlags[iIndex]--;
				if(m_aiEffectFlags[iIndex]==0)then
					//new effect
					if(iIndex==2 || iIndex==3 || iIndex==4)then
						//warcry
						RemoveFX("fx_warcry");
						RemoveFX("fx_warcry_lite");
					elseif(iIndex==9 || iIndex==10 || iIndex==11)then
						RemoveRangedBuff("less_damage");
					elseif(iIndex==18)then
						RemoveRangedBuff("less_attack_speed");
					elseif(iIndex==19)then
						RemoveRangedBuff("no_animal_aggro");
					elseif(iIndex==20)then
						//Kleemann Aura Effect
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.DisableFilter(CHero.KLEEMANN_AURA_PATH);
						endif;
						//RemoveRangedBuff("no_animal_aggro");
					elseif(iIndex==21)then
						//skull protector aura effect
						var ^CTechTreeDef pxDef=GetTechTreeDef();
						if(pxDef!=null)then
							pxDef^.DisableFilter(CSkullProtector.PATH);
						endif;
						//AddRangedBuff("");
					endif;
				endif;
				if(iIndex==16) then
					m_aiEffectFlags[iIndex]=0;
					RemoveRangedBuff("is_camouflaged");
				endif;
				
				if(iIndex==17) then
					m_aiEffectFlags[iIndex]=0;
				endif;
			endif;

			if(m_aiEffectFlags[iIndex]>0)then
				m_dwEffectFlags |= p_dwFlag;
				if (iIndex == 12) then
					//m_pxTaskMgr^.Break();
				elseif(iIndex == 16) then
					//SetCamouflage(true, false);
					RemAllLinkGFX();
					begin SetAttribs;
						//needed for AI
						var ^CAttribs pxAttr = GetAttribs();
						if(pxAttr!=null)then
							pxAttr^.SetValue("active_camouflage",true);
						endif;
					end SetAttribs;
					SetGFX(GetCamouflageAnml());

					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_PARTYCOL,false);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_SADDLE,false);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_HELMET,false);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMOR,false);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_STANDARTE,false);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_ARMORSADDLE,false);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_ANML_MISC,false);

					AddRangedBuff("is_camouflaged");

				endif;
			else
				m_aiEffectFlags[iIndex] = 0;
				m_dwEffectFlags &= ~p_dwFlag;
				if(iIndex==16) then
					UpdateGfx();
					begin SetAttribs;
						//needed for AI
						var ^CAttribs pxAttr = GetAttribs();
						if(pxAttr!=null)then
							pxAttr^.SetValue("active_camouflage",false);
						endif;
					end SetAttribs;
					AddSpecialActionTimer("Actions/Aje/Moves/CHTR/camouflage");
					SetCamouflage(false, false);
				endif;
			endif;

/*			if(iIndex==15 || iIndex==16) then
				var int iV = m_aiEffectFlags[15] - m_aiEffectFlags[16];
				if (iV==0) then
					return;
				elseif (iV < 0) then
					SetCamouflage(true, false);
				else
					SetCamouflage(true);
				endif;
			endif;
*/
			if(iIndex==7)then
				var int iV=m_aiEffectFlags[7];
				var ^CTechTreeDef pxDef=GetTechTreeDef();
				if(iV>0)then
					pxDef^.EnableFilter(CCauldron.EFFECT_PATH);
				else
					pxDef^.DisableFilter(CCauldron.EFFECT_PATH);
				endif;
			endif;
		endif;

		//Updating interface
		UpdateRangeNDamageInformation();
		AddTemporaryAttackBoni(GetDmg());
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
	endproc;

	export proc void AddRangedBuff(string p_sBuff)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var string sBuffs=pxAttr^.GetValue("BuffDecals");
		var string sSearchBuff=";"+p_sBuff;
		if(sBuffs.Find(sSearchBuff)!=-1)then return; endif;
		sBuffs+=sSearchBuff;
		pxAttr^.SetValue("BuffDecals",sBuffs);
	endproc;

	export proc void RemoveRangedBuff(string p_sBuff)
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;
		var string sBuffs=pxAttr^.GetValue("BuffDecals");
		var string sSearchBuff=";"+p_sBuff;
		if(sBuffs.Find(sSearchBuff)==-1)then return; endif;
		sBuffs.Replace(sSearchBuff,"");
		pxAttr^.SetValue("BuffDecals",sBuffs);
	endproc;

	export proc void SetOnWall(bool p_bValue)
		super.SetOnWall(p_bValue);
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
	endproc;

	proc string GetCamouflageAnml()
		var string sCreep=(CSrvWrap.GetCurLevel()^.GetLevelInfo().GetGenericData())["Base"].GetValueS("CamCreep","");
		if(!sCreep.IsEmpty()) then return sCreep; endif;
	
		var string sSetting = CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
		if (sSetting == "Jungle") then
			return "Parasaurolophus";
		elseif (sSetting=="Northland") then
			return "Megaloceros";
		elseif (sSetting=="Savanna") then
			return "Maiasauria";
		elseif (sSetting=="Ashvalley") then
			return "Iguanodon";
		elseif (sSetting=="Icewaste") then
			return "Megaloceros";
		endif;

		return "";
	endproc;

	///////
	//	GetEffectFlag()
	///////
	export proc bool GetEffectFlag(bitset p_dwFlag)
		return ((m_dwEffectFlags & p_dwFlag)==p_dwFlag);
	endproc;


	export proc ^CBoniBucket	GetBoniBucket(int p_iType)
		return ^m_axBoni[p_iType];
	endproc;

	export var CObjList m_xGropWalkMembersTmp;
	export proc void OnTaskStarted()
		m_xGropWalkMembersTmp.Clear();
	endproc;

	export proc void OnEmptyTaskList()
		m_xGropWalkMembersTmp.Clear();
	endproc;

	///////
	//	OnActionStart()
	///////
	export proc void OnActionStart()
		GetFSM()^.Enable(false);
	endproc;

	export proc void OnActionPreEnd(bool p_bBroken)
		m_xGropWalkMembersTmp.Clear();
		if(!p_bBroken) then
			var ^CGroupWalk pxGW=GetCurrentGroupWalk();
			if(pxGW!=null) then
				var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
				if(pxCurWalkTask!=null) then
					var CObjList xObjs;//Execute_Q_Walk
					pxGW^.GetMemberList(m_xGropWalkMembersTmp);
				endif;
			endif;
		endif;
	endproc;

	///////
	//	OnActionEnd(bool p_bBroken)
	///////
	export proc void OnActionEnd(bool p_bBroken)
		if(m_bPatrolWalk)then
			if(!p_bBroken)then
				if(m_pxPatrolInfo!=null)then
					m_pxPatrolInfo^.PatrolPointReached();
				endif;
			endif;
			m_bPatrolWalk = false;
		endif;

		if(m_pxTaskMgr!=null)then
			var ^CTask pxTask = m_pxTaskMgr^.GetCurTask();
			if(pxTask!=null)then
				if(p_bBroken)then
					pxTask^.ActionCanceled();
				else
					pxTask^.ActionSucceeded();
				endif;
			endif;
		endif;

		GetFSM()^.Enable(true);

		if(m_bRotateAction)then
			m_bRotateAction = false;
			return;
		endif;

		if(cast<CCharacter>(this)==null&&cast<CAnimal>(this)==null) then
			var bool bSetIdleAnim;
			if(m_pxTaskMgr!=null)then
				var ^CTask pxCurTask=m_pxTaskMgr^.GetCurTask();
				if(pxCurTask!=null) then
					bSetIdleAnim=pxCurTask^.OnActionEnd(p_bBroken);
				endif;
			endif;
			if (bSetIdleAnim && !IsDead() && m_fHitpoints>0.0f && !IsFeignDeath() && !m_bRotateSLEAction && !IsGroupWalkPending()) then
				SetIdleAnim();
			endif;
		endif;
	endproc;

	export proc void SetIdleAnim()
		if(HasAnim("standanim") && GetCurrentAnimName()!="standanim") then
			SetAnim("standanim",3);
		endif;
	endproc;


	///////
	//	ctor
	///////
	constructor()
		m_bGodMode=false;
		m_iLastDamage=-1;
		m_iFinishingMoveIdx=-1;
		m_iInvulnerable = 0;
		m_bFinished = false;
		m_bFeignDeath = false;
		m_aiEffectFlags = 22;
		m_bInvisibleFlag = false;
		m_xWalkSet = "def";
		m_xHumpWalkSet = "hump";
		m_axBoni = NUM_BONUS_TYPES;
		m_pxWeaponMgr = new CWeaponMgr(this);
		SetDead(false);
		m_bDoingFinishingMove = false;
		m_bIsGettingFinished = false;
		m_bBLDGResBack = false;
		m_bSHIPResBack = false;
		m_sMyBuildAction = "";
		m_pxTimeOnTick = new CTimerTick();
		m_pxTimeOnTick^.m_xOnTick = ProjectileOn;
		m_pxTimeOffTick = new CTimerTick();
		m_pxTimeOffTick^.m_xOnTick = ProjectileOff;
		m_bIsCheckInUnit = false;
		m_xPrimaryPoison.m_xOnTick = Damage;
		m_xPrimaryPoison.m_xOnDecay = DecayPoison;
		m_bScalpsGiven=false;
		m_pxPatrolInfo=null;
		m_iAttackType=0;
		m_xChangeTargetTime=CGameTime.GetInvalidTime();
		ResetHitDone();
		ms_fDurationFactor=1.0;
		m_fDurationFactor=1.0;
		m_fDefenseFactor=1.0f;
		m_fAttackFactor=1.0f;
	endconstructor;

	///////
	//	dtor
	///////
	destructor()
		m_axDmgTimer = 0;
		delete m_pxWeaponMgr;
		delete m_pxTimeOnTick;
		delete m_pxTimeOffTick;
		//delete m_pxTaskMgr;
		delete m_pxPatrolInfo;
		if(HasTimer(TIMER_FINISHINGMOVE))then
			DeleteTimer(TIMER_FINISHINGMOVE);
		endif;
		/*
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if (pxLevel!=null) then
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
			if (pxPlayer!=null) then
				pxPlayer^.SendPlayerLostUnitEvent(GetType(),GetClassName());
			endif;
		endif;
		*/
	enddestructor;

	export proc ^CWeaponMgr GetWeaponMgr()
		return m_pxWeaponMgr;
	endproc;

	///////
	//	HandleHealing()
	///////
	export proc void HandleHealing()
	endproc;

	export proc void SetGroup(CObjHndl p_xGroup)
		m_xGroup=p_xGroup;
	endproc;

	export proc CObjHndl GetGroup()
		return m_xGroup;
	endproc;

	//transportclass:
	//0 - 1 rider only
	//1 - 1 rider and infantry
	//2 - 1 rider and any unit except sizeclass 2
	export proc void SetTransportClass(int p_iSize)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null && pxAttr^.GetValueInt("transportclass")!=p_iSize)then
			pxAttr^.SetValue("transportclass",p_iSize);
		endif;
	endproc;

	export proc real GetLongRangeFireDelay()
		return 1.0f;
	endproc;

	export proc real GetLongRangeFireSpeed()
		return 30.0f;
	endproc;

	export proc real GetLongRangeFireFalloff()
		return -10.0f;
	endproc;


	export proc bool IsFeignDeath()
		return m_bFeignDeath;
	endproc;

	export proc void SetFeignDeath(bool p_bDeath)
		m_bFeignDeath = p_bDeath;
	endproc;


	export proc ref int GetInvulnerable()
		return m_iInvulnerable;
	endproc;

	export proc void SetInvulnerable(int p_iInvulnerable)
		m_iInvulnerable = p_iInvulnerable;
	endproc;

	export proc void SetLDInvulnerable(bool p_bValue)
		m_bLDInvulnerable=p_bValue;
	endproc;

	export proc bool GetLDInvulnerable()
		return m_bLDInvulnerable;
	endproc;

	export proc void StartANMLImmunityTimer()
		//Badgun Tuning: Warden Special Move
		var real fTime = 7.0;
		DeleteTimer(TIMER_ANML_IMMUNITY);
		CreateTimer(TIMER_ANML_IMMUNITY,CGameTimeSpan.OneSecond()*fTime,false);
	endproc;

	export proc ref bool GetFinished()
		return m_bFinished;
	endproc;

	export proc void SetFinished(bool p_bFinished)
		m_bFinished = p_bFinished;
	endproc;

	export proc bool DoesAreaDamage()
		var real fHitrange = m_xTechTree.GetValueR(GetCurrentWeapon()+"/hitrange", 0.0f);
		return fHitrange > 0.0f;
	endproc;

	export proc void SetGettingFinished(bool p_bValue)
		m_bIsGettingFinished=p_bValue;
		if(p_bValue && !HasTimer(TIMER_FINISHINGMOVE))then
			CreateTimer(TIMER_FINISHINGMOVE,CGameTimeSpan.OneSecond() * 0.5, false);
		endif;
	endproc;

	export proc void SetTrappedGfx(string p_sClass, real p_fDuration)
		var ^CLifeTimeObj pxObj=cast<CLifeTimeObj>(CSrvWrap.GetObjMgr()^.CreateObj("trapped_effect",GetOwner(),GetPos()));
		if(pxObj!=null)then
			pxObj^.SetGFX(p_sClass);
			if(pxObj^.HasAnim("grow"))then
				pxObj^.SetAnim("grow",0);
			endif;
			if(pxObj^.HasAnim("grow"))then
				pxObj^.InvokeGenericSCEvent(11,1.0f);
			endif;
			pxObj^.SetKillTimer(p_fDuration, GetHandle());
		endif;
	endproc;

	///////
	//	SetTrapped()
	///////
	export proc void SetTrapped(CObjHndl p_xTrapHndl)
		m_xTrap = p_xTrapHndl;
		m_bIsTrapped = p_xTrapHndl.IsValid();
		if(m_bIsTrapped)then
			TerminateAction();
	   		var ^CTrapped pxTask= cast<CTrapped>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Trapped"));
	   		pxTask^.Init(GetHandle(), p_xTrapHndl);
	   		pxTask^.SetUserCommand(false);
			var ^CFinishingMove pxMove=cast<CFinishingMove>(GetCurTask());
			if(pxMove!=null)then
				pxMove^.EndTask();
			endif;
			SetTaskImmediate(pxTask);
		endif;

	endproc;

	export proc void SetTrapped(bool p_bTrapped)
		if(p_bTrapped)then
			SetTrapped(GetHandle());
		else
			SetTrapped(CObjHndl.Invalid());
		endif;
	endproc;

	export proc void SetTrapped(real p_fDuration)
		m_xTrap = GetHandle();
		m_bIsTrapped = true;
		var ^CTrapped pxTask=cast<CTrapped>(GetCurTask());
		if(pxTask!=null)then
			pxTask^.SetDuration(p_fDuration);
			return;
		endif;
		if(m_bIsTrapped)then
			TerminateAction();
	   		var ^CTrapped pxTask= cast<CTrapped>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Trapped"));
	   		pxTask^.Init(GetHandle(), p_fDuration);
	   		pxTask^.SetUserCommand(false);
			var ^CFinishingMove pxMove=cast<CFinishingMove>(GetCurTask());
			if(pxMove!=null)then
				pxMove^.EndTask();
			endif;
			SetTaskImmediate(pxTask);
		endif;

	endproc;

	export proc void SetDundeed(real p_fDuration)
		DeleteTimer(TIMER_DUNDEED);
		if(p_fDuration>0.0)then
			m_bIsTrapped = true;
			CreateTimer(TIMER_DUNDEED,CGameTimeSpan.OneSecond() * p_fDuration, false);
		else
			m_bIsTrapped = false;
		endif;
	endproc;

	export proc void StartPatrol(ref array vec3 p_ravWaypoints,int p_iPatrolMode, int p_iSpeed)
		StartPatrol(p_ravWaypoints, p_iPatrolMode, p_iSpeed, false);
	endproc;

	export proc void StartPatrol(ref array vec3 p_ravWaypoints,int p_iPatrolMode, int p_iSpeed, bool p_bStraightWalk)
		m_bStoppingPatrol = false;
		m_bStraightWalkPatrol = p_bStraightWalk;
		var int iLastIdx,iCurIdx;
		if(m_pxPatrolInfo!=null)then
			iLastIdx=m_pxPatrolInfo^.m_iLastIdx;
			iCurIdx=m_pxPatrolInfo^.m_iCurIdx;
		endif;
   		delete m_pxPatrolInfo;
   		m_pxPatrolInfo=new CPatrolInfo(p_ravWaypoints,p_iPatrolMode,p_iSpeed);
   		m_pxPatrolInfo^.m_iLastIdx=iLastIdx;
   		m_pxPatrolInfo^.m_iCurIdx=iCurIdx;
   	endproc;

	export proc void AddPatrolPoint(vec3 p_vPos, int p_iSpeed)
		var array vec3 avPos;
		if(m_pxPatrolInfo!=null)then
			avPos=m_pxPatrolInfo^.m_avWaypoints;
		endif;
   		var int iMode=2;
   		var int iNum=avPos.NumEntries();
   		if(iNum>0)then
   			if((avPos[iNum-1]-p_vPos).AbsSquare()<25.0)then
   				avPos[iNum-1]=p_vPos;
   			elseif((avPos[0]-p_vPos).AbsSquare()<36.0)then
   				iMode=1;
   				avPos[0]=p_vPos;
   			else
		   		avPos.AddEntry(p_vPos);
   			endif;
   		else
   			var vec3 vCurPos=GetCurWalkTarget();
   			if(vCurPos=={0.0,0.0,0.0})then
   				vCurPos=GetPos();
   			endif;
	   		avPos.AddEntry(vCurPos);
	   		avPos.AddEntry(p_vPos);
   		endif;
   		StartPatrol(avPos,iMode,p_iSpeed);
	endproc;

	export proc void StopPatrol()
		if(m_bStoppingPatrol == true)then return; endif; //prevent endless recursion
		m_bStoppingPatrol = true;
		Notify("Notify=LastWaypoint");
		delete m_pxPatrolInfo;
		m_pxPatrolInfo=null;
		UpdatePatrolTargetAttribs();
	endproc;

	export proc void Dump(string p_sString)
		if(GetClassName()=="aje_ankylosaurus")then
			//KLog.LogSpam("JaNe",GetName()+" "+p_sString);
		endif;
	endproc;

	export proc void CheckPatrol()
		if(!CanWalk() && !CanSwim() && !CanFly())then return; endif;
		if(m_pxPatrolInfo==null)then
			if(m_vAggressionPos.AbsSquare()<1.0 || GetOnWall())then
				return;
			endif;
			var real fSqDist=(GetPos()-m_vAggressionPos).AbsSquare();
			var real fSqRadius=GetCollisionRadius();
			fSqRadius*=fSqRadius;
			if(fSqDist>=(fSqRadius*1.5))then
				var array vec3 avPos; avPos.AddEntry(m_vAggressionPos);
				StartPatrol(avPos,0,GetDefaultSpeed());
			endif;
		endif;
		if(m_pxPatrolInfo!=null)then
			var ^vec3 pvNextPoint=m_pxPatrolInfo^.GetNextWaypoint(GetPos());
			if(pvNextPoint==null)then
				if(m_pxPatrolInfo^.m_iMode==0)then
					StopPatrol();
				else
					//endless patrol mode
					return;
				endif;
			else
				m_bAggressionWalk = (m_bStraightWalkPatrol == false);
				UpdateAggressionPos(pvNextPoint^);
				m_bPatrolWalk = true;
				GoTo(pvNextPoint^, false, m_pxPatrolInfo^.GetSpeed(), true, true);
				return;
			endif;
		endif;
		if(m_bMovableInFight&&Random.GetInt()%50==13&&!HasWalkAction()) then
			var bool bUnitCollision=CheckUnitCollision();
			//KLog.LogWarn("CHP","CP:"+GetName()+" "+bUnitCollision.ToString());
			if(bUnitCollision) then
				var real fD=Random.MTRandF(Math.Pi()*2.0f);
				var vec3 vO;vO.SetXYZ(Math.Sin(fD),Math.Cos(fD),0.0f);
				GoTo(GetPos()+vO,false,GetDefaultSpeed(),true,false);
			endif;
		endif;
	endproc;

	///////
	//	IsTrapped()
	///////
	export proc bool IsTrapped()
		return m_xTrap.IsValid() && m_bIsTrapped;
	endproc;

	export proc void SetTaskImmediate(^CTask p_pxTask)
//		var ^CFinishingMove pxTask = cast<CFinishingMove>(m_pxTaskMgr^.GetCurTask());
//		if(pxTask==null)then
   			m_pxTaskMgr^.SetTaskImmediate(p_pxTask);
//		else
//			m_pxTaskMgr^.SetTask(p_pxTask);
//		endif;
	endproc;

	export proc void AddTask(^CTask p_pxTask,bool p_bQueue)
		if(p_pxTask^.IsUserCommand())then
			AnnounceState(p_pxTask^.GetName());
			var ^CFight pxFight = cast<CFight>(p_pxTask);
			if(pxFight==null || !pxFight^.GetNoUserBerserkerMode())then
				StopPatrol();
			endif;
		endif;
    	if(p_bQueue)then
    		m_pxTaskMgr^.AddTask(p_pxTask);
    	else
    		m_pxTaskMgr^.SetTask(p_pxTask);
    	endif;
	endproc;

	export proc void BreakCurTask()
		AnnounceState("");
		if (m_pxTaskMgr!=null) then
			m_pxTaskMgr^.Break();
		endif;
	endproc;

	///////
	//	HandleEvent()
	///////
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if (UpdateSpecialActions(iTimerID)) then
				ReWriteActionAttribs();
			elseif (iTimerID == TIMER_MAMMOTH_TRUMPET ) then
				DeleteTimer(TIMER_MAMMOTH_TRUMPET);
				SetEffectFlag(EFFECT_MAMMOTH_TRUMPET, false);
				ForceBoniUpdate();
			elseif (iTimerID == TIMER_TRICERATOPS_PAW ) then
				DeleteTimer(TIMER_TRICERATOPS_PAW);
				SetEffectFlag(EFFECT_TRICERATOPS_PAW, false);
			elseif (iTimerID == TIMER_PREAGGRO ) then
				PreCheckForEnemies();
			elseif (iTimerID == TIMER_AGGRO ) then
				ExamineEnemies(false, GetAggressionState()!=1 && GetAggressionState()!=-1 && GetAggressionState()!=3);
			elseif (iTimerID == TIMER_FLAGS ) then
				HandleHealing();
//				ExamineFlags();
			elseif (iTimerID == TIMER_FLAGS2 ) then
//				HandleHealing();
				ExamineFlags();
			elseif (iTimerID == TIMER_GETHITREACTION ) then
				DeleteTimer(TIMER_GETHITREACTION);
				DoGetHitReaction();
			elseif (iTimerID == TIMER_ALARM ) then
				if(m_pxTaskMgr^.GetCurTaskName()!="Fight")then
					ExamineEnemies(true, GetAggressionState()!=1 && GetAggressionState()!=-1 && GetAggressionState()!=3);
				endif;
			elseif (iTimerID == TIMER_INVUL ) then
				DeleteTimer(TIMER_INVUL);
				SetLDInvulnerable(false);
			elseif (iTimerID == TIMER_STONED) then
				DeleteTimer(TIMER_STONED);
				SetEffectFlag(EFFECT_ITEM_STONED, false);
			elseif(iTimerID==TIMER_FROST)then
				DeleteTimer(TIMER_FROST);
				SetIcedFlag(false);
				SetEffectFlag(EFFECT_ITEM_STONED,false);
			elseif(iTimerID==TIMER_FROSTIMMUNITY)then
				DeleteTimer(TIMER_FROSTIMMUNITY);
			elseif(iTimerID==TIMER_EXPLOSION)then
				DeleteTimer(TIMER_EXPLOSION);
				Delete();
			elseif(iTimerID==TIMER_DUNDEED)then
				DeleteTimer(TIMER_DUNDEED);
				SetDundeed(-1.0);
			elseif(iTimerID==TIMER_FINISHINGMOVE)then
				DeleteTimer(TIMER_FINISHINGMOVE);
				SetDead(false);
				Die();
			elseif(iTimerID==TIMER_ANML_IMMUNITY)then
				DeleteTimer(TIMER_ANML_IMMUNITY);
			elseif(iTimerID==TIMER_HELPSHOUT)then
				DeleteTimer(TIMER_HELPSHOUT);
				if(GetHealingRadius()>0.0)then
					var ^CCharacter pxChar=cast<CCharacter>(this);
					if(pxChar!=null)then
						if(pxChar^.SomeoneToHeal(false))then
							TerminateAction();
							pxChar^.HealUnits(false);
						endif;
					endif;
				else
					AddEnemy(m_xHelpShoutEnemy, m_bHelpShoutDefend);
				endif;
				m_bHelpShoutDefend=false;
				m_xHelpShoutEnemy=CObjHndl.Invalid();
			elseif(iTimerID==CAMO_TIMER)then
				DeleteTimer(CAMO_TIMER);
				if(m_bIntendedCamouflage)then
					m_bIntendedCamouflage = false;
					AddCamouflageEffect("disg");
					UpdateCamouflageLayers();
				endif;
			elseif(iTimerID==TIMER_LEVELUP_INV)then
				DeleteTimer(TIMER_LEVELUP_INV);
				m_bLevelUpInvulnerable=false;
			elseif(iTimerID==TIMER_ISGETTINGHEALED)then
				DeleteTimer(TIMER_ISGETTINGHEALED);
				RemoveRangedBuff("is_getting_healed");
			elseif(iTimerID==TIMER_ISGETTINGHEALED_FX)then
				DeleteTimer(TIMER_ISGETTINGHEALED_FX);
				RemoveFX("fx_heal_passive");
			elseif(iTimerID==TIMER_SELFHEAL)then
				HealMe(m_fSelfHealAmount);
			else

				super.HandleEvent(p_rxEvtPtr);
			endif;
		elseif(p_rxEvtPtr.GetClass()=="Fight")then
			m_bIsHelpShout=true;
			if(!HasTimer(TIMER_HELPSHOUT))then
				var CObjHndl xEnemy=p_rxEvtPtr.GetObjHandle(0);
				if(GetAggressionState()!=-1 && GetAggressionState()!=3 && xEnemy.IsValid() && xEnemy.GetObj()^.GetOwner()!=GetOwner() && !GetCamouflage() && GetClassName().Find("_worker")==-1)then
					CreateTimer(TIMER_HELPSHOUT, CGameTimeSpan.OneSecond()*0.1, false);
					m_bHelpShoutDefend=p_rxEvtPtr.GetBool(1);
					m_xHelpShoutEnemy=xEnemy;
				endif;
			endif;
		elseif(p_rxEvtPtr.GetClass()=="CTheLite")then
			var ^CTheLite pxTask = cast<CTheLite>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CTheLite"));
			pxTask^.Init(GetHandle(), p_rxEvtPtr.GetObjHandle(0));
			pxTask^.SetUserCommand(true);
			AddTask(pxTask,true);
		elseif(p_rxEvtPtr.GetClass()=="FrstStrk")then
			OnDoFirstStrike(p_rxEvtPtr.GetFloat(0));
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	export proc void OnDoFirstStrike(real p_fTimeToHit)
		//Warning! this Event is send synchronously, from inside the AdvanceAction
		//so don't break it

		//var CGameTime xHitTime=CTimeMgr.Get().GetTime()+CGameTimeSpan.OneSecond()*(p_fTimeToHit);
		//damage must be invoked at xHitTime

		//KLog.LogWarn("CHP","OnDoFirstStrike "+p_fTimeToHit.ToString());

		var ^CFight pxFightTask=cast<CFight>(m_pxTaskMgr^.GetCurTask());
		if(pxFightTask!=null) then
			var ^CFightingObj pxEnemy=cast<CFightingObj>(pxFightTask^.GetEnemy().GetObj());
			if(pxEnemy!=null) then
				pxEnemy^.TakeDmg(this,1.0,p_fTimeToHit);
				//KLog.LogWarn("CHP","OnDoFirstStrike --> Hit!!!!!!!!!!!!");
			endif;
			pxFightTask^.ResetFollowTimer();
		endif;

	endproc;

	export proc void UpdateDeliveries()
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		var array string asRes;
		asRes.AddEntry("food");
		asRes.AddEntry("wood");
		asRes.AddEntry("stone");
		asRes.AddEntry("iron");
		asRes.AddEntry("resin");
		asRes.AddEntry("hide");
		asRes.AddEntry("bone");
		m_bIsCheckInUnit = false;
		var ^CTechTree.CNode pxObjNode = m_xTechTree.FindNode(GetObjPath()+"/delivery");
		var bool bValid = pxObjNode!=null;
		var int i, iC = asRes.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(bValid)then
				var ^CTechTree.CNode pxNode = pxObjNode^.GetSub(asRes[i]);
				if(pxNode!=null && pxObjNode^.GetSubValueB(asRes[i]))then
					pxAttr^.SetValue(asRes[i]+"Delivery",true);
					m_bIsCheckInUnit = true;
				else
					pxAttr^.SetValue(asRes[i]+"Delivery",false);
				endif;
			else
				pxAttr^.SetValue(asRes[i]+"Delivery",false);
			endif;
		endfor;
	endproc;

	//mainly for CBuilding but maybe for Aje_Resource_Collector etc. too
	export proc void AcceptDeliveries()
		if(!m_bIsCheckInUnit)then return; endif;
		if(!HasAnim("deliver"))then return; endif;

		var ^CTask pxTask = m_pxTaskMgr^.GetCurTask();
		var ^CAcceptDeliveries pxAccept;
		if(pxTask!=null)then
			pxAccept = cast<CAcceptDeliveries>(pxTask);
			if(pxAccept==null)then return; endif;
		endif;

		if(pxAccept==null)then
			pxAccept = cast<CAcceptDeliveries>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"AcceptDe"));
			pxAccept^.Init(GetHandle());
			AddTask(pxAccept,false);
		else
			pxAccept^.AddAnimLoop();
		endif;

	endproc;

	///////
	//	OnGetFormationInfoAttackRange()
	///////
	export proc real OnGetFormationInfoAttackRange()
		return GetAttackRange();
	endproc;

	///////
	//	OnGetFormationInfoHitpoints()
	///////
	export proc real OnGetFormationInfoHitpoints()
		return m_fHitpoints;
	endproc;

	///////
	//	OnGetFormationInfoSpeed()
	///////
	export proc real OnGetFormationInfoSpeed()
		return GetMaxSpeed().ToReal();
	endproc;

	///////
	//	GetCurEnemy()
	///////
	export proc CObjHndl GetCurEnemy()
		return m_xCurEnemy;
	endproc;

	///////
	//	SetCurEnemy()
	///////
	export proc void SetCurEnemy(CObjHndl p_xHndl)
		m_xCurEnemy = p_xHndl;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			if(p_xHndl.IsValid())then
				pxAttr^.SetValue("CurEnemy",p_xHndl.AsInt());
			else
				pxAttr^.SetValue("CurEnemy",-1);
			endif;
		endif;
		m_xHelpDefendEnemies.Clear();
		m_xHelpAttackEnemies.Clear();
	endproc;

	export proc void ReturnToFight()
		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		if(pxTask!=null)then
			pxTask^.EndTask();
		endif;
		InvokeFightTask(CObjHndl.Invalid(), m_vAggressionPos, m_bReturnUserCommand, false, m_bReturnNoUserBerserkerMode);
	endproc;

	export proc void MemorizeCurrentFightState(CObjHndl p_xCurEnemy, bool p_bUserCommand, bool p_bNoUserBerserkerMode)
		if(IsInFight())then
			var ^CFight pxTask = cast<CFight>(m_pxTaskMgr^.GetCurTask());
			if(pxTask!=null)then
				m_bReturnUserCommand = pxTask^.IsUserCommand();
				m_bReturnNoUserBerserkerMode = pxTask^.GetNoUserBerserkerMode();
				m_xReturnEnemy = m_xCurEnemy;
			endif;
		elseif(p_xCurEnemy.IsValid())then
			m_bReturnUserCommand=p_bUserCommand;
			m_bReturnNoUserBerserkerMode=p_bNoUserBerserkerMode;
			m_xReturnEnemy=p_xCurEnemy;
		else
			m_bReturnUserCommand = true;
			m_bReturnNoUserBerserkerMode = false;
			m_xReturnEnemy.FromInt(-1);
		endif;
	endproc;

	export proc void SetFollowFailed(bool p_bFailed)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("FollowFailed",p_bFailed);
		endif;
	endproc;

	export proc bool InvalidateTechTree()
		if(m_xProduceUnit.IsValid()) then
			var ^CGameObj pxGameObj = m_xProduceUnit.GetObj();
			if(pxGameObj != null) then
				pxGameObj^.InvalidateTechTreeCache();
			endif;
		endif;
		InvalidateTechTreeCache();
		m_xTechTree=GetTechTree();
		return true;
	endproc;


	///////
	//	OnInit()
	///////
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		InitEvents();

		var ^CFSM pxFSM=GetFSM();
		if(pxFSM==null) then
			pxFSM=InitFSM();
        	m_pxTaskMgr=cast<CTaskMgr>(CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,"TaskMgr"));
        	m_pxTaskMgr^.SetOwner(GetHandle());
        else
        	m_pxTaskMgr=cast<CTaskMgr>(pxFSM^.FindSubStateRecursive("TaskMgr"));
        	m_pxTaskMgr^.SetOwner(GetHandle());
        endif;

		SetDmg(0.0);
		SetMinDmg(0.0);
		SetEndDmg(0.0f);
		SetHitRange(0.0f);
		SetMovableInFight(true);
		SetCanWalk(true);
		DeleteTimer(TIMER_PREAGGRO);
		UpdateAggressive();

		UpdateFOW();

		if(!p_bLoad)then
			CreateTimer(TIMER_FLAGS, CGameTimeSpan.OneSecond() * 1.0, true);
			CreateTimer(TIMER_FLAGS2, CGameTimeSpan.OneSecond() * 20.0, true);
			if(GetClassName()=="aje_poisoner")then
				SetAggressionState(3);
			else
				SetAggressionState(2);
			endif;

			UpdateCamouflageLayers();

			begin RallyPoint;
				var CFourCC xLink = "Ex_1";
				var vec3 vPos=GetPos();
				GetLinkPosWorld(xLink,vPos);
				var CObjHndl xInvalid;
				SetRallyPoint(vPos,xInvalid);
			end RallyPoint;

			m_vAggressionPos = GetPos();

		else
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null)then
				m_vRallyPos.FromString(pxAttribs^.GetValue("RallyPoint"));
			endif;
        endif;

		m_vFormationPriority = {0.0,0.0};
        InitTechTreeDef();
		m_pxWeaponMgr^.UpdateAll();
		UpdateEquipment();

		GetBestWeapon(null, true);
		UpdateWeaponBoni();
		UpdateRangeNDamageInformation();
		AddTemporaryAttackBoni(GetDmg());
		AddTemporaryDefenseBoni(GetProtection());
		AddTemporaryRangedDefenseBoni(GetRangedProtection());
		m_bIsHelpShout = false;

		m_bIsBerserker = false;
		if(GetClassName()=="hu_berserker")then
			m_bIsBerserker = true;
		endif;

		if(m_vAggressionPos=={0.0,0.0,0.0} || !CSrvWrap.GetCurLevel()^.GetLevelInfo().IsSaveGame())then
			UpdateAggressionPos(GetPos());
		endif;

		var string sObjPath = GetObjPath();
		var CTechTree xTT = GetTechTree();
		var ^CTechTree.CNode pxNode = xTT.FindNode(sObjPath+"/special_abilities");
		m_xAbilities.AddAbilities(pxNode, true);

		m_iFinishingMoveIdx=CFinishingMoveMgr.Get().FindFighter(GetClassName());

		if(p_bLoad) then
			m_pxIdleState=pxFSM^.FindSubStateRecursive("idle");
		endif;
		if(m_pxIdleState==null) then
	    	m_pxIdleState=CSrvWrap.GetUSLFactoryMgr().CreateState(pxFSM,"idle");
	    endif;
        m_pxIdleState^.m_xOnEnter=OnIdleEnter;
        m_pxIdleState^.m_xOnTick=OnIdleTick;
        m_pxIdleState^.m_xOnLeave=OnIdleLeave;
        m_pxTaskMgr^.m_xOnChangeToIdleState = OnChangeToIdleState;
        m_pxTaskMgr^.SetReturnState(m_pxIdleState);

		if(pxFSM^.GetCurState()==null) then
			pxFSM^.ChangeState(m_pxIdleState);
		endif;

		// fix for unsaved CFX objects (start)
		if(p_bLoad)then
			var int i,iC=m_xFXObjects.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFX pxCFX = cast<CFX>(m_xFXObjects[i].GetObj());
				if(pxCFX!=null)then
					pxCFX^.SetParent(GetHandle());
				endif;
			endfor;
		endif;
		// fix for unsaved CFX objects (end)

		// fix for unsaved CVirtualProduceUnits objects (start)
		if(p_bLoad)then
			if(m_xProduceUnit.IsValid())then
				var ^CVirtualProduceUnit pxUnit = cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
				if(pxUnit!=null)then
					pxUnit^.Init(GetHandle());
				endif;
			endif;
		endif;

		m_xWalkSet="defn";
		if(!HasWalkSet(m_xWalkSet)) then m_xWalkSet="def"; endif;
		SetDefaultWalkSet(GetWalkSet());

		// fix for unsaved CVirtualProduceUnits objects (end)
	endproc;

    export proc void OnChangeToIdleState(string p_sTaskName)
	endproc;

	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
	endproc;

	export proc void OnIdleTick(int p_iTime)
		CheckPatrol();
	endproc;

	export proc void OnIdleLeave(^CState p_pxFrom, ^CState p_pxTo)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr != null && pxAttr^.GetValue("CurTask")=="Idle")then
			pxAttr^.SetValue("CurTask","");
		endif;
		SetTaskDescription("");
	endproc;

	export proc int AddAutoSpecialMove(string p_sTTPath)
		var CFightingObj.CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);
		return m_axAutoSpecialMoves.AddEntry(xActionObj);
	endproc;

	export proc bool CheckSpecialMoves(^CFightingObj p_pxEnemy)

		if(p_pxEnemy!=null)then
			m_xCurEnemy = p_pxEnemy^.GetHandle();
		endif;

		var int i, iC = m_axAutoSpecialMoves.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axAutoSpecialMoves[i].CheckConditions() && CheckSpecialActionTimer(m_axAutoSpecialMoves[i].GetTTPath()))then
				m_axAutoSpecialMoves[i].StartAction();
				return true;
			endif;
		endfor;
		return false;
	endproc;

	export proc void UpdateAttribs(bool p_bLoad)

		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then return; endif;
		if(!p_bLoad)then
			pxAttribs^.SetValue("hitpoints",m_fHitpoints);
			pxAttribs^.SetValue("maxhitpoints",m_fMaxHitpoints);
			pxAttribs^.SetValue("tribe",m_sTribe);
			pxAttribs^.SetValue("RallyPoint", m_vRallyPos.ToString());
			pxAttribs^.SetValue("level",m_iLevel);
		else
			m_fHitpoints=pxAttribs^.GetValueFloat("hitpoints");
	   		m_fMaxHitpoints=pxAttribs^.GetValueFloat("maxhitpoints");
	   		m_sTribe=pxAttribs^.GetValue("tribe");
	   		m_vRallyPos.FromString(pxAttribs^.GetValue("RallyPoint"));
			m_iLevel = pxAttribs^.GetValueInt("level");
			SetLevelFilter(false);
			SetLevelFilter(true);
		endif;
		UpdateDestructionFlags();
	endproc;


	export proc CObjHndl GetProduceUnit()
		return m_xProduceUnit;
	endproc;


	export proc void CreatePersonalProduceUnit()
		CreatePersonalProduceUnit(true);
	endproc;


	export proc void CreatePersonalProduceUnit(bool p_bSetReady)
		var ^CVirtualProduceUnit pxUnit = cast<CVirtualProduceUnit>(CSrvWrap.GetObjMgr()^.CreateObj("Virtual_Produce_Unit",GetOwner(),GetPos()));
		if(pxUnit!=null)then
			pxUnit^.Init(GetHandle());
			m_xProduceUnit = pxUnit^.GetHandle();
			if(p_bSetReady)then
				pxUnit^.SetReady();
			endif;
		endif;
	endproc;




	proc void CreatePersonalRegion(string p_sRegionClass, vec3 p_vDimension, bitset p_dwType)
		var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
		if (pxRM!=null) then
			var int iIdx = pxRM^.CreateRegion(p_sRegionClass, p_dwType, GetPos(), p_vDimension);
			if(iIdx >= 0)then
				var ^CRegion pxRegion = pxRM^.GetRegion(iIdx);
				m_xRegionGuid = pxRegion^.GetGUID();
				m_xSink.SetRegion(pxRegion);
				pxRegion^.BindToObj(GetHandle());
				m_xSink.Subscribe();
			endif;
		endif;
	endproc;


	proc void DeletePersonalRegion()
		if(!m_xRegionGuid.IsNull())then
			var ^CRegionMgr pxRM = ^(CSrvWrap.GetRegionMgr());
			if (pxRM!=null) then
				var int iIdx = CSrvWrap.GetRegionMgr().FindRegion(m_xRegionGuid);
				if(iIdx >= 0)then
					var ^CRegion pxRegion = pxRM^.GetRegion(iIdx);
					m_xSink.Unsubscribe();
					if(pxRegion!=null)then
						pxRegion^.Unbind();
					endif;
					m_xSink.DeleteRegion();
					var CGuid xNew;
					m_xRegionGuid = xNew;
				endif;
			endif;
		endif;
	endproc;


	proc bool HasPersonalRegion()
		return !m_xRegionGuid.IsNull();
	endproc;


	export proc bool DoesCountInUnitLimit()
		return true;
	endproc;


	proc void AddUnit()
		if(GetOwner()<0)then return; endif;
		if(!DoesCountInUnitLimit())then return; endif;
				
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		
		if(pxPlayer==null)then return; endif;
				
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;			
		var int iUnits=pxPlAttr^.GetValueInt("units");
		iUnits++;
		
		pxPlAttr^.SetValue("units",iUnits);			
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then			
			pxAttr^.SetValue("unit_count",true);
		endif;
	endproc;

	proc void RemoveUnit()
		if(GetOwner()<0)then return; endif;
		if(!DoesCountInUnitLimit())then return; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return; endif;
		var ^CAttribs pxPlAttr=pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		var int iUnits=pxPlAttr^.GetValueInt("units");
		iUnits--;
		pxPlAttr^.SetValue("units",iUnits);
		var ^CAttribs pxAttr = GetAttribs();
	endproc;

	proc bool UpdateDestructionFlags()
		if(GetConstructLevel()<4) then return false; endif;
		if((GetHitpoints()!=GetMaxHitpoints())&&((GetHitpoints()!=0.0f)&&(GetMaxHitpoints()!=0.0f)))then
			var real fPercentage=GetHitpoints()/(GetMaxHitpoints()/100.0f);
			if(fPercentage<=25.0f)then
				if(GetDestructLevel()!=2)then
					if(GetDestructLevel()<2) then
						InvokeGenericSCEvent(14,4.0f);
					endif;
					SetDestructLevel(2);
				endif;
				return(true);
			elseif(fPercentage<=50.0f)then
				if(GetDestructLevel()!=1)then
					if(GetDestructLevel()<1) then
						InvokeGenericSCEvent(14,4.0f);
					endif;
					SetDestructLevel(1);
				endif;
				return(true);
			else
				SetDestructLevel(0);
				return(true);
			endif;
		endif;
		return(true);
	endproc;

	proc void StartTT()
		SetStartFilter(true);
	endproc;

	proc void SetStartFilter(bool p_bEnable)
		m_xTechTree=GetTechTree();

		// object TT
		var string sStartTT = m_xTechTree.GetValueS(GetObjPath()+"/StartTT","");
		var ^CTechTreeDef pxDef = GetTechTreeDef();
		if( !sStartTT.IsEmpty() && pxDef!=null)then
			if(p_bEnable)then
				pxDef^.EnableFilter(sStartTT);
			else
				pxDef^.DisableFilter(sStartTT);
			endif;
		endif;

		// player TT
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
			if(pxPlayer!=null)then
				sStartTT = m_xTechTree.GetValueS(GetObjPath()+"/GlobalStartTT","");
				if(!sStartTT.IsEmpty())then
					if(p_bEnable)then
						pxPlayer^.GetPlayerTechTreeDef().EnableFilter(sStartTT);
					else
						pxPlayer^.GetPlayerTechTreeDef().DisableFilter(sStartTT);
					endif;
				endif;
			endif;
		endif;
	endproc;

	proc void SetNewStartFilterOwner(int p_iOwner)
		// player TT
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel!=null)then
			var ^CPlayer pxPlayerOld=pxLevel^.GetPlayer(GetOwner());
			var ^CPlayer pxPlayerNew=pxLevel^.GetPlayer(p_iOwner);
			if(pxPlayerOld!=null && pxPlayerNew!=null)then
				var string sStartTT = m_xTechTree.GetValueS(GetObjPath()+"/GlobalStartTT","");
				if(!sStartTT.IsEmpty())then
					pxPlayerNew^.GetPlayerTechTreeDef().EnableFilter(sStartTT);
					pxPlayerOld^.GetPlayerTechTreeDef().DisableFilter(sStartTT);
				endif;
			endif;
		endif;
	endproc;


	///////
	//	UpdateSpecialActions()
	///////
	proc bool UpdateSpecialActions(ref int p_riTimerID)

		if(m_aiActionTimerIDs.NumEntries()==0)then
			return false;
		endif;

		var int iTimer = m_aiActionTimerIDs.FindEntry(p_riTimerID);

		if(iTimer==-1)then
			return false;
		else

			if(m_aiActionTimerIDs.NumEntries()!=m_axActionObj.NumEntries())then

				CSrvWrap.LogWarning("FightingObj","m_aiActionTimerIDs & m_axActionObj have different NumEntries!");

			endif;

			m_aiActionTimerIDs.DeleteEntryUS(iTimer);
			m_axActionObj.DeleteEntryUS(iTimer);

		endif;

		return true;

	endproc;

	///////
	//	AddSpecialActionTimer()
	///////
	export proc bool AddSpecialActionTimer(string p_sTTPath)
		var int iTimerID;

		var CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);

		var int iIndex = m_axActionObj.FindEntry(xActionObj);
		if(iIndex==-1)then

			var real fDuration = m_xTechTree.GetValueR(p_sTTPath+"/duration",5.0);

			xActionObj.SetDuration(fDuration);
			xActionObj.SetStartTime(CTimeMgr.Get().GetTime());

			var bool bFine = false;
			repeat
				iTimerID = (Random.GetInt()%50) + 300;
				bFine = m_aiActionTimerIDs.FindEntry(iTimerID)==-1;
				bFine = bFine && !HasTimer(iTimerID);
			until(bFine)endrepeat;

			CreateTimer(iTimerID, CGameTimeSpan.OneSecond()*fDuration,false);
			m_aiActionTimerIDs.AddEntry(iTimerID);
			m_axActionObj.AddEntry(xActionObj);
			//L CSrvWrap.LogSpam("FightingObj","iTimerID = "+iTimerID.ToString()+" "+p_sTTPath+" ("+m_axActionObj.NumEntries().ToString()+")");
		else
			return false;
		endif;

		ReWriteActionAttribs();

		return true;
	endproc;

	export proc bool CheckSpecialActionTimer(string p_sTTPath)
		var ^CTechTree.CNode pxActNode = m_xTechTree.FindNode(p_sTTPath+"/locations");
		if(pxActNode==null) then return false; endif;
		var bool bFound = false;
		var int i, iC = pxActNode^.NumSubs();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CTechTree.CNode pxSub = pxActNode^.GetSub(i);
			if(pxSub^.GetValue().Find(GetClassName())>=0 || pxSub^.GetValue().Right(4)==GetType().AsString()) then
				bFound = true;
			endif;
		endfor;
		if(!bFound)then return false; endif;
		var CActionObj xActionObj;
		xActionObj.SetTTPath(p_sTTPath);
		return m_axActionObj.FindEntry(xActionObj)==-1;
	endproc;

	///////
	//	ResetSpecialActionTimer()
	///////
	export proc bool ResetSpecialActionTimer(string p_sTTPath)

		var int i,iC = m_axActionObj.NumEntries();

		for(i=0)cond(i<iC)iter(i++)do
			if(m_axActionObj[i].GetTTPath() != p_sTTPath)then continue; endif;
			m_aiActionTimerIDs.DeleteEntry(i);
			m_axActionObj.DeleteEntry(i);
			break;
		endfor;

		ReWriteActionAttribs();

		return true;
	endproc;

	///////
	//	RewriteActionAttribs()
	///////
	proc void ReWriteActionAttribs()

		var string sSend;
		var string sActions;
		//var CPropDB xDB;
		var int i, iC = m_aiActionTimerIDs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			/*var ^CPropDB.CNode pxNode = ^(xDB.GetRoot().AddValue(i.ToString(),""));
			pxNode^.AddValue("TTPath",m_axActionObj[i].GetTTPath());
			pxNode^.AddValue("StartTime", m_axActionObj[i].GetStartTime().ToString());
			pxNode^.AddValue("Duration", m_axActionObj[i].GetDuration());
			*/
			var ^CTechTree.CNode pxTTNode = m_xTechTree.FindNode(m_axActionObj[i].GetTTPath());
			if(pxTTNode!=null) then
				sSend += pxTTNode^.GetHashValue().ToString()+"|"+m_axActionObj[i].GetStartTime().ToString()+"|"+m_axActionObj[i].GetDuration().ToString()+"\n";
				sActions += pxTTNode^.GetName()+"\n";
			endif;

		endfor;

		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr != null)then
			pxAttr^.SetValue("SpecialActionCounters",sSend);
			pxAttr^.SetValue("SpecialActionNames",sActions);
		endif;
	endproc;

	export proc ref CObjHndl AddFX(string p_sFX, real p_fTime)
	
		if(IsMarkedForDelete())then return m_xInvalid; endif;

		var int iIndex;
		var bool bAlreadyExists = false;

		var int i, iC = m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj = cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null && pxObj^.GetFXClass()==p_sFX)then
				bAlreadyExists = true;
				iIndex = i;
				break;
			endif;
		endfor;

		if(!bAlreadyExists)then
			var ^CFX pxFX = cast<CFX>(CSrvWrap.GetObjMgr()^.CreateObj(p_sFX,GetOwner(),GetPos(),GetRotation()));
			if(pxFX!=null)then
				iIndex = m_xFXObjects.Include(pxFX^.GetHandle());
				if(p_fTime>0.0)then
					pxFX^.SetTimer(p_fTime);
				endif;
				pxFX^.SetFXClass(p_sFX);
				pxFX^.SetParent(GetHandle());
			endif;
		endif;
		return m_xFXObjects[iIndex];

	endproc;

	export proc bool RemoveFX(string p_sFX)
		var int i, iC = m_xFXObjects.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFX pxObj = cast<CFX>(m_xFXObjects[i].GetObj());
			if(pxObj!=null && pxObj^.GetFXClass()==p_sFX)then
				m_xFXObjects.DeleteEntry(i);
				pxObj^.Delete();
				return true;
			endif;
		endfor;
		return false;
	endproc;

	export proc void ClearFX()
		var int i;
		for(i=0)cond(i<m_xFXObjects.NumEntries())iter(i++)do
			var ^CFX pxObj = cast<CFX>(m_xFXObjects[i].GetObj());
			m_xFXObjects.DeleteEntry(i);
			if(pxObj!=null)then
				pxObj^.Delete();
			endif;
			i--;
		endfor;
	endproc;


	///////
	//	SetOwner()
	///////
	export proc void SetOwner(int p_iNewOwner)
		RemoveUnit();
		SetNewStartFilterOwner(p_iNewOwner);
		super.SetOwner(p_iNewOwner);
		AddUnit();
		if(m_xProduceUnit.IsValid()) then
			m_xProduceUnit.GetObj()^.SetOwner(p_iNewOwner);
		endif;
		OnTechTreeChange();
	endproc;

	/*?
		?item GetLevel()
		?desc Get level of character
		?return Level of character
	?*/
	export proc int GetLevel()
		return(m_iLevel);
	endproc;


	proc bool CompareTechTreeLevel(int p_iLevel)
		return p_iLevel<=(GetLevel()+1);
	endproc;

	proc void SetLevelFilter(bool p_bEnable)
		var string sSearch="Filters/"+GetTribeName()+"/Upgrades/"+GetClassName()+"/Lvl"+(m_iLevel+1).ToString();
		SetLevelFilter(p_bEnable, sSearch);
	endproc;


	proc void SetLevelFilter(bool p_bEnable, string p_sPath)

		if(m_iLevel>0)then

			var string sSearch = p_sPath;

			var array string asFilters;

			var int i, iC = CTechTreeMgr.Get().NumEntries();
			for(i=0) cond(i<iC) iter(++i)do
				var string sP = CTechTreeMgr.Get().GetFilterPath(i);
				if(sP.Find(sSearch)>=0) then
					asFilters.AddEntry(sP);
				endif;
			endfor;

			var ^CPlayer pxPlayer=CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());

			if(pxPlayer!=null)then
				iC= asFilters.NumEntries();

				for(i=0) cond(i<iC) iter(++i) do

					var ^CTechTreeDef pxTTDef = GetTechTreeDef();
					if(asFilters[i].Find("_Bonus")<0) then
						pxTTDef = ^(pxPlayer^.GetPlayerTechTreeDef());
					endif;

					if(p_bEnable)then
						pxTTDef^.EnableFilter(asFilters[i]);
					else
						pxTTDef^.DisableFilter(asFilters[i]);
					endif;
				endfor;
			endif;

			if(m_iLevel==4)then
				if(pxPlayer!=null)then
					if(p_bEnable)then
						pxPlayer^.GetPlayerTechTreeDef().EnableFilter("Filters/"+GetTribeName()+"/Upgrades/"+GetClassName()+"/Chief_Bonus");
					else
						pxPlayer^.GetPlayerTechTreeDef().DisableFilter("Filters/"+GetTribeName()+"/Upgrades/"+GetClassName()+"/Chief_Bonus");
					endif;
				endif;
			endif;

			if(GetInventory()!=null)then
				GetInventory()^.SetSize(1);
			endif;

		endif;
	endproc;


	/*?
		?item SetLevel(int)
		?desc set level of character, make particle effects
		?param int new level
		?return true if changed
	?*/
	export proc bool SetLevel(int p_iLevel)

		if(m_iLevel==p_iLevel) then return true; endif;
		var int iOldLevel=m_iLevel;

		if((p_iLevel<0)||(p_iLevel>4))then return false; endif;

		begin CheckLevelLimit;
			var array int aiMaxUnits;
			aiMaxUnits.AddEntry(25);
			aiMaxUnits.AddEntry(15);
			aiMaxUnits.AddEntry(8);
			aiMaxUnits.AddEntry(3);
			aiMaxUnits.AddEntry(1);

			var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
			var ^CPropDB pxGenericDB=^(pxLevelInfo^.GetGenericData());
			var ^CPropDB.CNode pxLevelNode = ^((pxGenericDB^)["PlayerSettings/Player_"+GetOwner().ToString()+"/Restrictions/Chars/Level"+(p_iLevel+1).ToString()]);


			var int iVirtualUnits;
			var ^CAttribs pxPlAttr = CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner())^.GetAttribs();
			if(pxPlAttr!=null)then
				iVirtualUnits=pxPlAttr^.GetValueInt("virtual_units_"+p_iLevel.ToString());
			endif;

			var CObjQuery xQuery;
			xQuery.SetOwner(GetOwner());
			xQuery.SetType("CHTR");
			xQuery.SetType("ANML",true);
			xQuery.SetType("VHCL",true);
			xQuery.SetType("SHIP",true);
			xQuery.SetAttribsPos("level",p_iLevel);
			xQuery.SetAttribsPos("unit_count",true);

			if(pxLevelNode!=null)then
				aiMaxUnits[p_iLevel] = pxLevelNode^.GetValueI("Max",aiMaxUnits[p_iLevel]);
			endif;

			var CObjList xList;
			xQuery.Execute(xList);
			var int i,iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
			endfor;

			if((xList.NumEntries()+iVirtualUnits)>=aiMaxUnits[p_iLevel])then
				return false;
			endif;
		end CheckLevelLimit;

		begin CheckLevelResources;
			if(p_iLevel>m_iLevel)then
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				var ^CAttribs pxPlAttr = pxLevel^.GetPlayer(GetOwner())^.GetAttribs();
				var int iValue = pxPlAttr^.GetValueInt("iron");
				var int i, iC = p_iLevel - m_iLevel;
				var int iCosts  = 0;
				for(i=0)cond(i<iC)iter(i++)do
					iCosts += pxPlAttr^.GetValueInt("foodcost_lvl_"+(m_iLevel+i+1).ToString());
				endfor;

				if(iValue>=iCosts)then
					iValue-=iCosts;
					pxPlAttr^.SetValue("iron",iValue);
//L					KLog.LogInfo( "DaHo", "CFightingObj::SetLevel() needs a sample point!" );
				else
					return false;
				endif;
			endif;
		end CheckLevelResources;

		if(!SetLevelClean(p_iLevel))then return false; endif;
		GetBestWeapon(null, true); //update current weapon

		if(iOldLevel<p_iLevel)then
			DoLevelUpAnim();
			FullHeal();
			SetDestructLevel(0); // RT#15411
		endif;

		return true;
	endproc;

	export proc bool SetLevelClean(int p_iLevel)

		if(GetAttribs()^.GetValueBool("unique"))then
			SetFormationPriorityCenter2Side(0.0);
		else
			SetFormationPriorityCenter2Side(1.0 - (p_iLevel.ToReal()/5.0));
		endif;

		if(m_iLevel==p_iLevel)then return false; endif;
		if((p_iLevel<0)||(p_iLevel>4))then return false; endif;

		SetLevelFilter(false);

		if(cast<CHero>(this)==null)then
			SetLevelFilter(false,"Filters/"+GetTribeName()+"/Upgrades/AllNonHeroes/Lvl"+(m_iLevel+1).ToString());
		endif;

		m_iLevel=p_iLevel;

		SetLevelFilter(true);

		if(cast<CHero>(this)==null)then
			SetLevelFilter(true,"Filters/"+GetTribeName()+"/Upgrades/AllNonHeroes/Lvl"+(m_iLevel+1).ToString());
		endif;

		GetAttribs()^.SetValue("level",m_iLevel);

		var ^CInventory pxInventory = GetInventory();
		if(pxInventory!=null)then
			pxInventory^.SetSize(1);
		endif;

		GetWeaponMgr()^.UpdateAll();

		OnTechTreeChange();
		return true;
	endproc;

	export proc void DoLevelUpAnim()
		if (!GetTransportObj().IsValid() && !GetOnWall() && !IsTrapped()) then
			var string sAnim = "level_up";
			if(HasAnim(sAnim))then
				if(HasTimer(TIMER_LEVELUP_INV))then
					DeleteTimer(TIMER_LEVELUP_INV);
				endif;
				AnimAction(sAnim);
				m_bLevelUpInvulnerable=true;
				CreateTimer(CFightingObj.TIMER_LEVELUP_INV, CGameTimeSpan.OneSecond()*1.5, false);
			endif;
			InvokeGenericSCEvent(35,1.0f);
		endif;
	endproc;


	export proc void SetUnique(bool p_bUnique)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			var bool bUnique = pxAttr^.GetValueBool("unique");
			if(bUnique!=p_bUnique)then
				pxAttr^.SetValue("unique",p_bUnique);
			endif;
		endif;
	endproc;


	///////
	//	GetHitpoints()
	///////
	export proc real GetHitpoints()
		return(m_fHitpoints);
	endproc;

	export proc real GetMaxHitpoints()
		return m_fMaxHitpoints;
	endproc;

	proc void SetMaxHitpoints(real p_fMaxHitpoints)
		m_fMaxHitpoints = p_fMaxHitpoints;
		UpdateHitpoints();
	endproc;

	export proc void SetHitpoints(real p_fHitpoints)
		if (m_fHitpoints!=p_fHitpoints) then
			m_fHitpoints = p_fHitpoints;
			UpdateHitpoints();
		endif;
	endproc;

	export proc bool IsSeriouslyInjured()
		return (m_fHitpoints<(m_fMaxHitpoints*0.5f));
	endproc;

	///////
	//	GetPlayerTribeName()
	//	this returns a tribe of the player if one present.
	///////
	export proc string GetPlayerTribeName()
		var ^CBasePlayer pxBasePlayer=CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			return pxBasePlayer^.m_sTribe;
		endif;
		return "";
	endproc

	///////
	//	GetTribeName()
	//	this can vary from players tribe
	///////
	export proc string GetTribeName()
		if(m_sTribe.IsEmpty())then
			m_sTribe=GetPlayerTribeName();
			var ^CAttribs pxAttribs=GetAttribs();
			if(pxAttribs!=null)then
				pxAttribs^.SetValue("tribe",m_sTribe);
			endif;
		endif;
		return m_sTribe;
	endproc

	proc void OnObjClassChange()
		UpdateObjPath();
	endproc;


	///////
	//	GetBestWeapon()
	///////
	export proc void GetBestWeapon()
		GetBestWeapon(null, true);
	endproc;

	export proc void GetBestWeapon(^CFightingObj p_pxEnemy, bool p_bUpdate)
		if (p_bUpdate) then
			m_pxWeaponMgr^.UpdateAll();
		endif;
		UpdateEquipment();
	endproc;

	proc bool CompareCaste(string p_sCastes)
		return true;
	endproc;

	proc bool MustHaveUser()
		return true;
	endproc;

	///////
	//	ExamineFlags()
	///////
	export proc void ExamineFlags()
		if(GetOwner()==-1)then return; endif;
		if(m_xTechTree.GetValueI("/Objects/" + GetPlayerTribeName() + "/InventObjects/BLDG_res_back/invented", 0)!=0)then
			m_bBLDGResBack = true;
		else
			m_bBLDGResBack = false;
		endif;

		if(m_xTechTree.GetValueI("/Objects/" + GetPlayerTribeName() + "/InventObjects/SHIP_res_back/invented", 0)!=0)then
			m_bSHIPResBack = true;
		else
			m_bSHIPResBack = false;
		endif;
	endproc;

	///////
	//	UpdateGfxFlags()
	///////
	export proc void UpdateGfxFlags()
	endproc;

	///////
	//	UpdateFormationAttribs()
	///////
	proc void UpdateFormationAttribs()

		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		if(!CanSwim() && !CanWalk() && !CanFly())then return; endif;

		var real fTTFormPosY=m_xTechTree.GetValueR(GetObjPath()+"/formation_pos",-1.0f);

		var real fDmg		= GetDmg();
		var real fRange		= m_fAttackRange;
		var real fDef		= GetProtection();
		var real fRangedDef	= GetRangedProtection();
		var real fHP		= GetMaxHitpoints();
		var real fY;
		var real fX;

		//get relative hitpoints including defense
		fX = (100.0 * fHP) / ( 100.0 - fDef);
		fX = 1.0 - Math.Min(fX / 3000.0,1.0);

		fY=((fRange+1.0f)/75.0f)-fDmg/10000.0f;
		if(fTTFormPosY>=0.0f) then fY=fTTFormPosY; endif;
		fY=Math.Clamp(fY,0.0f,1.0f);

		//KLog.LogWarn("CHP",GetName()+" X:"+fX.ToString()+" Y:"+fY.ToString()+" Dmg:"+fDmg.ToString());
		if(fX!=pxAttr^.GetValueFloat("formation_x"))then
			pxAttr^.SetValue("formation_x",fX);
		endif;

		if(fY!=pxAttr^.GetValueFloat("formation_y"))then
			pxAttr^.SetValue("formation_y",fY);
		endif;

	endproc;

	///////
	//	UpdateAggressionPos()
	///////
	export proc void UpdateAggressionPos(vec3 p_vPos)
		m_vAggressionPos = p_vPos;
	endproc;

	export proc void SetPos(vec3 p_vPos)
		UpdateAggressionPos(p_vPos);
		super.SetPos(p_vPos);
	endproc;

	///////
	//	GetTechTreeHitpoints()
	///////
	export proc real GetTechTreeHitpoints()
		var string sObjPath = GetObjPath();
		var real fHitpoints = m_xTechTree.GetValueR(sObjPath+"/hitpoints",100.0);
		fHitpoints *= GetTechTreeModifier("Hitpoints",true);
		fHitpoints += GetTechTreeModifier("Hitpoints",false);
		fHitpoints *= GetClassTechTreeModifier("Hitpoints",true);
		fHitpoints += GetClassTechTreeModifier("Hitpoints",false);
		return fHitpoints;
	endproc;

	export proc real GetHealingRadius()
		var ^CFightingObj.CSpecialAbility pxA = m_xAbilities.GetAbility("heal", true);
		var real fValue=-1.0;
		if(pxA!=null) then
			fValue=pxA^.GetValueF("radius");
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(GetType()!="BLDG" && pxAttr!=null)then
			var bool bValue=(fValue>0.0);
			if(pxAttr^.GetValueBool("healer")!=bValue)then
				pxAttr^.SetValue("healer",bValue);
			endif;
		endif;
		return fValue;
	endproc;

	export proc real GetHealingAmount(^CFightingObj p_pxTarget)
		var ^CFightingObj.CSpecialAbility pxA = m_xAbilities.GetAbility("heal", true);
		if(pxA==null) then return -1.0; endif;
		var real fMod = p_pxTarget^.GetMaxHitpoints() * pxA^.GetValueF("mod") * 0.01;
		var real fAmount =  (pxA^.GetValueF("amount") * GetTechTreeModifier("Healing",true)) + GetTechTreeModifier("Healing",false);
		return fAmount+fMod;
	endproc;

	///////
	//	GetTechTreeValueR()
	///////
	export proc real GetTechTreeValueR(string p_sName, real p_fDefValue)
		var string sObjPath = GetObjPath();
		return(m_xTechTree.GetValueR(sObjPath+"/"+p_sName,p_fDefValue));
	endproc;

	export proc int GetTechTreeValueI(string p_sName, int p_iDefValue)
		var string sObjPath = GetObjPath();
		return(m_xTechTree.GetValueI(sObjPath+"/"+p_sName,p_iDefValue));
	endproc;


	export proc real GetSelfTimeFactor()
		var real fFactor = m_xTechTree.GetValueR(GetObjPath()+"/timefactor",2.0);
		if(fFactor<=0.0)then
			fFactor = 2.0;
		endif;
		return fFactor;
	endproc;


	///////
	//	GetTechTreeFlags()
	///////
	export proc void GetTechTreeFlags(ref array string p_rasFlags)
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		p_rasFlags = 0;
		if(pxPlayer!=null)then
			var string sObjPath = GetObjPath();
			var int i;
			for(i=0)cond(i<m_xTechTree.NumSubs(sObjPath+"/flags"))iter(i++)do
				p_rasFlags.AddEntry(m_xTechTree.GetSubAbsPath(sObjPath+"/flags",i));
			endfor;
		else
			CSrvWrap.LogError("FightingObj","GetTechTreeFlags(): Player invalid! Returning no flags!" );
		endif;
	endproc;

	///////
	//	GetTechTreeAggressive()
	///////
	export proc int GetTechTreeAggressiv()
		var string sObjPath = GetObjPath();
		//CSrvWrap.LogError("Aggressiv",sObjPath);
		return(m_xTechTree.GetValueI(sObjPath+"/aggressive",0));
	endproc;

	///////
	//	GetDirection() - returns direction front,back,left,right
	///////
	export proc bitset GetDirection(vec3 p_vDir)
		var real fLength=p_vDir.Abs();
		if(fLength<0.0001) then return DIR_INVALID; endif;
		p_vDir/=fLength;
		var Quat qRot=GetRot();
		qRot.InvertU();
		qRot.VecRotateU(p_vDir);
		var bool bX=Math.Abs(p_vDir.GetX())>Math.Abs(p_vDir.GetY());
		if(bX) then
			if(p_vDir.GetX()>0.0f) then
				return DIR_LEFT;
			else
				return DIR_RIGHT;
			endif;
		else
			if(p_vDir.GetY()>0.0f) then
				return DIR_FRONT;
			else
				return DIR_BACK;
			endif;
		endif;
	endproc;

	///////
	//	GetDirection() - returns direction front,back,left,right,frontleft,frontright,backleft,backright
	///////
	export proc bitset GetDirection8(vec3 p_vDir)
		p_vDir.SetZ(0.0);
		var real fLength=p_vDir.Abs();
		if(fLength<0.0001) then return DIR_INVALID; endif;
		p_vDir/=fLength;

		var Quat qRot=GetRot();
		qRot.InvertU();
		qRot.VecRotateU(p_vDir);

		var real fCP1=0.92387953f; //cos(PI/4-PI/8)
		var real fCP2=0.382683432; //cos(PI/4-PI/8+PI/4)

		var real fX=p_vDir.GetX();
		var real fY=p_vDir.GetY();

		var bool bXN,bYN;
		if(fX<0.0) then bXN=true;fX=-fX; else bXN=false; endif;
		if(fY<0.0) then bYN=true;fY=-fY; else bYN=false; endif;

		var int iQuad;
		if(bXN&&!bYN) then iQuad=0; elseif(!bXN&&!bYN) then iQuad=1; elseif(!bXN&&bYN) then iQuad=2; else iQuad=3; endif;

		var int iXA;
		if(fX>fCP1) then iXA=0; elseif(fX>fCP2) then iXA=1; else iXA=2; endif;

		switch(iQuad)
			case(0) do
				switch(iXA)
					case(0) do return DIR_RIGHT;		endcase;
					case(1) do return DIR_FRONT_RIGHT;	endcase;
					case default do return DIR_FRONT;	endcase;
				endswitch;
			endcase;

			case(1) do
				switch(iXA)
					case(0) do return DIR_LEFT;			endcase;
					case(1) do return DIR_FRONT_LEFT;	endcase;
					case default do return DIR_FRONT;	endcase;
				endswitch;
			endcase;

			case(2) do
				switch(iXA)
					case(0) do return DIR_LEFT;			endcase;
					case(1) do return DIR_BACK_LEFT;	endcase;
					case default do return DIR_BACK;	endcase;
				endswitch;
			endcase;

			case default do
				switch(iXA)
					case(0) do return DIR_RIGHT;		endcase;
					case(1) do return DIR_BACK_RIGHT;	endcase;
					case default do return DIR_BACK;	endcase;
				endswitch;
			endcase;
		endswitch;
	endproc;

	///////
	//	GetTaskMgr()
	///////
	export proc ^CTaskMgr GetTaskMgr()
		return m_pxTaskMgr;
	endproc;

	export proc ^CTask GetCurTask()
		if(m_pxTaskMgr!=null)then
			return m_pxTaskMgr^.GetCurTask();
		endif;
		return null;
	endproc;

	export proc string GetCurTaskName()
		if(m_pxTaskMgr!=null)then
			return m_pxTaskMgr^.GetCurTaskName();
		endif;
		return "";
	endproc;


	///////
	//	DoGetHitReaction()
	///////
	proc void DoGetHitReaction()
		var bitset dwDir=GetDirection(m_vHitReactionDir);
		var string sHitAnim="hit_back";

/*
		if		(dwDir==DIR_FRONT) 	then sHitAnim+="front";
		elseif	(dwDir==DIR_BACK) 	then sHitAnim+="back";
		elseif	(dwDir==DIR_LEFT) 	then sHitAnim+="left";
		elseif	(dwDir==DIR_RIGHT) 	then sHitAnim+="right";
		else
			CSrvWrap.LogError("FightingObj","invalid direction vector: "+m_vHitReactionDir.ToString());
			return;
		endif;
*/		var vec3 vImpulse=m_vHitReactionDir;
		//L CSrvWrap.LogSpam("FightingObj","Hier passiert der Bug: "+vImpulse.ToString()+" "+GetName());

		var string sGetUpAnim = "getting_up";
		if(m_fHitpoints<=0.0f || IsDead()) then
			sGetUpAnim="";
		endif;
		FallActionDest(GetPos()+vImpulse,sHitAnim,sGetUpAnim,0.0);
	endproc;

	///////
	//	SetHitReactionTimer()
	///////
	export proc void SetHitReactionTimer(real p_fSecs,vec3 p_vDir)
		if(HasTimer(TIMER_GETHITREACTION)) then return; endif; //gibt's schon
		CreateTimer(TIMER_GETHITREACTION, CGameTimeSpan.OneSecond()*p_fSecs,false);
		m_vHitReactionDir=p_vDir;
	endproc;


	export proc void OnKill()
		if(m_bScalpsGiven) then return; endif;

		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
		var CGameTime xTime=CTimeMgr.Get().GetTime();

		CSrvWrap.GetGameLogger().Log("UnitLost",GetOwner().ToString(),GetClassName());

		// give skulls		
		var ^CBasePlayer pxEnemyBasePlayer = cast<CBasePlayer>(CSrvWrap.GetCurLevel()^.GetPlayer(m_iLastDamage));
		if(pxEnemyBasePlayer!=null && m_iLastDamage!=GetOwner())then

			var int iScalpValue=GetScalpValue();
			pxEnemyBasePlayer^.AddScalps(iScalpValue);
			m_bScalpsGiven=true;

//			pxStatisticMgr^.AddSample( CStatisticSample.Collected_Skulls.ToInt(), m_iLastDamage, GetScalpValue() );
		endif;

		// store our death in the statistics
		if((GetOwner()==-1)&&(GetType()=="ANML"))then
			pxStatisticMgr^.AddSample( CStatisticSample.KilledAnimals.ToInt(), m_iLastDamage, 1 );
		elseif(GetType()=="BLDG")then
			if( m_iLastDamage != GetOwner() ) then
				pxStatisticMgr^.AddSample( CStatisticSample.RazedBuildings.ToInt(), m_iLastDamage, 1 );
			endif;

			var string sTribe=GetTribeName();
			var string sObjClass=GetClassName();
			var string sCategory="";
			var string sPath="/Actions/"+sTribe+"/Build/BLDG/"+sObjClass+"/locations/0/uiposition/subcat";
			sCategory=GetTechTree().GetValueS(sPath,"default");

			if ( sCategory=="ECON" /* Testen ob das Gebäude ECON ist */ )  then
				pxStatisticMgr^.AddSample( CStatisticSample.EcoBuildings.ToInt(), GetOwner(), -1 );
			endif;

			if ( sCategory=="COMB"/* Testen ob das Gebäude COMB ist */ )  then
				pxStatisticMgr^.AddSample( CStatisticSample.MilBuildings.ToInt(), GetOwner(), -1 );
			endif;

			if ( sCategory=="DEFE" /* Testen ob das Gebäude DEFE ist */ )  then		
				if(GetClassName().Find("palisade")==-1)then		
					pxStatisticMgr^.AddSample( CStatisticSample.DefBuildings.ToInt(), GetOwner(), -1 );
				endif;
			endif;
		else
			if(m_iLastDamage!=GetOwner())then
				pxStatisticMgr^.AddSample( CStatisticSample.KilledEnemies.ToInt(), m_iLastDamage, 1 );
			endif;
			if(DoesCountInUnitLimit())then
				pxStatisticMgr^.AddUnit( GetOwner(), GetClassName(), GetType(), -1 );
			endif;
		endif;
	endproc;

	export proc void Damage(real p_fDamage)
		if(m_bGodMode)then return;endif;
		if(m_bLevelUpInvulnerable)then return; endif;
		m_fHitpoints-= Math.Max(Math.Ceil(p_fDamage*m_fDefenseFactor),1.0);
		m_fHitpoints=Math.Max(m_fHitpoints,0.0);
//L		KLog.LogInfo( "DaHo", "HitPoints = " + m_fHitpoints.ToString() );
		if(m_fHitpoints<=0.0f && !IsDead())then
			OnKill();
		endif;
		UpdateHitpoints();
	endproc;

	///////
	//	TakeDmg()
	///////
	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return TakeDmg(p_pxEnemy, 1.0);
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy,real p_fFactor)
		if(p_pxEnemy!=null)then
			return TakeDmg(p_pxEnemy, p_fFactor, p_pxEnemy^.GetHitDelay());
		endif;
		return TakeDmg(p_pxEnemy, p_fFactor, 0.7);
	endproc;

	export proc void ClearDamageCache()
		m_xDmgCache.m_pxLastEnemy = null;
		m_xDmgCache.m_fDamage = 0.0;
		m_bWeaponHasChanged = true;
		m_bOwnWeaponHasChanged = true;
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor,real p_fHitDelay)
		if (GetEffectFlag(EFFECT_AJE_CAMOUFLAGE)) then
			TerminateAction();
			SetEffectFlag(EFFECT_AJE_CAMOUFLAGE, false);
		endif;
		if(p_pxEnemy==null)then	return 0.0;	endif;
		if(HasTimer(TIMER_ANML_IMMUNITY))then
			if(p_pxEnemy^.GetType()=="ANML")then
				return 0.0;
			endif;
		endif;
		UpdateFightFactors();
		var real fDamage = 0.0f;
		if (m_xDmgCache.m_pxLastEnemy == p_pxEnemy && m_xDmgCache.m_fDamage>0.0f && !p_pxEnemy^.WeaponHasChanged() && !OwnWeaponHasChanged()) then
			fDamage = m_xDmgCache.m_fDamage;
		else
			if(cast<CCharacter>(this)!=null && cast<CCharacter>(this)^.GetTransportObj().IsValid()) then return 0.0f; endif;
			//KLog.LogSpam("Fight","TaskName = "+m_pxTaskMgr^.GetCurTaskName());

			var real fDmg = p_fFactor * (p_pxEnemy^.AddTemporaryAttackBoni(p_pxEnemy^.GetDmg()) * (1.0 + (p_pxEnemy^.GetAttackBoni().GetBonus(GetType().AsString(),GetClassName())/ 100.0)));

			if(GetType()=="BLDG") then
				var real fBldgBonus = p_pxEnemy^.GetBonusSum(BONUS_DAMAGE_BLDG);
				if(fBldgBonus>0.0f) then
					var int iTmp = fDmg.ToInt();
					fDmg *= (1.0f + fBldgBonus*0.01f);
					if(fDmg.ToInt()==iTmp) then fDmg+=0.5f; endif;
				endif;
			endif;
			var real fDefense;

			var real fArmorPiercing = p_pxEnemy^.GetArmorPiercing();

			if(p_pxEnemy^.GetProjectile().IsEmpty())then
				fDefense = fDmg * Math.Clamp((AddTemporaryDefenseBoni(Math.Max(0.0,(GetProtection()-fArmorPiercing)))+((GetDefenseBoni().GetBonus(p_pxEnemy^.GetType().AsString(),p_pxEnemy^.GetClassName())*GetTechTreeModifier("Defence_"+p_pxEnemy^.GetType().AsString(), true)+GetTechTreeModifier("Defence_"+p_pxEnemy^.GetType().AsString(), false))))*0.01, 0.0f, 0.99f);
			else
				fDefense = fDmg * Math.Clamp(AddTemporaryRangedDefenseBoni(Math.Max(0.0,(GetRangedProtection()-fArmorPiercing))) * 0.01, 0.0f, 0.99f);
			endif;


			//L KLog.LogInfo("Fight",GetName()+" gets a hit with "+fDmg.ToString()+" dmg and absorbs "+fDefense.ToString()+" dmg! (after boni)");

			fDamage = fDmg-fDefense;
			fDamage = fDamage*p_pxEnemy^.m_fAttackFactor;

			m_xDmgCache.m_pxLastEnemy = p_pxEnemy;
			m_xDmgCache.m_fDamage = fDamage;

			if(fDamage>0.0f)then
				CFeedbackEventMgr.Get().AddAttackEvent(GetHandle(),GetOwner());
			endif;

		endif;

		if(p_pxEnemy^.GetClassName()=="ninigi_icespearman")then
			SetIced(2.5f);
		endif;

		//SetDmgTimer
		var ^CTimerIDTick pxTick = new CTimerIDTick();
		pxTick^.m_xOnTickID = ProvideDmg;
		if(p_fHitDelay>0.0)then
			pxTick^.SetTimer(p_fHitDelay);
		endif;
		m_axDmgTimer.NewEntryRef().Init(pxTick^.GetTimer(), fDamage, p_pxEnemy^.GetHandle(), pxTick, p_pxEnemy^.GetProjectile()!="", p_pxEnemy^.GetPoisonDmg(), p_pxEnemy^.GetPoisonMaxTickCount());
		if(p_fHitDelay<=0.0)then
			ProvideDmg(-1);
		endif;
		return 0.0;
	endproc;

	proc void ProvidePoison(real p_fDmg, int p_iMaxCount)

		if(GetType()=="BLDG" || GetType()=="VHCL" || GetType()=="SHIP")then return; endif;

		AddRangedBuff("is_poisoned");
		SetPoisonedFlag(true);

		//strong enough to be primary?
		if(m_xPrimaryPoison<=p_fDmg)then
			if(m_xPrimaryPoison>=m_xSecondaryPoison.GetTicksLeft())then
				m_xSecondaryPoison = m_xPrimaryPoison;
			endif;
			m_xPrimaryPoison.SetPoison(p_fDmg, p_iMaxCount, 0);
		//long enough to be secondary?
		elseif(m_xSecondaryPoison<=p_iMaxCount)then
			m_xSecondaryPoison.SetPoison(p_fDmg, p_iMaxCount, 0);
		else
		endif;

	endproc;

	proc void DecayPoison()
		if(m_xSecondaryPoison <= 0)then
			RemoveRangedBuff("is_poisoned");
			SetPoisonedFlag(false);
			return;
		endif;
		m_xPrimaryPoison = m_xSecondaryPoison;
		m_xSecondaryPoison.Reset();
	endproc;

	export proc ref bool CheckGrantResourcesBLDG()
		return m_bBLDGResBack;
	endproc;

	export proc ref bool CheckGrantResourcesSHIP()
		return m_bSHIPResBack;
	endproc;


	export proc void GrantResources(int p_iPlayer)

		if(IsDead())then return; endif;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(p_iPlayer);
		if(pxPlayer==null)then return; endif;
		var ^CAttribs pxPlAttr = pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		var ^CBasePlayer pxBasePlayer = cast<CBasePlayer>(pxPlayer);
		if(pxBasePlayer==null)then return; endif;
		var CTechTree xPlayerTechTree = pxPlayer^.GetPlayerTechTree();
		var ^CTechTree.CNode pxPlayerResources = xPlayerTechTree.FindNode("Resources/"+pxBasePlayer^.m_sTribe);
		if(pxPlayerResources==null)then return; endif;
		var CTechTreeDef xTTDef;
		var ^CTechTreeMgr pxTTMgr=CSrvWrap.GetGame().GetTechTreeMgr();
		var CTechTree xTT=pxTTMgr^.GetTechTree(xTTDef);

		var ^CTechTree.CNode pxBuildAction = xTT.FindNode(GetBuildAction()+"/conditions");
		if(pxBuildAction==null)then return; endif;
		var ^CTechTree.CNode pxResCosts = pxBuildAction^.GetSub("rescosts");
		if(pxResCosts==null)then return; endif;

		var int i, iC = pxPlayerResources^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var string sResName = pxPlayerResources^.GetSub(i)^.GetValue();
			var int iValue = pxResCosts^.GetSubValueI(sResName,0);
			if(iValue!=0)then
				var int iPlValue = pxPlAttr^.GetValueInt(sResName);
				var int iPlMaxValue = pxPlAttr^.GetValueInt("max_"+sResName);
				if(iPlValue<iPlMaxValue)then
					pxPlAttr^.SetValue(sResName, Math.Min(iPlValue+iValue, iPlMaxValue));
				endif;
			endif;
		endfor;

	endproc;

	export proc void SetBuildAction(string p_sAction)
		m_sMyBuildAction = p_sAction;
	endproc;

	export proc ref string GetBuildAction()
		if(m_sMyBuildAction.IsEmpty())then
			var string sBuildPath = "/Actions/"+GetTribeName()+"/Build/"+GetType().AsString()+"/"+GetClassName();
			if(m_xTechTree.FindNode(sBuildPath)!=null)then
				 m_sMyBuildAction = sBuildPath;
			endif;
		endif;
		return m_sMyBuildAction;
	endproc;

	export proc void InvokeAreaThrow(ref vec3 p_rvPos,real p_fRange)
		InvokeAreaThrow(p_rvPos,p_fRange,GetOwner(),m_iSizeClass);
	endproc;

	export proc bool CheckMaxAutoprodDist(CObjHndl p_xObj)
		if(!p_xObj.IsValid()) then return false; endif;
		if(MAX_AUTOPROD_DIST<=0) then return true; endif; //disabled
		var vec3 vDest=p_xObj.GetObj()^.GetPos();
		return CSrvWrap.GetPathfinder().CheckShortPathDist(GetOwner(),GetPos(),vDest,MAX_AUTOPROD_DIST);
	endproc;

	export proc bool CheckMaxAutoprodDist(vec3 p_vPos)
		if(MAX_AUTOPROD_DIST<=0) then return true; endif; //disabled
		return CSrvWrap.GetPathfinder().CheckShortPathDist(GetOwner(),GetPos(),p_vPos,MAX_AUTOPROD_DIST);
	endproc;

	export static proc void InvokeAreaThrow(ref vec3 p_rvPos,real p_fRange,int p_iOwner,int p_iSizeClass)
		var CObjList xEnemies;
		var int iOwner=p_iOwner;
		if(iOwner<0||true) then
			var CObjQuery xQuery;
			//xQuery.SetOwner(-1);
			xQuery.SetType("CHTR");
			xQuery.SetType("ANML",true);
			xQuery.RegionCircle(p_rvPos,p_fRange);
			xQuery.Execute(xEnemies);
		else
			var ^CObjList pxList = CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
			if (pxList != null) then
				pxList^.CopySorted(xEnemies,p_rvPos,p_fRange);
			endif;
		endif;
		if(xEnemies.NumEntries()==0) then return; endif;
		InvokeAreaThrow(p_rvPos,xEnemies,p_iSizeClass);
	endproc;

	export static proc void InvokeAreaThrow(ref vec3 p_rvPos,ref CObjList p_rxEnemies,int p_iSizeClass)
		if(p_rxEnemies.NumEntries()==0) then return; endif;
		var vec3 vPT=p_rvPos;
		var int i;
		p_rxEnemies.SortDistance(vPT,true); //begin with farthest, because of getfreepos
		for(i=0) cond(i<p_rxEnemies.NumEntries()) iter(i++) do
			var ^CFightingObj pxEnemy=cast<CFightingObj>(p_rxEnemies[i].GetObj());
			if(pxEnemy!=null&&pxEnemy^.m_iSizeClass>0) then
				var real fStr;
				if(CalcSizeClassAreaThrow(p_iSizeClass,pxEnemy^.m_iSizeClass,fStr))then
					if(!pxEnemy^.GetTransportObj().IsValid()) then
						var vec3 vPE=pxEnemy^.GetPos();
						var vec3 vDir=vPE-vPT;
						var real fDist=vDir.Abs();
						if(fDist>0.0) then vDir/=fDist; endif;
						var real fDelay=fDist/20.0;
						if(pxEnemy^.HasAnim("hit_back")) then
							var string sAct=pxEnemy^.GetActionDesc();
							if(sAct!="CActFall") then
								pxEnemy^.FallActionDest(vPE+vDir*fStr,"hit_back","getting_up",0.0);
							endif;
						endif;
					endif;
				endif;
			endif;
		endfor;
	endproc;

	export static proc bool CalcSizeClassAreaThrow(int p_iFighterSize,int p_iEnemySize,ref real po_rfStrength)
		var int iSzDiff=p_iFighterSize-p_iEnemySize;

		if(iSzDiff<3) 			then return false; endif; //Gr÷¯enunterschied < 3 Stufen -> keine Reaktion
		if(p_iFighterSize==0) 	then return false; endif; //Fighter hat  0 -> keine Reaktion
		if(p_iEnemySize==0) 	then return false; endif; //Enemy hat  0 -> keine Reaktion

		//po_rfStrength - So weit wird der Gegner weggeschleudert
		var real fStrengthJitter=0.3;	//Zufõllige Abweichung der Stõrke um +30%

		switch(iSzDiff)
		//******************************* TUNING **********************************//
			case (3) do po_rfStrength=2.0; endcase;
			case (4) do po_rfStrength=3.5; endcase;
			case (5) do po_rfStrength=4.0; endcase;
			case (6) do po_rfStrength=5.5; endcase;
			case (7) do po_rfStrength=6.0; endcase;
			case (8) do po_rfStrength=7.0; endcase;
			case (9) do po_rfStrength=8.0; endcase;
		//******************************* /TUNING **********************************//
			case default do KLog.LogError("FightingObj","CalcSizeClassAreaThrow(...) invalid sizeclass diff:"+iSzDiff.ToString()+" "+p_iFighterSize.ToString()+"/"+p_iEnemySize.ToString()); return false; endcase;
		endswitch;

		po_rfStrength+=Random.MTRandF(po_rfStrength*fStrengthJitter);
		return true;
	endproc;

	export static proc bool CalcSizeClassThrow(int p_iFighterSize,int p_iEnemySize,ref real po_rfStrength)
		var int iSzDiff=p_iFighterSize-p_iEnemySize;

		if(iSzDiff<3) 			then return false; endif; //Gr÷¯enunterschied < 3 Stufen -> keine Reaktion
		if(p_iFighterSize==0) 	then return false; endif; //Fighter hat  0 -> keine Reaktion
		if(p_iEnemySize==0) 	then return false; endif; //Enemy hat  0 -> keine Reaktion

		var real fChance;	//Chance f³r den Wurf 0.0=0%   1.0=100%
		//po_rfStrength - So weit wird der Gegner weggeschleudert
		var real fStrengthJitter=0.2;	//Zufõllige Abweichung der Stõrke um +20%

		switch(iSzDiff)
		//******************************* TUNING **********************************//
			case (3) do fChance=0.02; po_rfStrength=1.0; endcase;
			case (4) do fChance=0.04; po_rfStrength=1.5; endcase;
			case (5) do fChance=0.06; po_rfStrength=2.0; endcase;
			case (6) do fChance=0.08; po_rfStrength=2.5; endcase;
			case (7) do fChance=0.10; po_rfStrength=3.0; endcase;
			case (8) do fChance=0.20; po_rfStrength=4.0; endcase;
			case (9) do fChance=0.30; po_rfStrength=5.0; endcase;
		//******************************* /TUNING **********************************//
			case default do KLog.LogError("FightingObj","CalcSizeClassThrow(...) invalid sizeclass diff:"+iSzDiff.ToString()); return false; endcase;
		endswitch;

		if(fChance<=Random.MTRandF()) then return false; endif; //nicht getroffen
		po_rfStrength+=Random.MTRandF(po_rfStrength*fStrengthJitter);

		return true;
	endproc;

	proc void ProvideDmg(int p_iID)
		var int i, iC = m_axDmgTimer.NumEntries();
		var int iIndex = -1;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axDmgTimer[i].GetTimer()!=p_iID)then continue; endif;
			iIndex = i;
			break;
		endfor;
		if(iIndex==-1)then return; endif;

		var ^CFightingObj pxEnemy = cast<CFightingObj>(m_axDmgTimer[iIndex].GetSource().GetObj());
		var real fDmg = m_axDmgTimer[iIndex].GetDmg();
		var real fPoisonDmg = m_axDmgTimer[iIndex].GetPoisonDmg();
		var int iPoisonMaxTickCount = m_axDmgTimer[iIndex].GetPoisonMaxTickCount();

		if (m_axDmgTimer[iIndex].IsProjectile()) then
			if(GetEffectFlag(EFFECT_ITEM_RING)) then
				fDmg *= 0.5f;
			endif;
		endif;

		if (GetEffectFlag(EFFECT_ITEM_AMULETT1)) then
			fDmg *= 0.5f;
		endif;

		if(pxEnemy==null && !m_axDmgTimer[iIndex].IsProjectile())then return; endif;

		if(GetInvulnerable()<=0 && !GetLDInvulnerable())then

			if(pxEnemy!=null)then
				m_xLastEnemy = pxEnemy^.GetHandle();
			endif;

			var bool bDefense = true;
			var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
			if(cast<CFlee>(pxTask)!=null) then bDefense=false; endif;

			if(pxEnemy!=null && bDefense)then
				if(HasTimer(TIMER_PREAGGRO) && !HasTimer(TIMER_AGGRO))then
					ActivateAggroTimer();
				endif;
				AddEnemy(pxEnemy^.GetHandle(), true);
				pxTask=m_pxTaskMgr^.GetCurTask(); //OnDefend can delete pxTask!!!
			endif;

			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if (pxLevel != null) then
				var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
				if (pxPlayer != null) then
					var ^CBasePlayer pxBasePlayer = cast<CBasePlayer>(pxPlayer);
					if(pxBasePlayer != null)then
						if(pxEnemy!=null)then
							pxBasePlayer^.IWasAttacked(GetHandle(), pxEnemy^.GetHandle());
						endif;
					endif;
				endif;
			endif;

			begin DamageAction;
				if(pxEnemy!=null&&!GetOnWall()&&fDmg>=1.0f) then
					var vec3 vPT=GetPos();
					var vec3 vPE=pxEnemy^.GetPos();
					var vec3 vDir=vPT-vPE;
					if(vDir.Abs()>0.0001f) then
						vDir.Normalize();
						vDir.SetZ(vDir.GetZ()+0.5);
						vDir.Normalize();

						var real fThrowStrength=0.0;
						var bool bThrow=CalcSizeClassThrow(pxEnemy^.m_iSizeClass,m_iSizeClass,fThrowStrength);
						if(bThrow) then
							if(GetTransportObj().IsValid()) then
								bThrow=false;
							endif;
							//Fallback: RT#6740
							if(cast<CCharacter>(this)==null&&cast<CAnimal>(this)==null) then
								bThrow=false;
							endif;
						endif;

						//var int iSizeClassDiff=(pxEnemy^.m_iSizeClass-m_iSizeClass);
						var bool bSlide=false; //((iSizeClassDiff>=0)&&(Random.GetInt()<(32768/10+iSizeClassDiff*32768/5)));  //10%+iSizeClassDiff*20%
						//var bool bThrow=((iSizeClassDiff>=1)&&(Random.GetInt()<32768/10)); //10%

						begin AlwaysThrowEnemy;
							var int iAlwaysThrowEnemy;
							CSettings.Get("Game/GamePlayOptions/AlwaysThrowEnemy",iAlwaysThrowEnemy);
							if(iAlwaysThrowEnemy!=0) then
								bThrow=true;
							endif;
						end AlwaysThrowEnemy;

						if(bThrow) then
							SetHitReactionTimer(0.4f,vDir*fThrowStrength);
						else
							if(bSlide) then
								//var real fLength=fDmg*0.1f;
								//if(fLength>0.8f) then fLength=0.8f; endif;
								//vDir*=fLength;
								var real fLength=0.6f;
								if(m_iSizeClass==2) then fLength=1.3f;
								elseif(m_iSizeClass==3) then fLength=2.5f; endif;
								SecondaryActionGetHit(vDir,0.75f);	//this is a secondary action and doesn't affect the main action
							endif;

							//KLog.LogError("CHP","hit_reaction");
							//var bitset dwDir=GetDirection8(vDir);
							var bitset dwDir=GetDirection(vDir*-1.0);
							var bitset dwEvt=CObjBase.TSCEvent.EID_Invalid; //invalid events will be skipped

							m_dwLastHitDirection=dwDir;
							if(!m_axDmgTimer[iIndex].IsProjectile())then

								if(dwDir==DIR_FRONT) 		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_F; endif;
								if(dwDir==DIR_BACK) 		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_B; endif;
								if(dwDir==DIR_LEFT) 		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_L; endif;
								if(dwDir==DIR_RIGHT) 		then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_R; endif;
//								if(dwDir==DIR_BACK_LEFT) 	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_BL; endif;
//								if(dwDir==DIR_BACK_RIGHT) 	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_BR; endif;
//								if(dwDir==DIR_FRONT_LEFT) 	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_FL; endif;
//								if(dwDir==DIR_FRONT_RIGHT)	then dwEvt=CObjBase.TSCEvent.EID_HitReactionOVLAnim_FR; endif;

								if(GetType()!="BLDG" && GetType()!="VHCL" && GetType()!="SHIP") then
									//blood effect + hit reaction
									if(!m_xTrap.IsValid())then
										InvokeSCEvent(dwEvt,3.0f);
									endif;
								endif;
								//material effect
								pxEnemy^.InvokeGenericSCEvent(37,0.2f);
							endif;

						endif;

					endif;
				endif;
			end DamageAction;

			begin ItemHandling;
				if (pxEnemy!=null) then
					var string sCur = pxEnemy^.GetCurrentWeapon();
					if (sCur.Find("Items")>=0) then
						var ^CWeaponMgr pxMgr = pxEnemy^.GetWeaponMgr();
						var int iIdx = pxMgr^.FindWeapon(sCur);
						var ^CWeaponDesc pxWeapon = pxMgr^.GetWeapon(iIdx);
						if(pxWeapon != null && pxWeapon^.IsSpecialWeapon()) then
							pxWeapon^.GetSpecialWeapon()^.OnHit(this);
						endif;
					endif;
				endif;
			end ItemHandling;

			var real fPotentialDmg = Math.Max(Math.Ceil(fDmg),1.0);
			var int iEnemyOwner = -1;
			if(pxEnemy!=null)then
				iEnemyOwner = pxEnemy^.GetOwner();
				m_iLastDamage = pxEnemy^.GetOwner();
			endif;

			if(pxEnemy!=null)then
				var ^CFightingObj.CSpecialAbility pxAb = pxEnemy^.m_xAbilities.GetAbility("drain_life", true);
				if(pxAb!=null) then	
					pxEnemy^.HealMe(fDmg*pxAb^.GetValueF("amount"));
				endif;
			endif;

			var real fPotentialHitpoints = m_fHitpoints - fPotentialDmg;

			if(fPotentialHitpoints<=0.0 && !IsDead())then

				if(GetType()=="SHIP" && pxEnemy!=null && pxEnemy^.CheckGrantResourcesSHIP())then
					GrantResources(iEnemyOwner);
				elseif(GetType()=="BLDG" && pxEnemy!=null && pxEnemy^.CheckGrantResourcesBLDG())then
					GrantResources(iEnemyOwner);
				//Sonderscripting
				elseif(GetClassName()=="aje_resource_collector" && pxEnemy^.CheckGrantResourcesBLDG())then
					GrantResources(iEnemyOwner);
				endif;
			endif;

			if(fPoisonDmg>0.0 && iPoisonMaxTickCount>0)then
				ProvidePoison(fPoisonDmg, iPoisonMaxTickCount);
			endif;
			if(CanDisguise())then
				ResetCamouflageTimer();
			endif;
			if(!IsAbleToFight())then ShoutForHelp(false);endif;
			Damage(fDmg);
		endif;
		m_axDmgTimer.DeleteEntryUS(iIndex);
	endproc;

	export proc void ResetCamouflageTimer()
		DeleteTimer(CAMO_TIMER);
		CreateTimer(CAMO_TIMER, CGameTimeSpan.OneSecond() * 10.0, false);
	endproc;

	export proc bool CanDisguise()
		if(GetClassName()=="ninigi_muraeno_submarine")then
			return true;
		endif;
/*		if(GetClassName()=="seas_submarine")then
			return true;
		endif;
*/		return GetClassName()=="ninigi_ninja" && CRequirementsMgr.Get().CheckInvention(this, GetOwner(), "disguise", GetTribeName());
	endproc;

	export proc int GetScalpValue()
		var real fScalps=m_xTechTree.GetValueR(GetObjPath()+"/scalps",5.0);
		fScalps *= GetTechTreeModifier("Skulls",true);
		fScalps += GetTechTreeModifier("Skulls",false);
		return Math.Round(fScalps).ToInt();
	endproc;


	///////
	// TriggerTimer
	//////
	export proc void TriggerTimer(real p_fSecs)
		CreateTimer(TIMER_INVUL, CGameTimeSpan.OneSecond() * p_fSecs, false);
		SetLDInvulnerable(true);
	endproc;

	///////
	//	TakeDIrectDmg()
	///////
	export proc void TakeDirectDmg(real p_fDmg)
		TakeDirectDmg(p_fDmg, 0.0);
	endproc;

	export proc void TakeDirectDmg(real p_fDmg, real p_fArmorPiercing)
		if(GetInvulnerable()<=0 && !GetLDInvulnerable())then
			var real fDef=Math.Clamp(AddTemporaryRangedDefenseBoni(GetRangedProtection()-p_fArmorPiercing) / 100.0, 0.0f, 0.99f);
			var real fDefense = p_fDmg * fDef;
			Damage(p_fDmg-fDefense);
		endif;
	endproc;

	export proc void TakeDirectDmg(real p_fDmg, real p_fArmorPiercing,int p_iDmgDealer)
	    m_iLastDamage=p_iDmgDealer;
		TakeDirectDmg(p_fDmg,p_fArmorPiercing);
	endproc;

	///////
	//	TakeDIrectDmg()
	//  Use p_iDmgDealer to set the player who deals the damage (because this lucky fellow wants to have his skulls)
	///////
	export proc void TakeDirectDmg(real p_fDmg,int p_iDmgDealer)
	    m_iLastDamage=p_iDmgDealer;
		TakeDirectDmg(p_fDmg);
	endproc;

	///////
	//	TakeDIrectDmg()
	///////
	export proc void TakeDirectMeleeDmg(real p_fDmg)		
		TakeDirectMeleeDmg(p_fDmg, 0.0);
	endproc;
		
	///////
	//	TakeDIrectDmg()
	///////
	export proc void TakeDirectMeleeDmg(real p_fDmg, real p_fArmorPiercing)
		if(GetInvulnerable()<=0 && !GetLDInvulnerable())then
			var real fDef=Math.Clamp(AddTemporaryDefenseBoni(GetProtection()-p_fArmorPiercing) / 100.0, 0.0f, 0.99f);
			var real fDefense = p_fDmg * fDef;
			Damage(p_fDmg-fDefense);
		endif;
	endproc;
	
	export proc void TakeDirectMeleeDmg(real p_fDmg,int p_iDmgDealer)		
	    m_iLastDamage=p_iDmgDealer;
		TakeDirectMeleeDmg(p_fDmg);
	endproc;

	export proc void OnAttack(^CGameObj p_pxEnemy)
		OnDefend(p_pxEnemy);
	endproc;

	///////
	//	OnDefend()
	///////
	export proc void OnDefend(^CGameObj p_pxEnemy)
		if (GetInvisibleFlag()) then return; endif;
		if(m_iAggressionState==-1)then return; endif;
		if(p_pxEnemy!=null)then
			HandleGamePlayCommand("Action",p_pxEnemy,p_pxEnemy^.GetPos(),"/AttackSrv");
		endif;
	endproc;

	export proc void AddEnemy(CObjHndl p_xEnemy, bool p_bDefend)

		m_xPotEnemies.Include(p_xEnemy);
		if(p_bDefend)then
			m_xHelpDefendEnemies.Include(p_xEnemy);
		else
			m_xHelpAttackEnemies.Include(p_xEnemy);
		endif;
		if(!IsInFight()&&(p_bDefend||GetAggressionState()!=1)&&GetAggressionState()!=3)then
			ExamineEnemies(false, false);
		endif;
	endproc;

	///////
	//	PreCheckForEnemies()
	///////
	export proc void PreCheckForEnemies()

		var int iOwner=GetOwner();
		if(iOwner<0) then return; endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
		if(pxEnemies==null) then return; endif;

		var real fRange = GetAlarmRange();
		if(GetAttackRange()>fRange)then
			//CSrvWrap.LogWarning("FightingObj",GetName()+": AttackRange greater than AlarmRange!");
			fRange = GetAttackRange();
		endif;
		fRange+=50.0f;

		var int iNearest=pxEnemies^.FindNearest(GetPos(),fRange);
		var int iFOWNearest=pxEnemies^.FindNearest(GetPos(),GetFOWRange());

		if(iNearest!=-1 /*AI: || /* m_xPriorityList.NumEntries()>0*/)then
			ActivateAggroTimer();
		else
			DeleteTimer(TIMER_AGGRO);
		endif;

		if(iFOWNearest==-1)then
			SetAlarmed(false);
		endif;

	endproc;
	
	export proc void UpdateFightFactors()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer!=null)then
			m_fDefenseFactor=pxPlayer^.GetPlayerDefenseFactor();
			m_fAttackFactor=pxPlayer^.GetPlayerAttackFactor();
		else
			m_fDefenseFactor=1.0f;
			m_fAttackFactor=1.0f;
		endif;
	endproc;

	///////
	//	ExamineEnemies()
	///////

	export proc bool ExamineEnemies(bool p_bAlarm)
		return ExamineEnemies(p_bAlarm, true);
	endproc;

	export proc bool ExamineEnemies(bool p_bAlarm, bool p_bFillEnemyList)

		//FightingObj is trying to determine, which enemy to attack...
		var CObjList xEnemies;
		var CObjList xAlarmEnemies;

		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
		UpdateFightFactors();

		if(p_bFillEnemyList)then
			FillEnemyList(xEnemies,xAlarmEnemies);
		endif;

		if(m_xCurEnemy.IsValid())then
			m_xPotEnemies.Include(m_xCurEnemy);
		endif;

		var CObjHndl xNextTarget;

		if(m_xPotEnemies.NumEntries()<=0 /*AI: && m_xPriorityList.NumEntries()<=0*/)then
			if(xEnemies.NumEntries() == 0)then
				if(xAlarmEnemies.NumEntries()==0)then
					if(p_bAlarm)then
						SetAlarmed(false);
					endif;
					return false;
				else
					SetAlarmed(true,xAlarmEnemies[0]);
					return false;
				endif;
			endif;
		endif;

		xEnemies.Include(m_xPotEnemies);
		
		/*AI:
		var int i,iC=m_xPriorityList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxObj=cast<CFightingObj>(m_xPriorityList[i].GetObj());
			if(pxObj==null)then
				m_xPriorityList.DeleteEntry(i);
				i--; iC--;
			else
				xEnemies.Include(m_xPriorityList[i]);
				m_vAggressionPos=pxObj^.GetPos();
				break;
			endif;
		endfor;
		*/
		var CObjHndl xOptimalTarget;
		if(GetAttribs()!=null)then
			xOptimalTarget.FromInt(GetAttribs()^.GetValueInt("OptimalTarget"));
			if(xOptimalTarget.IsValid())then
				xEnemies.Include(xOptimalTarget);
			endif;
		endif;
		
		SortEnemyList(xEnemies, GetAttackRange(), GetRealMinAttackRange()>0.0, true);

		SetAlarmed(false);
		if(xEnemies.NumEntries()>0)then
			xNextTarget = xEnemies[0];
		endif;

		var bool bFoundEnemy = false;
		if(xNextTarget.IsValid())then  //if iC==0, xNextTarget is null
			
			if(	m_xCurEnemy.IsValid()											//Er kämpft bereits gegen jemanden...
				&& !(xNextTarget==m_xCurEnemy))then								//Das neue Ziel ist ungleich dem gegenwärtigen Ziel
				
				var ^CFightingObj pxFO=cast<CFightingObj>(xNextTarget.GetObj());
				
				if(!IsInCombatRange(pxFO, false))then
						
					var CGameTime xNow = CTimeMgr.Get().GetTime();
					
					if(m_xChangeTargetTime==CGameTime.GetInvalidTime())then
						m_xChangeTargetTime=xNow;
						return bFoundEnemy;
					endif;
					
					if((xNow-m_xChangeTargetTime).GetSecondsF()<2.0)then
						return bFoundEnemy;
					endif;
						
				endif;
			endif;

			m_xChangeTargetTime=CGameTime.GetInvalidTime();
			
			
			if(m_xHelpDefendEnemies.FindEntry(xNextTarget)==-1)then
				m_xHelpAttackEnemies.Include(xNextTarget);
			endif;
			OnAttack(xNextTarget.GetObj());
			bFoundEnemy = true;
		endif;

		m_xPotEnemies.Clear();
		
		return bFoundEnemy;

	endproc;


	export proc void SortEnemyList(ref CObjList p_rxList, real p_fAttackRange, bool p_bSortMinAttackRange, bool p_bAttackOwn)

		var array CFightingObj.CEnemyListSorter axList;
		var real fAlarmRng		= GetAlarmRange()*2.0;
		var real fAttackRange	= p_fAttackRange;
		var real fCalcRange = (fAlarmRng+fAttackRange)*(fAlarmRng+fAttackRange);

		var bool bSelfWaterMelee=(!CanWalk()&&CanSwim()&&(m_fAttackRange<1.0));
		var bool bTorpedo=(GetClassName()=="seas_submarine")||(GetClassName()=="ninigi_muraeno_submarine");

		var int iOwner = GetOwner();
		
		var int iOptimalTarget=-2;
		if(GetAttribs()!=null)then
			iOptimalTarget=GetAttribs()^.GetValueInt("OptimalTarget");
		endif;
		
		var int i, iC = p_rxList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do

			var ^CFightingObj pxObj = cast<CFightingObj>(p_rxList[i].GetObj());
			if(pxObj==null)then continue; endif;

			if(pxObj^.IsMarkedForDelete())then continue; endif;

			if(!pxObj^.IsHitable())then continue; endif;
			if(pxObj^.GetIsVanished())then continue; endif;
			
			if(iOwner!=-1 && iOwner==pxObj^.GetOwner())then continue; endif;

			if(pxObj^.GetEffectFlag(EFFECT_AJE_CAMOUFLAGE) && !(p_rxList[i]==m_xCurEnemy))then continue; endif;

			var bool bInPriorityList=m_xPriorityList.FindEntry(p_rxList[i])!=-1;

			if(!bInPriorityList && cast<CWall>(pxObj)!=null && !(p_rxList[i]==m_xCurEnemy))then continue; endif;

			if(pxObj^.GetClassName()=="pirate_boss")then
				var ^CPirateBoss pxBoss=cast<CPirateBoss>(pxObj);
				if(pxBoss!=null)then
					p_rxList.Include(pxBoss^.GetSegel());
					p_rxList.Include(pxBoss^.GetHeck());	
					p_rxList.Include(pxBoss^.GetBug());	
					iC=p_rxList.NumEntries();
				endif;
				continue;
			endif;
			if(pxObj^.GetClassName()=="pirate_boss_cannons")then continue; endif;

			if(iOwner>-1 && (pxObj^.GetVisibleMask()&(01b<<iOwner))==00b )then continue; endif; //SB#16733 units should not see objects invisible for their owner

			var bool bWasAttacked=(m_xPotEnemies.FindEntry(p_rxList[i])!=-1);

			if(!bWasAttacked && (bSelfWaterMelee || bTorpedo))then
				var bool bHarbour=cast<CHarbour>(pxObj)!=null;
				var real fHeight=CSrvWrap.GetScapeMgr().GetHeight(pxObj^.GetPos().GetX(),pxObj^.GetPos().GetY());
				var real fSeaLevel=CSrvWrap.GetScapeMgr().GetSeaLevel();
				if(!bTorpedo)then fSeaLevel+=1.7; else fSeaLevel-=0.5; endif;
	 			if(!bHarbour&&(fHeight>fSeaLevel))then continue; endif;
			endif;

			var int iObjOwner = pxObj^.GetOwner();

			if(!p_bAttackOwn && iOwner==iObjOwner)then
				continue;
			endif;

			if(iOwner!=-1 && iObjOwner!=-1 && iOwner!=iObjOwner)then
				if(!CSrvWrap.GetDiplomacyMgr().GetIsEnemy(iOwner, pxObj^.GetOwner())) then continue; endif;
			endif;
			var bool bNeutralEnemy=false;
			if(!bInPriorityList && iObjOwner==-1)then
				if(pxObj^.GetAggressive()!=1)then
					if(bWasAttacked)then
						bNeutralEnemy=true;
					else
						continue;
					endif;
				endif;
			endif;

			var bool bInRange=(m_vAggressionPos-pxObj^.GetPos()).Abs2S() <= fCalcRange;

			var bool bWildAnimal=(iOwner==-1);
			var bool bEnemyWildAnimal=(iObjOwner==-1);
			
			if(!bInPriorityList && !bWildAnimal && !bInRange && !m_bAggressionWalk)then continue; endif;
			
			//Ai doesn't want to attack wild animals on aggro walk, this could be solved high level, but would cost much more performance and is not timing consistent
			if(bEnemyWildAnimal&&m_bAggressionWalk&&m_bAggrTNoAnml)then continue; endif;

			var ^CFightingObj.CEnemyListSorter pxSorter = ^(axList.NewEntryRef());
			pxSorter^.m_xObj = p_rxList[i];
			pxSorter^.m_iIndex = i;
			pxSorter^.m_iAttackType = GetAttackType();
			pxSorter^.m_bCurrentTarget = p_rxList[i]==m_xCurEnemy; //PrioritiyList?
			pxSorter^.m_bInCombatRange = IsInCombatRange(pxObj, false);
			pxSorter^.m_bInPriorityList = bInPriorityList;
			pxSorter^.m_bPrioTarget = p_rxList[i].AsInt()==iOptimalTarget;
			pxSorter^.m_fDmg = pxObj^.GetDmg();
			pxSorter^.CalculateValue();
		endfor;

		axList.QSort();
		p_rxList = 0;

		if(p_bSortMinAttackRange)then

			var real fSecondaryS = GetSecondaryRangeS();
			var real fSecondaryM = GetSecondaryRangeM();
			var real fMinAttackRange = GetRealMinAttackRange();

			var real fCollisionRadius = GetCollisionRadius();

			fSecondaryS+=fCollisionRadius+2.0f;
			fSecondaryM+=fCollisionRadius+2.0f;
			fAttackRange+=fCollisionRadius+2.0f;
			fMinAttackRange+=fCollisionRadius+2.0f;

			var real fProjFallOffCone;

			if(!GetRealProjectile().IsEmpty()) then
				fProjFallOffCone=GetProjectileFallOffCone();
			endif;

			var CObjList xMinRangeTargets;

			iC = axList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxEnemy = cast<CFightingObj>(axList[i].m_xObj.GetObj());
				fSecondaryM = fMinAttackRange;
				var int iRng = IsInCombatRangeAttackZone(pxEnemy,fSecondaryS,fSecondaryM,fAttackRange,fProjFallOffCone);
				if(iRng<=2)then
					xMinRangeTargets.AddEntry(pxEnemy^.GetHandle());
					continue;
				endif;
				p_rxList.AddEntry(pxEnemy^.GetHandle());
			endfor;
			if(!GetSecondaryWeaponS().IsEmpty() || !GetSecondaryWeaponM().IsEmpty())then
				p_rxList.Include(xMinRangeTargets);
			endif;
		else
			iC = axList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				p_rxList.AddEntry(axList[i].m_xObj);
			endfor;
		endif;

	endproc;


	///////
	//	FillEnemyList()
	///////

	export proc void FillEnemyList(ref CObjList p_rxDirectList, ref CObjList p_rxAlarmList)

		var string sString;

		var int iOwner=GetOwner();
		if(iOwner<0) then return; endif;

		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(iOwner);
		if(pxEnemies==null) then return; endif;

		// TODO:
		CSrvWrap.GetObjMgr()^.FilterOwnerEnemyList(pxEnemies);
		/*
		var int i, iC = pxEnemies^.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CGameObj pxO = pxEnemies^[i].GetObj();
			if(pxO==null || pxO^.GetType()=="OTHR") then
				pxEnemies^.DeleteEntry(i--);--iC;
			endif;
		endfor;
		*/

		var real fMaxRange 	= GetAttackRange();
		var real fAlarmRange= GetAlarmRange();
		//Dump("GetRightHandWeapon()="+GetRightHandWeapon());
		//Dump("fMaxRange="+fMaxRange.ToString());
		//Dump("fAlarmRange="+fAlarmRange.ToString());

		if(GetRealProjectile()!="")then
			var vec3 vCenter=GetProjectileStartPos();
			if (fAlarmRange > fMaxRange) then
				var real fFallOff=GetProjectileFallOffCone(fAlarmRange);
				pxEnemies^.CopySortedCone(p_rxAlarmList,vCenter,fFallOff,Math.Max(fAlarmRange,30.0f));
				p_rxAlarmList.CopySortedCone(p_rxDirectList,vCenter,fFallOff,fMaxRange);
			else
				var real fFallOff =GetProjectileFallOffCone(fMaxRange);
				pxEnemies^.CopySortedCone(p_rxDirectList,vCenter,fFallOff,Math.Max(fMaxRange,30.0f));
				p_rxDirectList.CopySortedCone(p_rxAlarmList,vCenter,fFallOff,fAlarmRange);
			endif;
		else
			pxEnemies^.CopySorted2D(p_rxAlarmList,GetPos(),fAlarmRange);
			p_rxAlarmList.CopySorted2D(p_rxDirectList,GetPos(),Math.Max(fMaxRange,30.0f));
		endif;

		if(GetClassName()=="darwin_s0")then
			var int i, iC=p_rxDirectList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var CObjHndl xHndl = p_rxDirectList[i];
				if(xHndl.IsValid())then
					if(xHndl.GetObj()^.GetType()=="ANML" && xHndl.GetObj()^.GetOwner()==-1)then
						p_rxDirectList.DeleteEntry(i--);
						--iC;
					endif;
				endif;
			endfor;

			iC=p_rxAlarmList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var CObjHndl xHndl = p_rxAlarmList[i];
				if(xHndl.IsValid())then
					if(xHndl.GetObj()^.GetType()=="ANML" && xHndl.GetObj()^.GetOwner()==-1)then
						p_rxAlarmList.DeleteEntry(i--);
						--iC;
					endif;
				endif;
			endfor;
		endif;

	endproc;

	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy)
		var CObjHndl xInvalid; var bool bInvalid;
		return IsInCombatRange(p_pxEnemy,bInvalid,xInvalid);
	endproc;

	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, bool p_bUpdateWeapons)
		var CObjHndl xInvalid; var bool bInvalid;
		return IsInCombatRange(p_pxEnemy,bInvalid,xInvalid, GetAttackRange(),p_bUpdateWeapons);
	endproc;

	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, ref bool po_rbInMinRange, ref CObjHndl p_rxLastMinRangeTarget)
		return IsInCombatRange(p_pxEnemy,po_rbInMinRange,p_rxLastMinRangeTarget,GetAttackRange());
	endproc;

	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, ref bool po_rbInMinRange, ref CObjHndl p_rxLastMinRangeTarget, real p_fAttackRange)
		return IsInCombatRange(p_pxEnemy,po_rbInMinRange,p_rxLastMinRangeTarget,p_fAttackRange,true);
	endproc;

	export proc bool IsInCombatRange(^CFightingObj p_pxEnemy, ref bool po_rbInMinRange, ref CObjHndl p_rxLastMinRangeTarget, real p_fAttackRange, bool p_bUpdateWeapons)

		var ^CFightingObj pxEnemy 	=p_pxEnemy;

		var bool bIgnoreHeight=false;

		var vec3 vFighterPos;
		var vec3 vEnemyPos;
		var vec3 vLastEnemyPos;
		var real fFightDistance=pxEnemy^.GetCollisionRadius();
		var real fCollRadiusFighter=GetCollisionRadius();

		if(pxEnemy^.GetClassName()=="carrier_launch_pad")then
			fFightDistance=pxEnemy^.GetRadius();
			fCollRadiusFighter+=(fFightDistance*0.7);
			bIgnoreHeight=true;
		endif;

		vFighterPos = GetPos();
		vEnemyPos = pxEnemy^.GetPos();
		vLastEnemyPos = pxEnemy^.GetLastPos();
		if((vFighterPos-vEnemyPos).Abs2S()>(vFighterPos-vLastEnemyPos).Abs2S())then
			vEnemyPos=vLastEnemyPos;
		endif;

		var real fSecondaryS = GetSecondaryRangeS();
		var real fSecondaryM = GetSecondaryRangeM();
		var real fAttackRange = p_fAttackRange;

		var real fMinAttackRange = GetRealMinAttackRange();
		var bool bMinAttackRange = fMinAttackRange>0.0;

		fSecondaryS+=fCollRadiusFighter+2.0f;
		fSecondaryM+=fCollRadiusFighter+2.0f;
		fMinAttackRange+=fCollRadiusFighter;

		var bool bPrimProj=false;
		var real fProjFallOffCone=0.0;
		if(!GetRealProjectile().IsEmpty()) then
			fProjFallOffCone=GetProjectileFallOffCone();
			bPrimProj=true;
			fAttackRange+=GetCollisionRadiusInner();
			fMinAttackRange-=pxEnemy^.GetCollisionRadiusInner();
		elseif(GetPenetration() && m_fAttackRange>5.0)then
			bPrimProj=true;
			fAttackRange+=GetCollisionRadiusInner();
		else
			fAttackRange+=fCollRadiusFighter+2.0f;
		endif;
		if(fAttackRange>0.0f&&fAttackRange<4.0f) then fAttackRange=4.0f; endif; //primary minimum

		var vec3 vDir=vFighterPos-vEnemyPos;
		var real fDist = vDir.Abs2();

		var real fZFighter=GetPos().GetZ();
		var real fZEnemy=pxEnemy^.GetPos().GetZ();
		var real fZDiff=Math.Abs(fZEnemy-fZFighter);
		var real fHeight;

		if(fZFighter>fZEnemy)then
			fHeight=pxEnemy^.GetSize().GetZ();
		else
			fHeight=GetSize().GetZ();
		endif;

		fHeight=Math.Min(7.0,fHeight);

		var bool bHeightOk=(fZDiff<fHeight)||bIgnoreHeight;

		if(bHeightOk||bPrimProj) then
			//if(fDist<=fSecondaryS+fFightDistance||fDist<=fSecondaryM+fFightDistance||fDist<=fAttackRange+fFightDistance) then

				if(bMinAttackRange)then
					fSecondaryM = fMinAttackRange;
				endif;

				var int iRng=IsInCombatRangeAttackZone(pxEnemy,fSecondaryS,fSecondaryM,fAttackRange,fProjFallOffCone);
				//KLog.LogWarn("JaNe","IsInCR: "+GetName()+" "+p_pxEnemy^.GetName()+" D:"+fDist.ToString()+" ZF:"+fZFighter.ToString()+" ZE:"+fZEnemy.ToString()+" AR:"+fAttackRange.ToString()+" "+fProjFallOffCone.ToString()+" "+vDir.Abs2ConeS(fProjFallOffCone).ToString()+" R:"+iRng.ToString());
				if((iRng!=3||(!bPrimProj))&&cast<CBuilding>(this)==null&&cast<CBuilding>(pxEnemy)==null) then
					if(!CheckLineOfSightFight(pxEnemy,fDist)) then
						//KLog.LogWarn("CHP","LOS Check failed");
						return false;
					endif;
				endif;
				if(iRng!=0 && IsOnOpenTransporter())then
					iRng=3;
				endif;
				//KLog.LogWarn("CHP","B:"+iRng.ToString()+" D:"+fDist.ToString(2)+" AR:"+fAttackRange.ToString(2)+" FO:"+fProjFallOffCone.ToString(2));
				if(iRng==0) then return false; endif; //out of range
				if(iRng==3) then //primary/long range
					if(GetRightHandWeapon()!=GetCurrentWeapon() && p_bUpdateWeapons)then
						UpdateWeapons(GetRightHandWeapon());
						pxEnemy^.ClearDamageCache();
					endif;
					return true;
				endif;
				if(!bHeightOk) then return false; endif; //out of range
				if(iRng==1) then //short range
					if(fSecondaryS>0.0 && GetSecondaryWeaponS()!=GetCurrentWeapon() && p_bUpdateWeapons)then
						UpdateWeapons(GetSecondaryWeaponS());
						pxEnemy^.ClearDamageCache();
					endif;
					return true;
				endif;
				if(iRng==2)then //medium range
					if(bMinAttackRange)then

						po_rbInMinRange = true;

						if(p_rxLastMinRangeTarget==p_pxEnemy^.GetHandle())then
							if(fSecondaryS>0.0 && GetSecondaryWeaponS()!=GetCurrentWeapon() && p_bUpdateWeapons)then
								UpdateWeapons(GetSecondaryWeaponS());
								pxEnemy^.ClearDamageCache();
							endif;
						else
							p_rxLastMinRangeTarget = p_pxEnemy^.GetHandle();
						endif;

						return false;

					elseif(fSecondaryM>0.0 && GetSecondaryWeaponM()!=GetCurrentWeapon() && p_bUpdateWeapons)then
						UpdateWeapons(GetSecondaryWeaponM());
						pxEnemy^.ClearDamageCache();
					endif;
					return true;
				endif;
			//endif;
		endif;
		return false;
	endproc;


	export proc bool IsInScapeCombatRange(vec3 p_vAttackPos, ref bool po_rbInMinRange)

		var vec3 vFighterPos;
		var vec3 vEnemyPos = p_vAttackPos;
		var real fCollRadiusFighter = GetCollisionRadius();

		vFighterPos = GetPos();

		var real fSecondaryS = GetSecondaryRangeS();
		var real fSecondaryM = GetSecondaryRangeM();
		var real fAttackRange = GetAttackRange();

		var real fMinAttackRange = GetRealMinAttackRange();
		var bool bMinAttackRange = fMinAttackRange>0.0;

		fSecondaryS+=fCollRadiusFighter+2.0f;
		fSecondaryM+=fCollRadiusFighter+2.0f;
		fAttackRange+=fCollRadiusFighter+2.0f;
		fMinAttackRange+=fCollRadiusFighter;
		if(fAttackRange>0.0f&&fAttackRange<4.0f) then fAttackRange=4.0f; endif; //primary minimum

		var bool bPrimProj=false;
		var real fProjFallOffCone=0.0;
		if(!GetRealProjectile().IsEmpty()) then
			fProjFallOffCone=GetProjectileFallOffCone();
			bPrimProj=true;
		endif;

		var real fDist = (vFighterPos-vEnemyPos).Abs2();

		if(bPrimProj || GetPenetration()) then
			if(fDist>fAttackRange)then
				if(GetRightHandWeapon()!=GetCurrentWeapon())then
					UpdateWeapons(GetRightHandWeapon());
				endif;
				return false;
			endif;

			if(bMinAttackRange)then
				fSecondaryM = fMinAttackRange;
			endif;

			if(fDist>fSecondaryM)then
				if(GetRightHandWeapon()!=GetCurrentWeapon())then
					UpdateWeapons(GetRightHandWeapon());
				endif;
				return true;
			endif;

			if(fDist<=fSecondaryS)then
				if(GetSecondaryWeaponS()!=GetCurrentWeapon())then
					UpdateWeapons(GetSecondaryWeaponS());
				endif;
				if(bMinAttackRange)then
					po_rbInMinRange = true;
					return false;
				else
					return true;
				endif;
			endif;

			if(fDist<=fSecondaryM)then
				if(bMinAttackRange)then
					if(fSecondaryS>0.0 && GetSecondaryWeaponS()!=GetCurrentWeapon())then
						UpdateWeapons(GetSecondaryWeaponS());
					endif;
					po_rbInMinRange = true;
					return false;
				else
					if(GetSecondaryWeaponM()!=GetCurrentWeapon())then
						UpdateWeapons(GetSecondaryWeaponM());
					endif;
					return true;
				endif;
			endif;

			if(fDist<=fSecondaryM)then
				if(GetSecondaryWeaponS()!=GetCurrentWeapon())then
					UpdateWeapons(GetSecondaryWeaponS());
				endif;
				return true;
			endif;
		endif;
		return false;
	endproc;

	export proc int GetAttackType()
		return m_iAttackType;
	endproc;

	export proc void SetAttackType(int p_iType)
		//0	-	normal attack unit
		//1	-	unit against buildings
		m_iAttackType=p_iType;
	endproc;


	///////
	//	SetDmg()
	///////
	export proc void SetDmg(real p_fDmg)
		m_fDamage = p_fDmg;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("damage", Math.Ceil(m_fDamage).ToInt());
		endif;
	endproc;

	///////
	//	GetDmg()
	///////
	export proc real GetDmg()
		return m_fDamage;
	endproc;


	export proc ref real GetPoisonDmg()
		return m_fPoisonDmg;
	endproc;

	export proc void SetPoisonDmg(real p_fDmg)
		m_fPoisonDmg = p_fDmg;
	endproc;


	export proc ref int GetPoisonMaxTickCount()
		return m_iPoisonMaxTickCount;
	endproc;

	export proc void SetPoisonMaxTickCount(int p_iTickCount)
		m_iPoisonMaxTickCount = p_iTickCount;
	endproc;

	export proc void SetWeaponSizeClass(int p_iWeaponSizeClass) m_iWeaponSizeClass=p_iWeaponSizeClass; endproc;
	export proc int GetWeaponSizeClass() return m_iWeaponSizeClass; endproc;

	export proc void SetHitRange(real p_fHitRange)
		m_fHitRange = p_fHitRange;
	endproc;

	export proc ref real GetHitRange()
		return m_fHitRange;
	endproc;


	export proc void SetRealHitRange(real p_fHitRange)
		m_fRealHitRange = p_fHitRange;
	endproc;

	export proc ref real GetRealHitRange()
		return m_fRealHitRange;
	endproc;


	export proc void SetEndDmg(real p_fEndDmg)
		m_fEndDmg = p_fEndDmg;
	endproc;

	export proc ref real GetEndDmg()
		return m_fEndDmg;
	endproc;


	///////
	//	SetFormationPriorityFront2Back()
	///////
	export proc void SetFormationPriorityFront2Back(real p_fFront)
		m_vFormationPriority.SetY(p_fFront);
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("formation_y",p_fFront);
		endif;
	endproc;

	///////
	//	SetFormationPriorityCenter2Side()
	///////
	export proc void SetFormationPriorityCenter2Side(real p_fCenter)
		m_vFormationPriority.SetX(p_fCenter);
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("formation_x",p_fCenter);
		endif;
	endproc;

	///////
	//	GetFormationPriority()
	///////
	export proc ref vec2 GetFormationPriority()
		return m_vFormationPriority;
	endproc;

	///////
	//	SetMinDmg()
	///////
	export proc void SetMinDmg(real p_fDmg)
		m_fMinDamage = p_fDmg;
	endproc;

	///////
	//	SetProtection()
	///////
	export proc void SetProtection(real p_fProt)
		m_fProtection = p_fProt;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("defense",(m_fProtection+0.5).ToInt());
		endif;
	endproc;

	///////
	//	GetProtection()
	///////
	export proc ref real GetProtection()
		return m_fProtection;
	endproc;

	///////
	//	SetRangedProtection()
	///////
	export proc void SetRangedProtection(real p_fProt)
		m_fRangedProtection = p_fProt;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("rangeddefense",(m_fRangedProtection+0.5).ToInt());
		endif;
	endproc;

	///////
	//	GetProtection()
	///////
	export proc ref real GetRangedProtection()
		return m_fRangedProtection;
	endproc;

	///////
	//	IsDead()
	///////
	export proc bool IsDead()
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			return pxAttribs^.GetValueBool("dead");
		endif;
		return false;
	endproc;

	export proc void SetDead(bool p_bValue)
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs!=null)then
			pxAttribs^.SetValue("dead",p_bValue);
		endif;
	endproc;

	///////
	//	ChangeMaxHitpoints()
	///////
	export proc void ChangeMaxHitpoints(real p_fNewMax)
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		if(pxLevel==null || pxLevel^.IsEditable())then
			return;
		endif;

		var real fRate;
		if(m_fMaxHitpoints==0.0)then
			fRate = 1.0;
		else
			fRate = m_fHitpoints / m_fMaxHitpoints;
		endif;
		m_fMaxHitpoints = p_fNewMax + GetBonusSum(BONUS_MAXHITPOINTS);
		m_fHitpoints = m_fMaxHitpoints * fRate;

		UpdateHitpoints();
	endproc;

	///////
	//	AddHitpoints()
	///////
	export proc void AddHitpoints(real p_fAdd)
		m_fHitpoints = Math.Clamp((m_fHitpoints+p_fAdd),0.0,m_fMaxHitpoints);
		UpdateHitpoints();
	endproc;

	///////
	//	SetTransportObj()
	///////
	export proc void SetTransportObj(CObjHndl p_xHndl)
		m_xTransportObj = p_xHndl;
		if (m_xTransportObj.IsValid()) then
			GetAttribs()^.SetValue("transporter_guid", m_xTransportObj.GetObj()^.GetGuid().ToString());
		else
			GetAttribs()^.SetValue("transporter_guid","");
			var Quat qR; qR.SetIdentity();
			SetAdditionalRot(qR);
			UpdateCamouflageLayers();
		endif;
	endproc;

	///////
	//	GetTransportObj()
	///////
	export proc CObjHndl GetTransportObj()
		return m_xTransportObj;
	endproc;

	///////
	//	UpdateHitpoints()
	///////
	export proc void UpdateHitpoints()
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("hitpoints",m_fHitpoints);
			pxAttr^.SetValue("maxhitpoints",m_fMaxHitpoints);
		endif;

		SetDefaultWalkSet(GetWalkSet());

		if(m_fHitpoints<=0.0)then
			Die();
		endif;
		//If building
		if(GetType()=="BLDG")then
			//and not under construction
			if(!(GetConstructLevel()<4))then
				UpdateDestructionFlags();
			endif;
		elseif(GetType()=="SHIP" || GetType()=="VHCL") then
			UpdateDestructionFlags();
		endif;

		if(!IsDead() && GetRageUnit())then
			if((m_fHitpoints*4.0)<=m_fMaxHitpoints)then
				if(!m_bRage)then
					var ^CTechTreeDef pxTDef = GetTechTreeDef();
					if(pxTDef!=null)then
						pxTDef^.EnableFilter("/Filters/Hu/Upgrades/hu_wild_boar/wild_boar_rage");
						//L KLog.LogSpam("JaNe",GetName()+" EnableFilter");
					endif;
					m_bRage=true;
					ForceBoniUpdate();
				endif;
			else
				if(m_bRage)then
					m_bRage=false;
					var ^CTechTreeDef pxTDef = GetTechTreeDef();
					if(pxTDef!=null)then
						pxTDef^.DisableFilter("/Filters/Hu/Upgrades/hu_wild_boar/wild_boar_rage");
						//L KLog.LogSpam("JaNe",GetName()+" DisableFilter");
					endif;
					ForceBoniUpdate();
				endif;
			endif;
		endif;

	endproc;
	
	export proc void UpdateRageUnit()
	endproc;

	export proc ref CFourCC GetWalkSet()
		if(IsSeriouslyInjured()&&HasWalkSet(m_xHumpWalkSet))then
			return m_xHumpWalkSet;
		else
			return m_xWalkSet;
		endif;
	endproc;

	export proc ref CFourCC GetHumpWalkSet()
		if(HasWalkSet(m_xHumpWalkSet))then
			return m_xHumpWalkSet;
		else
			return m_xWalkSet;
		endif;
	endproc;
	
	
	///////
	//	Die()
	///////
	export proc void Die()
		if(!IsDead())then
			if(m_xTransportObj.IsValid())then
				var ^CTransportObj pxObj = cast<CTransportObj>(m_xTransportObj.GetObj());
				if(pxObj!=null)then
					pxObj^.OnDismount(GetHandle(),true,GetPos());
				endif;
			endif;

			var CFourCC xType=GetType();

			if(m_xProduceUnit.IsValid()) then
				var ^CVirtualProduceUnit pxO = cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
				if(pxO!=null) then pxO^.Die(); endif;
				m_xProduceUnit.FromInt(-1);
			endif;
			
			var bool bCreateSprit=false;
			if((xType=="CHTR"||xType=="ANML") && GetOwner()!=-1)then
				
				var ^CAttribs pxAttr=GetAttribs();
				if(pxAttr!=null)then
					if(pxAttr^.GetValue("illusion")=="1")then
						bCreateSprit=false;
					else
						bCreateSprit=true;
					endif;
				endif;
				
				if(cast<CHero>(this)!=null || GetClassName()=="special_eusmilus")then
					var ^CLevelInfoHost pxLevelInfo=^(CSrvWrap.GetCurLevel()^.GetLevelInfo());
					if(!pxLevelInfo^.IsMultiplayer())then
						bCreateSprit=false;
					endif;
				endif;
			endif;
			if(bCreateSprit)then
				CreateSpirit();
			endif;
			
			m_fHitpoints = 0.0f;
			if(xType=="BLDG") then
				SetExploTimer();
				if(GetTribeName()=="Ninigi")then
					if(m_xTechTree.GetValueI("/Objects/"+GetTribeName()+"/InventObjects/Explode/invented",0)!=0)then
						AuthorizationPicardFourSevenAlphaTango(); //:)
					endif;
				endif;
				SetDead(true);
			else
				SetDead(true);
				Delete();
			endif;

		endif;
	endproc;

	export proc bool SelfDestruct()
		return(true);
	endproc;

	export proc void DiePerHarakiri()		
		OnKill();
		Die();
	endproc;

	proc bool SetExploTimer();
		CreateTimer(TIMER_EXPLOSION, CGameTimeSpan.OneSecond() * 1.0, true);
		return(true);
	endproc;

	///////
	//	DieFastAndSilent()
	///////
	export proc void DieFastAndSilent()
		if(!IsDead())then
			m_fHitpoints = 0.0f;
			SetVisible(false);
			SetDead(true);
			Delete();
		endif;
	endproc;

	proc bool AuthorizationPicardFourSevenAlphaTango()
		new CAreaDamage(20.0f,500.0f,100.0f,GetOwner(),GetPos(),7);
		return(true);
	endproc;

	///////
	//	Delete()
	///////
	export proc void Delete()
		if(m_xGroup.IsValid()) then
			var ^CGroupObj pxGroup = cast<CGroupObj>(m_xGroup.GetObj());
			if(pxGroup!=null) then
				pxGroup^.RemMember(GetHandle());
			endif;
		endif;

		var ^CInventory pxInv = GetInventory();
		if (pxInv!=null) then
			var int i, iC = pxInv^.Count();
			var CObjList xList;
			for(i=0) cond(i<iC) iter(++i) do
				if(!pxInv^.GetItem(i).IsValid())then continue; endif;
				xList.Include(pxInv^.GetItem(i));
			endfor;
			iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				if (xList[i].IsValid()) then
					var ^CGameObj pxItem = xList[i].GetObj();
					var ^CItem pxI = cast<CItem>(pxItem);
					if (pxI != null) then
						RemoveItem(pxI^.GetHandle());
					endif;
				endif;
			endfor;
			pxInv^.Clear();
		endif;

		SetStartFilter(false);
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.Break();
  			/*if(m_pxTaskMgr^.GetCurTask()!=null)then
  				m_pxTaskMgr^.GetCurTask()^.Break();
  			endif;*/
		endif;
		DeletePersonalRegion();
		SetLevelFilter(false);
		if(cast<CHero>(this)==null && m_iLevel==4)then
			SetLevelFilter(false,"Filters/"+GetTribeName()+"/Upgrades/AllNonHeroes/Lvl"+(m_iLevel+1).ToString());
		endif;

		RemoveUnit();
		ClearFX();

		super.Delete();
	endproc;

	///////
	//	SetrReaction()
	///////
	export proc void SetReaction(real p_fDmg)
		if(p_fDmg>0.0)then
			Damage(p_fDmg);
		elseif(p_fDmg<0.0)then
			HealMe(p_fDmg);
			//L CSrvWrap.LogSpam("Shotgun","Name: "+GetName()+" Hitpoints after Hit: "+m_fHitpoints.ToString());
		endif;
	endproc;

	export proc real GetAttackDirection()
		return m_fAttackDirection;
	endproc;

	export proc void SetAttackDirection(real p_fDirection)
		m_fAttackDirection = p_fDirection;
	endproc;

	export proc void RotateToEnemy(^CFightingObj p_pxEnemy, vec3 p_vPos)
		 RotateToEnemy(p_pxEnemy,p_vPos,"",0.0);
	endproc;

	export proc void RotateToEnemy(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sOverlayAnim, real p_fOverlayRatio)
		if(GetTransportObj().IsValid())then return; endif;
		var Quat qRot;
		if(p_pxEnemy!=null)then
			qRot = GetAngleToQ(p_pxEnemy);
		else
			qRot = GetAngleToQ(p_vPos);
		endif;
		m_bRotateAction = true;
		if(!p_sOverlayAnim.IsEmpty() && HasAnim(p_sOverlayAnim)) then
			RotateAction(qRot,p_sOverlayAnim,p_fOverlayRatio);
		else
			RotateAction(qRot);
		endif;
	endproc;

	export proc real GetAngleToR(^CGameObj p_pxTarget)
		return GetAngleToR(p_pxTarget^.GetPos());
	endproc;

	export proc real GetAngleToR(vec3 p_vPos)
		var vec3 vDir = (p_vPos - GetPos()).GetNormalized();
		vDir.RotZ(GetAttackDirection());
		var Quat qRot;
		qRot.FromXYDir(vDir.GetX(), vDir.GetY());
		var Quat qRotDiff=qRot/GetRot();
		var vec3 vRot;
		qRotDiff.ToVec3(vRot);
		return Math.Abs(vRot.GetZ());
	endproc;

	export proc Quat GetAngleToQ(^CGameObj p_pxTarget)
		return GetAngleToQ(p_pxTarget^.GetPos());
	endproc;

	export proc Quat GetAngleToQ(vec3 p_vPos)
		var vec3 vDir = (p_vPos - GetPos()).GetNormalized();
		vDir.RotZ(GetAttackDirection());
		var Quat qRot;
		qRot.FromXYDir(vDir.GetX(), vDir.GetY());
		return qRot;
	endproc;


	proc bool StartFireworks(string p_sTTPath)
    	if(GetClassName()!="ninigi_monk")then return(false);endif;
    	if(CheckSpecialActionTimer(p_sTTPath))then
	    	var ^CFireworks pxTask=cast<CFireworks>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Firework"));
	   		var bool bReturn=pxTask^.Init(GetHandle());
	   		pxTask^.SetUserCommand(true);
	   		AddTask(pxTask,false);
	    	return bReturn;
    	else
    		return(false);
    	endif;
	endproc;

	proc bool StartSweepingBlow(string p_sTTPath)
		if(CheckSpecialActionTimer(p_sTTPath))then
	    	var ^CSweepingBlow pxTask=cast<CSweepingBlow>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"SwpBlow"));
	   		var bool bReturn=pxTask^.Init(GetHandle());
	   		pxTask^.SetUserCommand(true);
	   		AddTask(pxTask,false);
	    	return bReturn;
    	else
    		return(false);
    	endif;
	endproc;
	
	export proc void SetHitDone()
		m_xLastHitDone=CTimeMgr.Get().GetTime();
	endproc;

	export proc void ResetHitDone()
		m_xLastHitDone=CGameTime.GetInvalidTime();
	endproc;

	export proc bool CanDoNextHit(real p_fDuration)
		if(m_xLastHitDone==CGameTime.GetInvalidTime())then
			return true;
		endif;
		return (CTimeMgr.Get().GetTime()-m_xLastHitDone).GetSecondsF()>p_fDuration;
	endproc;

	///////
	//	AttackEnemy()
	///////
	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		//if(p_pxEnemy!=null)then

			var string sProj=GetProjectile();

			var string sFAnim=GetNextFightAnim();

			if (sFAnim.IsEmpty()) then sFAnim="attack_front"; endif;
			var bool bProj=!sProj.IsEmpty();
			var bool bFAnim=!sFAnim.IsEmpty();

			begin Rotate;
				var real fAngle;
				if(p_pxEnemy!=null)then
					fAngle = GetAngleToR(p_pxEnemy);
				else
					fAngle = GetAngleToR(p_vTarget);
				endif;

				if(!bProj&&bFAnim) then
					if(GetPenetration()&&fAngle>(Math.Pi()/16.0f))then
						RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
						DoCaptainAttackAnim();
						p_rbRotated = true;
					elseif(fAngle>Math.Pi()/8.0)then
						RotateToEnemy(p_pxEnemy, p_vTarget, sFAnim, 0.5);
						DoCaptainAttackAnim();
						p_rbRotated = true;
						return true;
					endif;
				else
					//normal rotate
					if(fAngle>Math.Pi()/4.0 || (GetPenetration()&&fAngle>Math.Pi()/16.0f)) then
						RotateToEnemy(p_pxEnemy, p_vTarget);
						p_rbRotated = true;
						return false;
					endif;
				endif;
			end Rotate;

			if(GetPenetration())then
				Penetrate(p_pxEnemy,p_vTarget);
				if(sFAnim!="" && HasAnim(sFAnim))then
					SetAnim(sFAnim,1);
				endif;
				return false;
			elseif(bProj) then
				CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
				if(sFAnim!="" && HasAnim(sFAnim))then
					SetAnim(sFAnim,1);
				endif;
				DoCaptainAttackAnim();
				return false;
			elseif(bFAnim)then
				if(sFAnim!="" && HasAnim(sFAnim))then
					SetAnim(sFAnim,1);
				endif;
				DoCaptainAttackAnim();
			endif;
		//endif;

		return true;
	endproc;

	export proc void DoCaptainAttackAnim()
	endproc;

	export proc void Penetrate(^CFightingObj p_pxEnemy)
		Penetrate(p_pxEnemy^.GetPos());
	endproc;

	export proc void Penetrate(^CFightingObj p_pxEnemy, vec3 p_vPos)
		if(p_pxEnemy!=null)then
			Penetrate(p_pxEnemy^.GetPos());
		else
			Penetrate(p_vPos);
		endif;
	endproc;

	export proc void Penetrate(vec3 p_vPos)
		var CObjList xList;
		UpdateFightFactors();
		GetPenetratedObjs(p_vPos, GetAttackRange(), xList, GetPenetrationAngle());
		var int i, iC = xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
			if(pxFight!=null)then
				pxFight^.TakeDmg(this);
			endif;
		endfor;
	endproc;

	export proc void Penetrate(^CFightingObj p_pxEnemy, real p_fAngle)
		var CObjList xList;
		UpdateFightFactors();
		GetPenetratedObjs(p_pxEnemy^.GetPos(), GetAttackRange(), xList, p_fAngle);
		var int i, iC = xList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFight = cast<CFightingObj>(xList[i].GetObj());
			if(pxFight!=null)then
				pxFight^.TakeDmg(this);
			endif;
		endfor;
	endproc;

	export proc void GetPenetratedObjs(vec3 p_vTarget, real p_fRadius, ref CObjList p_rxObjs, real p_fAngle)
		var CObjQuery xQuery;

		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery);
		xQuery.SetOwner(-1,true);
		
		var real fDist=(p_vTarget-GetPos()).Abs2();
		//xQuery.SetOwner(0,true);

		var vec3 vPos = GetPos();

		xQuery.RegionCircle(vPos, Math.Max(p_fRadius*2.0, fDist*1.5));
		var CObjList xL;
		xQuery.Execute(xL);

		p_fAngle*=0.5;
		p_fAngle=(Math.Pi()/180.0)*p_fAngle;
		p_fRadius+=GetCollisionRadius()+2.0f;

		var vec3 vDir = (p_vTarget - vPos);

		var int i, iC = xL.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CFightingObj pxO = cast<CFightingObj>(xL[i].GetObj());
			if(pxO!=null)then
				var vec3 vDirEnemy = (pxO^.GetPos()-vPos);
				var real fEnemyRadius=pxO^.GetCollisionRadiusInner();
				var real fEnemyDistSquare=vDirEnemy.AbsSquare();
				
				//KLog.LogSpam("JaNe",pxO^.GetName()+" "+((fEnemyRadius+p_fRadius)*(fEnemyRadius+p_fRadius)).ToString()+" vs. "+fEnemyDistSquare.ToString());
				//KLog.LogSpam("JaNe","fEnemyRadius="+fEnemyRadius.ToString()+" and p_fRadius="+p_fRadius.ToString()+" vs. fEnemyDistSquare="+Math.Sqrt(fEnemyDistSquare).ToString());
				if((fEnemyRadius+p_fRadius)*(fEnemyRadius+p_fRadius) < fEnemyDistSquare)then
					continue;
				endif;
				var real fAngle=vDir.AngBetweenXY(vDirEnemy);
				//KLog.LogSpam("JaNe","fAngle="+fAngle.ToString()+" vs. p_fAngle="+p_fAngle.ToString());
				if(fAngle>p_fAngle)then
					continue;
				endif;

				p_rxObjs.Include(xL[i]);

			endif;
		endfor;
	endproc;

	export proc void EndFight()
		UpdateWeapons(GetRightHandWeapon());
		if(CanDisguise())then
			ResetCamouflageTimer();
			AddCamouflageEffect("disg");
		endif;
	endproc;

	export proc void OnStartFight()
	endproc;

	export proc string GetFirstStrikeAnim()
		return "";
	endproc;

	export proc bool FollowEnemy(^CFightingObj p_pxEnemy, bool p_bAttackScape)

		if(!IsAbleToWalk())then return false; endif;

		var bool bNoUserCommand		= false;

		var ^CTask pxTask = m_pxTaskMgr^.GetCurTask();
		if(pxTask!=null)then
			bNoUserCommand		= !pxTask^.IsUserCommand();
		endif;

		if(bNoUserCommand && GetAggressionState()<=0)then
			return false;
		endif;

		if(m_bDoingFinishingMove)then return false; endif;

		var bool bPos				= false;
		var bool bValidEnemy		= false;
		var bool bFarFromDest		= false;

		var real fAlarmRng			= GetAlarmRange()*2.0;
		fAlarmRng					+= GetAttackRange();

		if(p_pxEnemy!=null)then
			bPos				= (m_vAggressionPos-p_pxEnemy^.GetPos()).Abs2() > fAlarmRng;
			bValidEnemy			= true;
		endif;

		bFarFromDest			= (m_vAggressionPos-GetPos()).Abs2S()>2.0;

		var CFourCC xWalkSet;

		var real fAttackRange;

		if(GetSecondaryWeaponS()==GetCurrentWeapon()) then
			fAttackRange=GetSecondaryRangeS();
		elseif(GetSecondaryWeaponM()==GetCurrentWeapon()) then
			fAttackRange=GetSecondaryRangeM();
		else
			fAttackRange = GetAttackRange()-2.0f;
		endif;

		if(m_fAttackRange<1.0)then
			fAttackRange = 0.0;	//GetCollisionRadius() + 0.1;
		endif;

		var real fPFallOff=0.0;
		if(!GetProjectile().IsEmpty())then
			if(GetRightHandWeapon()==GetCurrentWeapon()) then
				fPFallOff=GetProjectileFallOffCone();
			endif;
		endif;
		if(fPFallOff>0.0) then
			fAttackRange+=GetCollisionRadiusInner();
		else
			fAttackRange+=GetCollisionRadius();
		endif;

		if(bValidEnemy)then
			var ^CWall pxWall=cast<CWall>(p_pxEnemy);
			var ^CTower pxTower=cast<CTower>(p_pxEnemy);
			if(bNoUserCommand)then
				if(m_bAggressionWalk)then
					TerminateAction();
					var CGameObj.CAdvanceActionParams xAWAP;
					xAWAP.m_fMinDistance=fAttackRange;
					xAWAP.m_iPrefSpeed=GetMaxSpeed();
					xAWAP.m_fProjectileFallOff=fPFallOff;
					xAWAP.m_bStopOnLostTarget=bNoUserCommand;
					if(GetOnWall())then
						AdvanceWallAction(p_pxEnemy^.GetHandle(),xAWAP,!p_pxEnemy^.GetOnWall(),bNoUserCommand);
					else
						AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
					endif;
					return true;
				elseif(GetAggressionState()>0)then
					if(bPos /*&& GetAggressionState()==1*/ && !m_bAggressionWalk)then
						if(bFarFromDest)then
							if(GetOnWall())then
								WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
							else
								WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
							endif;
							return false;
						endif;
					else
						var real fDist=(p_pxEnemy^.GetPos()-GetPos()).Abs();
						if(fDist>fAlarmRng-2.0f) then
							return false;
						endif;
						TerminateAction();
						var CGameObj.CAdvanceActionParams xAWAP;
						xAWAP.m_fMinDistance=fAttackRange;
						xAWAP.m_iPrefSpeed=GetMaxSpeed();
						xAWAP.m_xWalkSet=GetWalkSet();
						xAWAP.m_fMaxRange=fAlarmRng;
						xAWAP.m_vRootPos=m_vAggressionPos;
						xAWAP.m_fProjectileFallOff=fPFallOff;
						xAWAP.m_bStopOnLostTarget=bNoUserCommand;
						if(GetOnWall())then
							AdvanceWallAction(p_pxEnemy^.GetHandle(),xAWAP,!p_pxEnemy^.GetOnWall(),bNoUserCommand);
						else
							AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
						endif;
						return true;
					endif;
				elseif(bFarFromDest)then
					if(GetOnWall())then
						WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
					else
						WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
					endif;
				endif;
				return false;
			else
				TerminateAction();
				var CGameObj.CAdvanceActionParams xAWAP;

				xAWAP.m_fMinDistance=fAttackRange;
				xAWAP.m_iPrefSpeed=GetMaxSpeed();
				xAWAP.m_sFirstStrike=GetFirstStrikeAnim();
				xAWAP.m_fProjectileFallOff=fPFallOff;
				xAWAP.m_bStopOnLostTarget=bNoUserCommand;
				if(GetOnWall() || p_pxEnemy^.GetOnWall())then
					if(!GetOnWall() && p_pxEnemy^.GetOnWall() && !GetProjectile().IsEmpty())then
						AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
					else
						AdvanceWallAction(p_pxEnemy^.GetHandle(),xAWAP,!p_pxEnemy^.GetOnWall(),!bNoUserCommand);
					endif;
				else
					AdvanceAction(p_pxEnemy^.GetHandle(),xAWAP);
				endif;
				return true;
			endif;
		else

			if(p_bAttackScape)then
				var CGameObj.CAdvanceActionParams xAWAP;

				xAWAP.m_fMinDistance=fAttackRange;
				xAWAP.m_iPrefSpeed=GetMaxSpeed();
				xAWAP.m_fProjectileFallOff=fPFallOff;
				xAWAP.m_vGoalOffset = m_vAggressionPos;
				xAWAP.m_bStopOnLostTarget=bNoUserCommand;

				if(GetOnWall())then
					AdvanceWallAction(CObjHndl.Invalid(),xAWAP, false, false);
				else
					AdvanceAction(CObjHndl.Invalid(),xAWAP);
				endif;
				return true;
			elseif(bFarFromDest)then
				if(GetOnWall())then
					WallWalkAction(m_vAggressionPos,true,GetDefaultSpeed(),false);
				else
					WalkAction(m_vAggressionPos,GetDefaultSpeed(),true);
				endif;
			elseif(m_bAggressionWalk)then
				m_bAggressionWalk = false;
				m_bAggrTNoAnml=false;
			endif;
			return false;
		endif;
	endproc;


//	###########################################################################################################
//	#### NEW FIGHTINGOBJ PROCS ################################################################################
//	###########################################################################################################

	export proc void SetAggressionWalk(bool p_bAggressionWalk) SetAggressionWalk(p_bAggressionWalk,false);endproc;
	export proc void SetAggressionWalk(bool p_bAggressionWalk,bool p_bAggrTNoAnml)
		m_bAggressionWalk=p_bAggressionWalk;
		m_bAggrTNoAnml=p_bAggrTNoAnml;
	endproc;

	///////
	//	IsAbleToWalk()
	///////
	export proc bool IsAbleToWalk()
		return (CanWalk() || CanSwim() || CanFly()) && !m_bIsTrapped && !GetTransportObj().IsValid();
	endproc;

	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption)
		GoTo(p_vPos,p_bUserCommand,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,false);
	endproc;

	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, bool p_bOnWall)
		GoTo(p_vPos,p_bUserCommand,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,p_bOnWall, false);
	endproc;

	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, bool p_bOnWall, bool p_bQueued)
		GoTo(p_vPos,p_bUserCommand,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,p_bOnWall, p_bQueued, true);
	endproc;

	///////
	//	GoTo()
	///////
	export proc void GoTo(vec3 p_vPos, bool p_bUserCommand, int p_iSpeed, bool p_bUsePathfinder, bool p_bHeightAdaption, bool p_bOnWall, bool p_bQueued, bool p_bUseMaterial)
		if (!IsAbleToWalk()/* || GetEffectFlag(CFightingObj.EFFECT_ITEM_STONED)*/) then
			return;
		endif;
		if(p_bUserCommand)then
			var CObjHndl xInvalid;
			var vec3 vPos(0,0,0);
			SetRallyPoint(vPos,xInvalid);
			AnnounceState("walk");
		endif;

		var bool bNewUserCmd = p_bUserCommand;
		var bool bOldUserCmd = false;

		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCurTask = m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd = pxCurTask^.IsUserCommand();
		endif;

		if(!bNewUserCmd && bOldUserCmd)then return; endif;

		m_bIsHelpShout=false;

		if(bNewUserCmd)then
			m_bAggressionWalk = false;
			m_bAggrTNoAnml=false;
		endif;
		UpdateAggressionPos(p_vPos);
		begin UpdateRider;
			var ^CTransportObj pxTransport = cast<CTransportObj>(this);
			if(pxTransport!=null)then
				var ^CObjList pxPassengers = ^(pxTransport^.GetPassengers());
				if(pxPassengers!=null)then
					var int i, iC = pxPassengers^.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CFightingObj pxFight = cast<CFightingObj>(pxPassengers^[i].GetObj());
						if(pxFight!=null)then
							pxFight^.UpdateAggressionPos(p_vPos);
						endif;
					endfor;
				endif;
			endif;
		end UpdateRider;


		var bool bAdd = p_bQueued;
		if (IsFeignDeath()) then
			var ^CFeignDeath pxT = cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
			if (pxT!=null) then
				pxT^.Init(GetHandle(), false);
				pxT^.SetUserCommand(p_bUserCommand);
				AddTask(pxT,false);
				bAdd = true;
			endif;
		endif;

		var ^CWalkToPos pxTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Walk2Pos"));
    	pxTask^.Init(GetHandle(),p_vPos,p_iSpeed,p_bUsePathfinder,p_bHeightAdaption,p_bOnWall, p_bUseMaterial);
    	pxTask^.SetUserCommand(p_bUserCommand);
	    if (bAdd) then
	    	AddTask(pxTask, true);
	    else
			AddTask(pxTask,false);
	    endif;

	endproc;

	export proc void GoTo(CObjHndl p_xTarget, ref CGameObj.CAdvanceActionParams p_rxParams, bool p_bUserCommand, bool p_bQueued)
		if (!IsAbleToWalk()/* || GetEffectFlag(CFightingObj.EFFECT_ITEM_STONED)*/) then
			return;
		endif;

		if(p_bUserCommand)then
			var CObjHndl xInvalid;
			var vec3 vPos(0,0,0);
			SetRallyPoint(vPos,xInvalid);
			AnnounceState("walk");
		endif;

		var bool bNewUserCmd = p_bUserCommand;
		var bool bOldUserCmd = false;

		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCurTask = m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd = pxCurTask^.IsUserCommand();
		endif;

		if(!bNewUserCmd && bOldUserCmd)then return; endif;

		m_bIsHelpShout=false;

		if(bNewUserCmd)then
			m_bAggressionWalk = false;
			m_bAggrTNoAnml=false;
		endif;
		var vec3 vPos;
		if(p_xTarget.IsValid())then
			vPos=p_xTarget.GetObj()^.GetPos();
		else
			vPos=p_rxParams.m_vGoalOffset;
		endif;
		UpdateAggressionPos(vPos);
		begin UpdateRider;
			var ^CTransportObj pxTransport = cast<CTransportObj>(this);
			if(pxTransport!=null)then
				var ^CObjList pxPassengers = ^(pxTransport^.GetPassengers());
				if(pxPassengers!=null)then
					var int i, iC = pxPassengers^.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CFightingObj pxFight = cast<CFightingObj>(pxPassengers^[i].GetObj());
						if(pxFight!=null)then
							pxFight^.UpdateAggressionPos(vPos);
						endif;
					endfor;
				endif;
			endif;
		end UpdateRider;

		var bool bAdd = p_bQueued;
		if (IsFeignDeath()) then
			var ^CFeignDeath pxT = cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
			if (pxT!=null) then
				pxT^.Init(GetHandle(), false);
				pxT^.SetUserCommand(p_bUserCommand);
				AddTask(pxT,false);
				bAdd = true;
			endif;
		endif;

		var ^CWalkToPos pxTask=cast<CWalkToPos>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Walk2Pos"));
    	pxTask^.Init(GetHandle(), p_xTarget, p_rxParams);
    	pxTask^.SetUserCommand(p_bUserCommand);
	    if (bAdd) then
	    	AddTask(pxTask, true);
	    else
			AddTask(pxTask,false);
	    endif;

	endproc;




	///////
	//	GoTo()
	///////
	export proc void GoToObj(CObjHndl p_xTarget, bool p_bUserCommand, bool p_bQueued)
		if (!IsAbleToWalk()/* || GetEffectFlag(CFightingObj.EFFECT_ITEM_STONED)*/) then
			return;
		endif;
		if(!p_xTarget.IsValid())then
			return;
		endif;
		var ^CGameObj pxObj=p_xTarget.GetObj();

		if(p_bUserCommand)then
			AnnounceState("walk");
		endif;

		var bool bNewUserCmd = p_bUserCommand;
		var bool bOldUserCmd = false;

		if(m_pxTaskMgr==null)then return; endif;
		var ^CTask pxCurTask = m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd = pxCurTask^.IsUserCommand();
		endif;

		if(!bNewUserCmd && bOldUserCmd)then return; endif;

		m_bIsHelpShout=false;

		if(bNewUserCmd)then
			m_bAggressionWalk = false;
			m_bAggrTNoAnml=false;
		endif;
		UpdateAggressionPos(pxObj^.GetPos());
		begin UpdateRider;
			var ^CTransportObj pxTransport = cast<CTransportObj>(this);
			if(pxTransport!=null)then
				var ^CObjList pxPassengers = ^(pxTransport^.GetPassengers());
				if(pxPassengers!=null)then
					var int i, iC = pxPassengers^.NumEntries();
					for(i=0)cond(i<iC)iter(i++)do
						var ^CFightingObj pxFight = cast<CFightingObj>(pxPassengers^[i].GetObj());
						if(pxFight!=null)then
							pxFight^.UpdateAggressionPos(pxObj^.GetPos());
						endif;
					endfor;
				endif;
			endif;
		end UpdateRider;


		var bool bAdd = p_bQueued;
		if (IsFeignDeath()) then
			var ^CFeignDeath pxT = cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
			if (pxT!=null) then
				pxT^.Init(GetHandle(), false);
				pxT^.SetUserCommand(p_bUserCommand);
				AddTask(pxT,false);
				bAdd = true;
			endif;
		endif;

		var ^CWalkToObj pxTask=cast<CWalkToObj>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Walk2Obj"));
    	pxTask^.Init(GetHandle(), p_xTarget);
    	pxTask^.SetUserCommand(p_bUserCommand);
	    if (bAdd) then
	    	AddTask(pxTask, true);
	    else
			AddTask(pxTask,false);
	    endif;

	endproc;



	///////
	//	IsAbleToFight()
	///////
	export proc bool IsAbleToFight()
		return GetDmg()>0.0;
	endproc;

	export proc void SetCanFightAttrib(bool p_bCanFight)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("can_attack", p_bCanFight);
		endif;
	endproc;

	export proc bool IsInFight()
		var ^CTask pxTask = m_pxTaskMgr^.GetCurTask();
		if(pxTask==null)then return false; endif;

		var ^CFight pxFight = cast<CFight>(pxTask);
		var ^CFinishingMove pxFinish = cast<CFinishingMove>(pxTask);

		return (pxFight!=null || pxFinish!=null);
	endproc;

	proc void InvokeFightTask(CObjHndl p_xTarget,vec3 p_vPos,bool p_bUserCommand)
		InvokeFightTask(p_xTarget, p_vPos, p_bUserCommand, false);
	endproc;

	proc void InvokeFightTask(CObjHndl p_xTarget,vec3 p_vPos, bool p_bUserCommand, bool p_bAddTask)
		InvokeFightTask(p_xTarget, p_vPos, p_bUserCommand, false, false);
	endproc;

	proc void InvokeFightTask(CObjHndl p_xTarget,vec3 p_vPos, bool p_bUserCommand, bool p_bAddTask, bool p_bNoUserBerserkerMode)

		if(m_xReturnEnemy.IsValid())then
			p_xTarget = m_xReturnEnemy;
			m_xReturnEnemy.FromInt(-1);
		endif;

   		if(!p_xTarget.IsValid() && p_bUserCommand && !p_bNoUserBerserkerMode && GetRealHitRange()<=0.0 && !GetPenetration())then
   			if(!IsInFight())then
				HandleGamePlayCommand("Action", null, p_vPos, "/AggressiveTarget");
			endif;
			return;
   		endif;

		if(p_xTarget==GetHandle())then return; endif;

		var ^CTask pxCur = m_pxTaskMgr^.GetCurTask();
   		var ^CFight pxTask=cast<CFight>(pxCur);

   		// already in fight, update target

		if (p_xTarget.IsValid()) then
			GetWeaponMgr()^.GetBestWeapon(cast<CFightingObj>(p_xTarget.GetObj()), true);
		endif;

		if(!p_bUserCommand && m_iAggressionState==0)then
			var ^CFightingObj pxEnemy = cast<CFightingObj>(p_xTarget.GetObj());
			var bool bInvalid;
			var CObjHndl xInvalid;
			if(pxEnemy!=null && !IsInCombatRange(pxEnemy, false))then
				return;
			endif;
		endif;

   		if(pxTask!=null)then
   			if(p_bUserCommand && !p_bNoUserBerserkerMode)then
				m_bAggressionWalk=false;
				UpdateAggressionPos(p_vPos);
			endif;

			pxTask^.SetNoUserBerserkerMode(p_bNoUserBerserkerMode);

    		pxTask^.SetUserCommand(p_bUserCommand);
    		pxTask^.UpdateEnemy(p_xTarget, p_vPos);
    		m_xCurEnemy = p_xTarget;
   		else
		    if(p_bUserCommand && !p_bNoUserBerserkerMode)then
				m_bAggressionWalk=false;
				UpdateAggressionPos(p_vPos);
			endif;

   			pxTask=cast<CFight>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Fight"));

   			if (pxTask!=null) then
   				pxTask^.SetUserCommand(p_bUserCommand);
				pxTask^.SetNoUserBerserkerMode(p_bNoUserBerserkerMode);
	    		pxTask^.Init(GetHandle(), p_xTarget, p_vPos);
		    	if(p_bUserCommand && !p_bAddTask)then
					AddTask(pxTask,false);
				elseif (!p_bAddTask) then
					SetTaskImmediate(pxTask);
				else
					AddTask(pxTask,true);
				endif;
				m_xCurEnemy = p_xTarget;
		    endif;

   		endif;
	endproc;

	export proc bool IsBerserking()
		return IsInFight() && m_bIsBerserker && IsBerserkTarget(m_xCurEnemy.GetObj());
	endproc;

	export proc bool IsBerserkTarget(^CGameObj p_pxObj)
		if(p_pxObj==null)then return false; endif;
		if(p_pxObj^.GetType()=="BLDG")then return false; endif;
		if(p_pxObj^.GetType()=="ANML" && p_pxObj^.GetOwner()==-1)then return false; endif;
		if(p_pxObj^.GetType()=="NEST")then return false; endif;
		return true;
	endproc;

	///////
	//	Fight()
	///////
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand)

		var bool bNewUserCmd = p_bUserCommand;
		var bool bOldUserCmd = false;
		var bool bAlreadyInFight = false;
		var bool bAlreadyInAction = false;
		var bool bNoUserBerserkerMode = false;
		if(!IsAbleToFight())then
			return;
		endif;
		var ^CTask pxCurTask = m_pxTaskMgr^.GetCurTask();
		if(pxCurTask!=null)then
			bOldUserCmd = pxCurTask^.IsUserCommand();
			bAlreadyInFight = IsInFight();
			bAlreadyInAction = (cast<CAction>(pxCurTask)!=null);//IsPerformingAction();
		endif;
		if(m_bIsBerserker && IsBerserkTarget(p_pxTarget))then
			if(!bNewUserCmd)then
				bNoUserBerserkerMode = true;
			endif;
			bNewUserCmd = true;
		endif;

		if(!bNewUserCmd && bOldUserCmd)then
			return;
		endif;
		var bool bAdd = false;
		if (IsFeignDeath()) then
			var ^CFeignDeath pxT = cast<CFeignDeath>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "FeignDth"));
			if (pxT!=null) then
				pxT^.Init(GetHandle(), false);
				pxT^.SetUserCommand(p_bUserCommand);
				AddTask(pxT,false);
				bAdd = true;
			endif;
		endif;
		if(p_pxTarget!=null)then
			var ^CFightingObj pxFO = cast<CFightingObj>(p_pxTarget);
			if (pxFO!=null) then

				if (pxFO^.IsFeignDeath()) then
					if (bNewUserCmd) then
						var ^CAnimal pxA = null;
						if (pxFO^.GetType()!="ANML") then
							if(pxFO^.GetTransportObj().IsValid()) then
								pxA = cast<CAnimal>(pxFO^.GetTransportObj().GetObj());
							endif;
						else
							pxA = cast<CAnimal>(pxFO);
						endif;
						if (pxA!=null)then
							pxA^.FeignDeathTask(false);
						endif;
					else
						return;
					endif;
				endif;
			endif;
			if (GetType()=="CHTR") then
				var ^CCharacter pxC = cast<CCharacter>(this);
				if (pxC^.GetTransportObj().IsValid() && !pxC^.IsOnOpenTransporter())then

					var ^CFightingObj pxTransporter=cast<CFightingObj>(pxC^.GetTransportObj().GetObj());
					if(pxTransporter!=null && pxTransporter^.IsTrapped())then return; endif;

					if(!pxTransporter^.GetTransportObj().IsValid())then
						pxTransporter^.HandleGamePlayCommand("Action", p_pxTarget, p_pxTarget^.GetPos(),"/AttackSrv");
						return;
					else
						return;
					endif;
				endif;
			endif;
			m_xCurEnemy = p_pxTarget^.GetHandle();
			if(bNewUserCmd) then
	    		if (GetOwner()!=p_pxTarget^.GetOwner()) then
					var bool bIsMultiplayerGame = false;
					var string sPlayerNameAttacker = "unknown (attacker)";
					var string sPlayerNameDefender = "unknown (defender)";
					var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
					if(pxLevel!=null)then
						var CLevelInfo xLevelInfo = pxLevel^.GetLevelInfo();
						bIsMultiplayerGame = xLevelInfo.IsMultiplayer();
						if(GetOwner()>=0)then
							var ^CPlayer pxPlayerAttacker = pxLevel^.GetPlayer(GetOwner());
							if(pxPlayerAttacker!=null)then
								sPlayerNameAttacker = xLevelInfo.GetPlayerSlot(pxPlayerAttacker^.GetPlayerSlotID()).GetName();
							endif;
						endif;
						if(p_pxTarget^.GetOwner()>=0)then
							var ^CPlayer pxPlayerDefender = pxLevel^.GetPlayer(p_pxTarget^.GetOwner());
							if(pxPlayerDefender!=null)then
								sPlayerNameDefender = xLevelInfo.GetPlayerSlot(pxPlayerDefender^.GetPlayerSlotID()).GetName();
							endif;
						endif;
					endif;
	    			if (!CSrvWrap.GetDiplomacyMgr().GetIsEnemy( p_pxTarget^.GetOwner(), GetOwner() ) && p_pxTarget^.GetOwner()>=0 && GetOwner()>=0) then
						//singleplayer: don't allow to attack a friend (either player is friend of target or target is friend of player)
						//multiplayer: no friends no more.
						if(
							!bIsMultiplayerGame &&
							(
								CSrvWrap.GetDiplomacyMgr().GetIsFriend(p_pxTarget^.GetOwner(), GetOwner()) ||
								CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner())
							)
						)then
							CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_DiplAttackNonEnemyIsNotAllowed\t"+sPlayerNameDefender, p_pxTarget^.GetPos());
							return; // don't allow to attack in single player mode
						else
							if(	CSrvWrap.GetGame().GetAttribInt("DiplomacyLocked")!=0 &&
								CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), p_pxTarget^.GetOwner())
							)then
								CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_DiplAttackNonEnemyIsNotAllowed\t"+sPlayerNameDefender, p_pxTarget^.GetPos());
								return; // don't allow to attack in single player mode
							endif;
							CSrvWrap.GetDiplomacyMgr().SetRelation( p_pxTarget^.GetOwner(), GetOwner(), 0); //Enemy
							CSrvWrap.GetDiplomacyMgr().SetRelation( GetOwner(), p_pxTarget^.GetOwner(), 0);
							//if(!bIsMultiplayerGame)then  endif; // make self hostile towards target in singleplayer because one can not change diplomacy
							//send feedback to all players
							CFeedback.Print(CFeedback.ALL, CFeedback.DIPLOMACY, "_NT_DiplChangeEnemyAttacked\t"+sPlayerNameAttacker+"\t"+sPlayerNameDefender, p_pxTarget^.GetPos());
						endif;
	    			endif;
	    		endif;
			endif;
	    	if(bAlreadyInFight&&bNewUserCmd)then
	    		InvokeFightTask(m_xCurEnemy,p_vPos,bNewUserCmd, bAdd, bNoUserBerserkerMode);
	    	elseif(bAlreadyInAction)then
	    		return;
	    	else
	    		InvokeFightTask(m_xCurEnemy,p_vPos,bNewUserCmd, bAdd, bNoUserBerserkerMode);
	    	endif;
	    else
    		InvokeFightTask(CObjHndl.Invalid(), p_vPos, p_bUserCommand, bAdd, bNoUserBerserkerMode);
	    endif;
    endproc;

//	###########################################################################################################
//	#### NEW FIGHTINGOBJ PROCS ################################################################################
//	###########################################################################################################

	///////
	//	ShoutForHelp()
	///////
	export proc void ShoutForHelp(bool p_bForced)

		var CGameTime xNow = CTimeMgr.Get().GetTime();

		if(!p_bForced)then
			var real fDuration=7.0;
			if(GetHitpoints()<GetMaxHitpoints())then
				fDuration=3.0;
			endif;
			if((xNow-m_xLastHelpShout).GetSecondsF()<fDuration)then
				return;
			endif;
		endif;

		var bool bDefend=true;
		var CObjHndl xEnemy;
		if(m_xHelpDefendEnemies.NumEntries()>0)then
			xEnemy=m_xHelpDefendEnemies[0];
		elseif(m_xHelpAttackEnemies.NumEntries()>0)then
			xEnemy=m_xHelpAttackEnemies[0];
			bDefend=false;
		else
			xEnemy=m_xCurEnemy;
			bDefend=false;
		endif;

		var ^CTask pxTask=m_pxTaskMgr^.GetCurTask();
		if(pxTask!=null && pxTask^.IsUserCommand())then return; endif;

		var CObjQuery xFriendSearch;
		var CObjList xFriends;
		var int i;
		xFriendSearch.SetOwner(GetOwner());
		xFriendSearch.RegionCircle(GetPos(),GetAlarmRange()*1.1);
		var CObjList xBuildings;
		if(GetOwner()==-1 && GetType()=="ANML")then
			xFriendSearch.SetClass(GetClassName());
		else
			xFriendSearch.SetType("CHTR");
			xFriendSearch.SetType("VHCL",true);
			xFriendSearch.SetType("ANML",true);
			if(xEnemy.IsValid() && xEnemy.GetObj()^.GetType()=="SHIP")then
				xFriendSearch.SetType("SHIP",true);
			endif;
			if(GetTribeName()=="SEAS")then
				var CObjQuery xFriendBLDGSearch;
				xFriendBLDGSearch.SetOwner(GetOwner());
				xFriendBLDGSearch.RegionCircle(GetPos(),GetAlarmRange()*1.1);
				xFriendBLDGSearch.SetClass("seas_carrier");
				xFriendBLDGSearch.Exclude(GetHandle());
				xFriendBLDGSearch.Execute(xBuildings);
			endif;
		endif;
		xFriendSearch.Exclude(GetHandle());
		var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("Fight");
		xEvt.SetObjHandle(0,xEnemy);
		xEvt.SetBool(1,bDefend);


		if(xFriendSearch.Execute(xFriends) || xBuildings.NumEntries()>0)then
			xFriends.Include(xBuildings);
			var int iC = xFriends.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxFriend=cast<CFightingObj>(xFriends[i].GetObj());
				if(pxFriend==null)then continue; endif;
				if(!bDefend&&pxFriend^.GetAggressionState()==1)then continue; endif;
				if(pxFriend^.m_bIsHelpShout)then continue; endif;
				if(!pxFriend^.IsAbleToFight())then continue; endif;
				var ^CTask pxTask=pxFriend^.GetCurTask();
				if(pxTask!=null && pxTask^.IsUserCommand())then continue; endif;
				pxFriend^.HandleEvent(xEvt);
			endfor;
		endif;
		m_xLastHelpShout = xNow;
		PlayHelpSound(xEnemy.GetObj(),xFriends);

		m_bIsHelpShout=false;

		m_xHelpDefendEnemies.Clear();
		m_xHelpAttackEnemies.Clear();

	endproc;

	proc bool PlayHelpSound(^CGameObj p_pxEnemy,CObjList p_xFriends)
		if(p_pxEnemy==null)then return(false);endif;
		//Different sounds can be played depending on the combatants and helpers.

		//Somehow it doensn't work...
		//Somehow? DbgView is overflowing with error Msgs!
		// Urs.Shared.GameObj WARN :3D Sound event not found: FX_AnimalHelpCryGeneric
		//PlaySound("FX_AnimalHelpCryGeneric"); //64 Byte Traffic
		
		InvokeGenericSCEvent(25,0.1f); //3 Byte Traffic

		return(true);
	endproc;

	///////
	//	SetAttrib()
	///////
	export proc void SetAttrib(string p_sName, string p_sValue)
        if(p_sName=="hitpoints")then
			m_fHitpoints=p_sValue.ToInt().ToReal();
		elseif(p_sName=="maxhitpoints")then
			m_fMaxHitpoints=p_sValue.ToInt().ToReal();
        elseif(p_sName=="tribe")then
        	m_sTribe=p_sValue;
        elseif(p_sName=="level")then
        	m_iLevel=p_sValue.ToInt();
        else
            super.SetAttrib(p_sName,p_sValue);
        endif;
	endproc;

	///////
	//	SetMovableInFight()
	///////
	export proc void SetMovableInFight(bool p_bMove)
		m_bMovableInFight = p_bMove;
	endproc;

	///////
	//	GetMovableInFight()
	///////
	export proc bool GetMovableInFight()
		return m_bMovableInFight;
	endproc;

	///////
	//	UpdateAggressive()
	///////
	proc void UpdateAggressive()
		//-1 - friedlich
		//0 - neutral
		//1 - aggressiv
		var int iAggressiv=GetTechTreeAggressiv();
		if(iAggressiv==1)then
			if(!HasTimer(TIMER_PREAGGRO))then
				var real fJitter=0.9+Random.MTRandF(0.2); //jitter by +- 10%
				CreateTimer(TIMER_PREAGGRO, CGameTimeSpan.OneSecond() * 7.0f * fJitter, true);
			endif;
			if(GetOwner()==-1)then
				SetAggressive(true);
			endif;
		else
			SetAggressive(false);
			if(HasTimer(TIMER_PREAGGRO))then
				DeleteTimer(TIMER_PREAGGRO);
			endif;
			if(HasTimer(TIMER_AGGRO))then
				DeleteTimer(TIMER_AGGRO);
			endif;
		endif;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("anml_aggressive_type",iAggressiv);
		endif;
	endproc;

	///////
	//	ActivateAggroTimer()
	///////
	proc void ActivateAggroTimer()
		if(!HasTimer(TIMER_AGGRO))then
			var ^CCharacter pxC = cast<CCharacter>(this);
			if (pxC!=null && pxC^.GetTransportObj().IsValid() && !pxC^.IsOnOpenTransporter()) then
				return;
			endif;
			var real fJitter=0.9+Random.MTRandF(0.2);
			CreateTimer(TIMER_AGGRO, CGameTimeSpan.OneSecond()*3.0f*fJitter, true);
		endif;
	endproc;

	///////
	//	GetAggressive()
	///////
	export proc int GetAggressive()
		return GetTechTreeAggressiv();
	endproc;

	///////
	//	SetAlarmed()
	///////
	export proc void SetAlarmed(bool p_bStatus)
		SetAlarmed(p_bStatus, CObjHndl.Invalid());
	endproc;

	export proc void SetAlarmed(bool p_bStatus, CObjHndl p_xObj)
		if(GetAggressive()>=0)then
			//L CSrvWrap.LogInfo("FightingObj","SetAlarmed("+p_bStatus.ToString()+")");
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("alarmed",p_bStatus);
			endif;
			SetAlarmSign(p_bStatus);
			if(p_bStatus)then
				if(GetType()=="ANML" && GetOwner()==-1)then
					if(!IsInFight() && (m_pxTaskMgr^.GetCurTask()==null || m_pxTaskMgr^.GetCurTask()==m_pxIdleState || m_pxTaskMgr^.GetCurTask()^.GetName()=="Walk2Pos"))then
						SetThreatTask(p_xObj);
					endif;
				elseif(!HasAction() && m_pxTaskMgr^.GetCurTask()==m_pxIdleState || m_pxTaskMgr^.GetCurTask()==null)then
					SetThreatTask(p_xObj);
				endif;
//				var vec3 vOffset = {0.0,0.0,0.0};
//				vOffset.SetZ(GetSize().GetZ()+1.0);
//				var ^CSign pxNewObj = cast<CSign>(CSrvWrap.GetObjMgr()^.CreateObj("Alarm_Sign",GetOwner(),GetPos()+vOffset,GetRotation()));
//				pxNewObj^.SetCountDown(5.0, GetHandle());
				var ^CCharacter pxC = cast<CCharacter>(this);
				if (pxC!=null && pxC^.GetTransportObj().IsValid()) then
					return;
				endif;
				if(!HasTimer(TIMER_ALARM))then
					CreateTimer(TIMER_ALARM, CGameTimeSpan.OneSecond() * 10.0, false);
				endif;
			endif;
		endif;
	endproc;

	export proc void SetThreatTask(CObjHndl p_xHndl)
		if(!GetThreatAnim().IsEmpty())then
			var ^CAlarmed pxTask=cast<CAlarmed>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Alarmed"));
	    	pxTask^.Init(GetHandle(),p_xHndl);
			pxTask^.SetUserCommand(false);
			AddTask(pxTask,false);
		endif;
	endproc;

	export proc string GetThreatAnim()
		return "menace";
	endproc;

	export proc void SetInvisibleFlag(bool p_bStatus)
		m_bInvisibleFlag = p_bStatus;
	endproc;

	export proc ref bool GetInvisibleFlag()
		return m_bInvisibleFlag;
	endproc;

	///////
	//	SetProjectile()
	///////
	export proc void SetProjectile(string p_sArrow)
		m_sProjectile=p_sArrow;
		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null) then
			pxA^.SetValue("projectile", p_sArrow);
		endif;
	endproc;

	///////
	//	GetProjectile()
	///////
	export proc ref string GetProjectile()
		return m_sProjectile;
	endproc;

	export proc bool NextJob(CObjHndl p_xTarget, CObjList p_xIgnoreBuildUps)
		return false;
	endproc;


	export proc void SetRealProjectile(string p_sArrow)
		m_sRealProjectile=p_sArrow;
	endproc;


	export proc ref string GetRealProjectile()
		return m_sRealProjectile;
	endproc;


	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos)
		var string sProj = GetProjectile() + GetWeaponMgr()^.GetRightHVariationPostfix();
		return CreateProjectileAndShoot(p_pxEnemy, p_vPos, sProj);
	endproc;


	export proc ^CArrow CreateProjectileAndShoot(^CFightingObj p_pxEnemy, vec3 p_vPos, string p_sProjectileType)

		var ^CArrow pxArrow=cast<CArrow>(CSrvWrap.GetObjMgr()^.CreateObj(p_sProjectileType,GetOwner(),GetProjectileStartPos()));
		if(pxArrow!=null)then
			if(p_pxEnemy==null)then
				pxArrow^.SetAttackScape(this, p_vPos);
			else
				pxArrow^.Set(this, p_pxEnemy);
			endif;
		endif;
		var string sClassName = GetClassName();
		if(sClassName=="seas_rocketman" || sClassName=="ninigi_mortar")then
			InvokeGenericSCEvent(36,2.5f);
		endif;
		return pxArrow;
	endproc;


	export proc void CreateProjectileAndShootBuildUp(^CFightingObj p_pxEnemy, vec3 p_vPos, ^CBuildUpWeapon p_pxBuildUp)
		var string sProj = p_pxBuildUp^.GetProjectile() + GetWeaponMgr()^.GetRightHVariationPostfix();

		if(sProj.IsEmpty())then
			//L KLog.LogSpam("JaNe",GetName()+" CreateProjectileAndShootBuildUp() HILFE! Cant Create Obj Of Undefined Class!!!");
			//L KLog.LogSpam("JaNe","GetPrimaryWeapon() = "+p_pxBuildUp^.GetWeapon());
			return;
		endif;

		var ^CArrow pxArrow=cast<CArrow>(CSrvWrap.GetObjMgr()^.CreateObj(sProj,GetOwner(),p_pxBuildUp^.GetProjectileStartPos()));
		if(pxArrow!=null)then
			if(p_pxEnemy==null)then
				pxArrow^.SetAttackScape(this, p_vPos);
			else
				pxArrow^.Set(this, p_pxEnemy, p_pxBuildUp);
			endif;
		endif;
	endproc;


	export proc real GetProjectileDelay()
		return m_xCurrentFightAnim.m_fShootDelay;
		//return m_fProjectileDelay;
	endproc;

	export proc void SetProjectileDelay(real p_fDelay)
		m_fProjectileDelay = p_fDelay;
	endproc;


	export proc ref real GetProjectileFallOff()
		return m_fProjectileFallOff;
	endproc;

	export proc void SetProjectileFallOff(real p_fFallOff)
		m_fProjectileFallOff = p_fFallOff;
	endproc;


	export proc ref real GetProjectileSpeed()
		return m_fProjectileSpeed;
	endproc;

	export proc void SetProjectileSpeed(real p_fSpeed)
		m_fProjectileSpeed = p_fSpeed;
	endproc;


	export proc void SetProjectileJitter(real p_fJitter)
		m_fProjectileJitter = p_fJitter;
	endproc;

	export proc real GetProjectileJitter()
		return m_fProjectileJitter;
	endproc;


	export proc void SetPenetration(bool p_bPenetration)
		m_bPenetration = p_bPenetration;
	endproc;

	export proc void SetPenetrationAngle(real p_fPenetrationAngle)
		m_fPenetrationAngle=p_fPenetrationAngle;
	endproc;

	export proc ref bool GetPenetration()
		return m_bPenetration;
	endproc;

	export proc ref real GetPenetrationAngle()
		return m_fPenetrationAngle;
	endproc;

	export proc vec3 GetProjectileStartPos()
		var vec3 vPos;
		if(!GetLinkPosWorld(GetProjectileLink(), vPos))then
			var vec3 vSize = GetSize();
			vPos = GetPos();
			vPos.SetZ(vPos.GetZ() + vSize.GetZ()*0.7);
		endif;
		return vPos;
	endproc;

	export proc vec3 GetProjectileStartPos(int p_iIdx)
		return GetPos();
	endproc;

	export proc CFourCC GetProjectileLink()
		var CFourCC xL="Proj";
		return xL;
	endproc;

	export proc real GetProjectileFallOffCone(real p_fRange)
		return FALLOFFCONE_VAL/Math.Max(p_fRange,0.01f);
	endproc;

	export proc real GetProjectileFallOffCone()
		return FALLOFFCONE_VAL/Math.Max(GetAttackRange(),0.01f);
	endproc;

	///////
	//	ShowWeapons()
	///////
	export proc void ShowWeapons()
	endproc;

	export proc void UpdateWeaponsGfx()
	endproc;

	///////
	//	HideWeapons()
	///////
	export proc void HideWeapons()
	endproc;

	///////
	//	GetWeaponDuration()
	///////
	export proc real GetWeaponDuration()
		return m_fWeaponDuration;
		//return (m_fWeaponDuration*ms_fDurationFactor);
	endproc;

	///////
	//	SetWeaponDuration()
	///////
	export proc void SetWeaponDuration(real p_fDuration)
		m_fWeaponDuration=p_fDuration;
	endproc;

	///////
	//	GetWeaponDuration()
	///////
	export proc ref real GetHitDelay()
		return m_xCurrentFightAnim.m_fDelay;
	endproc;

	///////
	//	SetWeaponDuration()
	///////
	export proc void SetHitDelay(real p_fHitDelay)
		m_fHitDelay=p_fHitDelay;
	endproc;

	///////
	//	GetAggresionState()
	///////
	export proc int GetAggressionState()
		if(!IsAbleToFight())then
			return 1;
		endif;
		return m_iAggressionState;
	endproc;

	///////
	//	SetAggessionState()
	///////
	export proc void SetAggressionState(int p_iState)
		if(m_iAggressionState==3)then return; endif;
		m_iAggressionState = p_iState;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("AggressionState",m_iAggressionState);
		endif;
	endproc;

	///////
	//	GetMinAttackRange()
	///////
	export proc ref real GetMinAttackRange()
		return m_fMinAttackRange;
	endproc;

	export proc void SetMinAttackRange(real p_fValue)
		m_fMinAttackRange = p_fValue;
	endproc;

	export proc ref real GetRealMinAttackRange()
		return m_fRealMinAttackRange;
	endproc;

	export proc void SetRealMinAttackRange(real p_fValue)
		m_fRealMinAttackRange = p_fValue;
	endproc;


	///////
	//	GetAttackRange()
	///////
	export proc real GetAttackRange()
		var real fRad=GetRadius();
		if(GetType()=="CHTR") then
			fRad=2.0f; //RT#6302
		endif;
		if(!GetRealProjectile().IsEmpty()) then
			fRad=0.0; //long range
		endif;
		m_fRealAttackRange = m_fAttackRange+fRad;
		return (m_fRealAttackRange)+AddTemporaryRangeBoni();
	endproc;

	///////
	//	SetAttackRange()
	///////
	export proc void SetAttackRange(real p_fRange)
		m_fAttackRange=p_fRange;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("range",(m_fAttackRange+0.5).ToInt());
		endif;
		SetAlarmRange(Math.Clamp(GetAttackRange()+8.0,32.0,GetFOWRange()));
	endproc;

	export proc ref real GetSecondaryRangeM()
		var real fRad=GetRadius();
		if(GetType()=="CHTR") then
			fRad=1.5f;
		endif;
		m_fRealSecRangeM = m_fSecRangeM+fRad;
		return (m_fRealSecRangeM);
	endproc;

	export proc ref real GetSecondaryRangeS()
		var real fRad=GetRadius();
		if(GetType()=="CHTR") then
			fRad=1.5f;
		endif;
		m_fRealSecRangeS = m_fSecRangeS+fRad;
		return (m_fRealSecRangeS);
	endproc;

	export proc void SetSecondaryRangeM(real p_fRange)
		m_fSecRangeM=p_fRange;
	endproc;

	export proc void SetSecondaryRangeS(real p_fRange)
		m_fSecRangeS=p_fRange;
	endproc;


	///////
	//	SetFOWRange()
	///////
	export proc void SetFOWRange(real p_fRange)
		m_fFOWRange = p_fRange + GetBonusSum(BONUS_FOWRANGE);
		SetFOW(m_fFOWRange);
	endproc;

	///////
	//	GetFOWRange()
	///////
	export proc ref real GetFOWRange()
		return m_fFOWRange;
	endproc;

	export proc ref real GetArmorPiercing()
		return m_fArmorPiercing;
	endproc;

	export proc void SetArmorPiercing(real p_fValue)
		m_fArmorPiercing = p_fValue;
	endproc;


	export proc ref real GetAlarmRange()
		return m_fAlarmRange;
	endproc;

	export proc void PickUp(CObjHndl p_xItem,bool p_bQueue)
		if(!IsAbleToWalk())then return; endif;
		var CFourCC xType=GetType();
		if(xType!="ANML" && xType!="CHTR" && xType!="VHCL")then return; endif;
		var ^CPickUp pxTask=cast<CPickUp>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"PickUp"));
    	pxTask^.Init(GetHandle(),p_xItem);
		pxTask^.SetUserCommand(true);
    	AddTask(pxTask,p_bQueue);
	endproc;


	export proc void DropItem(CGuid p_xGuid, vec3 p_vDropPos,bool p_bQueue)
		var ^CDropItem pxTask=cast<CDropItem>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"DropItem"));
    	pxTask^.Init(GetHandle(),p_xGuid, p_vDropPos);
		pxTask^.SetUserCommand(true);
    	AddTask(pxTask,p_bQueue);
    	CFeedback.Print(GetOwner(), CFeedback.INFO, "_NT_ItemDropped\t"+GetTechTreeDesc());
	endproc;

	export proc void UseItem(^CGameObj p_pxObject)
		if (p_pxObject != null) then
			var ^CInventory pxInv = GetInventory();
			if (pxInv == null) then return; endif;

			var int i, iC = pxInv^.Count();
			for(i=0) cond(i<iC) iter(++i) do
				if (pxInv^.GetItem(i) == p_pxObject^.GetHandle()) then
					(cast<CItem>(p_pxObject))^.OnUsed(this);
					break;
				endif;
			endfor;
		endif;
	endproc;

	///////
	//	SetAlarmRange()
	///////
	export proc void SetAlarmRange(real p_fRange)
		m_fAlarmRange=p_fRange;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("alarm_range",(GetAlarmRange()+0.5).ToInt());
		endif;
	endproc;

	export proc bool InitFinishingMove(^CGameObj p_pxFighter, ^CGameObj p_pxEnemy);
		var string sClass = p_pxFighter^.GetClassName();
		var string sEnemyClass = p_pxEnemy^.GetClassName();

		if(m_iFinishingMoveIdx==-1)then return false; endif;
		if(m_bDoingFinishingMove)then return false; endif;
		if(m_xLastFinishingVictim==m_xCurEnemy)then return false; endif;

		var ^CFinishingMoveMgr.CMoveDef pxMove=CFinishingMoveMgr.Get().FindMove(m_iFinishingMoveIdx,p_pxEnemy);
		if(pxMove==null)then
			return false;
		endif;

   		var ^CFinishingMove pxTask= cast<CFinishingMove>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(), "Finish"));
   		var bool bReturn = pxTask^.Init(GetHandle(),m_xCurEnemy,pxMove^);
		if(bReturn)then
			pxTask^.SetUserCommand(true);
			SetTaskImmediate(pxTask);
			m_xLastFinishingVictim = m_xCurEnemy;
		else
			GetFSM()^.FreeStateDelayed(pxTask);
		endif;
		return bReturn;
	endproc;

	///////
	//	GetNextFightAnim()
	///////
	export proc string GetNextFightAnim()

		if(m_asFightAnims.NumEntries()>0)then
			var string sFollow = m_xCurrentFightAnim.m_sFollowAnim;

			if(sFollow!="")then
				var int i, iC = m_axFightAnims.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					if(m_axFightAnims[i].m_sAnim == sFollow)then
						m_xCurrentFightAnim = m_axFightAnims[i];
						break;
					endif;
				endfor;
			else
				var int iCount = m_axFightAnims.NumEntries();
				var int iRandom;
				repeat
					iRandom = Random.GetInt()%iCount;
				until(!m_axFightAnims[iRandom].m_bIsComboAnim)endrepeat;

				m_xCurrentFightAnim = m_axFightAnims[iRandom];
			endif;

		else
			m_xCurrentFightAnim.Clear();
		endif;
		return GetFightAnim();
	endproc;

	export proc string GetFightAnim()
		return m_xCurrentFightAnim.m_sAnim;
	endproc;

	export proc ref real GetProjectileOn()
		return m_xCurrentFightAnim.m_fProjectileTimeOutStart;
	endproc;

	export proc ref real GetProjectileOff()
		return m_xCurrentFightAnim.m_fProjectileTimeOutEnd;
	endproc;

	export proc void SetProjectileOnTimer()
		var real fTimeOut = GetProjectileOn();
		if(fTimeOut>0.0)then
			m_pxTimeOnTick^.SetTimer(fTimeOut);
		endif;
	endproc;

	export proc void SetProjectileOffTimer()
		var real fTimeOut = GetProjectileOff();
		if(fTimeOut>0.0)then
			m_pxTimeOffTick^.SetTimer(fTimeOut);
		endif;
	endproc;

	export proc void ProjectileOn()
		if(GetProjectile().IsEmpty())then return; endif;
		var CFourCC xLink=GetProjectileLink();
		var vec3 vP;
		if(GetLinkPosObj(xLink, vP))then
			SetLinkGFX(xLink,GetProjectile()+GetWeaponMgr()^.GetRightHVariationPostfix());
		endif;
	endproc;

	export proc void ProjectileOff()
		if(GetProjectile().IsEmpty())then return; endif;
		var CFourCC xLink=GetProjectileLink();
		var vec3 vP;
		if(GetLinkPosObj(xLink, vP))then
			RemLinkGFX(xLink);
		endif;
	endproc;

	///////
	//	SetFightAnim()
	///////
	export proc void SetFightAnim(ref CFightingObj.CFightAnim p_rxAnim)
		ClearFightAnims();
		AddFightAnim(p_rxAnim);
	endproc;

	export proc void ClearFightAnims()
		m_asFightAnims = 0;
		m_axFightAnims = 0;
		m_xCurrentFightAnim.Clear();
	endproc;

	///////
	//	AddFightAnim()
	///////
	export proc void AddFightAnim(string p_sAnim)
		m_asFightAnims.AddEntry(p_sAnim);
	endproc;

	export proc void AddFightAnim(ref CFightingObj.CFightAnim p_rxAnim)
		m_asFightAnims.AddEntry(p_rxAnim.m_sAnim);
		m_axFightAnims.AddEntry(p_rxAnim);
		m_xCurrentFightAnim = p_rxAnim;
	endproc;

	export proc void UpdateTechTree()
	endproc;

	///////
	//	UpdateEquipment()
	///////
	export proc void UpdateEquipment()
		var string sWeapon = GetRightHandWeapon();
		var string sWeaponM = GetSecondaryWeaponM();
		var string sWeaponS = GetSecondaryWeaponS();
		UpdateWeapons(sWeapon);
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		if(pxAttr^.GetValue("Equip_Slot_0")!=sWeapon)then
			pxAttr^.SetValue("Equip_Slot_0",sWeapon);
		endif;
		if(pxAttr^.GetValue("Equip_Slot_1")!=sWeaponM)then
			pxAttr^.SetValue("Equip_Slot_1",sWeaponM);
		endif;
		if(pxAttr^.GetValue("Equip_Slot_2")!=sWeaponS)then
			pxAttr^.SetValue("Equip_Slot_2",sWeaponS);
		endif;
		m_bWeaponHasChanged = true;
		m_bOwnWeaponHasChanged = true;
	endproc;

	export proc bool WeaponHasChanged()
		if(m_bWeaponHasChanged)then
			m_bWeaponHasChanged = false;
			return true;
		endif;
		return false;
	endproc;

	export proc bool OwnWeaponHasChanged()
		if(m_bOwnWeaponHasChanged)then
			m_bOwnWeaponHasChanged = false;
			return true;
		endif;
		return false;
	endproc;

	export proc void UpdateWeapons(string p_sPrimaryWeapon)

		var bool bWeaponChanged = p_sPrimaryWeapon!=m_sCurrentWeapon;

		var int i, iC = m_axWeaponCaches.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj.CWeaponCache pxCache = ^(m_axWeaponCaches[i]);
			if(pxCache^.m_sWeaponPath == p_sPrimaryWeapon)then
				ReloadWeaponCache(pxCache);
				if(bWeaponChanged)then
					UpdateWeaponsGfx();
				endif;
				return;
			endif;
		endfor;

		m_sCurrentWeapon = p_sPrimaryWeapon;

		if(bWeaponChanged)then
			UpdateWeaponsGfx();
		endif;

		var ^CTechTree.CNode pxNode = m_xTechTree.FindNode(p_sPrimaryWeapon);
		if (pxNode==null) then return; endif;

		var ^CAttribs pxAttr = GetAttribs();
		ClearFightAnims();
		SetProjectile("");

		SetWeaponDuration(0.5);

		var real fDmg = 0.0f;
		var real fMinDmg = 0.0f;
		var real fProtect = 0.0f;
		var real fRangedProtect = 0.0f;
		var real fEndDmg = 0.0f;
		var real fHitrange = 0.0f;
		var real fAttackRange = 0.0f;
		var real fPoisonDmg = 0.0;
		var int iPoisonMaxTickCount = 0;
		var bool bPenetration = false;
		var bool bProjectile = false;
		var real fPenetrationAngle = 0.0;
		var real fMinAttackRange = 0.0;
		var real fArmorPiercing = 0.0;
		var int iWeaponSizeClass=0;

		var array ^CTechTree.CNode apxNodes;

		if(pxAttr!=null)then
			var int iNumProjectiles;

			iWeaponSizeClass=pxNode^.GetSubValueI("unit_size",0);

			var ^CTechTree.CNode pxProjectiles = pxNode^.GetSub("Projectile");
			if (pxProjectiles!=null) then
				iNumProjectiles = pxProjectiles^.NumSubs();
				if(iNumProjectiles > 0)then
					bProjectile = true;
					SetProjectile(pxProjectiles^.GetSubValue("0"));
					SetProjectileFallOff(pxNode^.GetSubValueF("bulletfalloff"));
					SetProjectileSpeed(pxNode^.GetSubValueF("bulletspeed"));
					SetProjectileJitter(pxNode^.GetSubValueF("jitter"));
					if(p_sPrimaryWeapon==GetRightHandWeapon())then
						SetRealProjectile(GetProjectile());
					endif;
				endif;
			endif;

			apxNodes.AddEntry(pxNode);

			var real fFrequency = pxNode^.GetSubValueF("frequency");
			if(fFrequency==0.0)then
				fFrequency = 1.0;
			endif;
			var real fDuration = (60.0/fFrequency);
			fDuration *= GetTechTreeModifier("WeaponDuration",true);
			fDuration += GetTechTreeModifier("WeaponDuration",false);
			fDuration *= GetAICheatModifier();
			SetWeaponDuration(fDuration);

			var ^CTechTree.CNode pxAnims = pxNode^.GetSub("Animations");
			if (pxAnims!=null) then
				var int i, iC = pxAnims^.NumSubs();
				for(i=0) cond(i<iC) iter(++i) do
					var ^CTechTree.CNode pxCurAnim = pxAnims^.GetSub(i);
					if (pxCurAnim!=null) then
						var CFightingObj.CFightAnim xAnim;
						xAnim.m_sAnim = pxCurAnim^.GetValue();
						xAnim.m_fDelay = pxCurAnim^.GetSubValueF("delay");
						xAnim.m_sFollowAnim = pxCurAnim^.GetSubValue("followanim");
						xAnim.m_bIsComboAnim = pxCurAnim^.GetSubValueB("combo");
						xAnim.m_fShootDelay = pxCurAnim^.GetSubValueF("shootdelay");
						xAnim.m_fProjectileTimeOutStart = pxCurAnim^.GetSubValueF("projectile_on",-1.0);
						xAnim.m_fProjectileTimeOutEnd = pxCurAnim^.GetSubValueF("projectile_off",-1.0);
						AddFightAnim(xAnim);
					endif;
				endfor;
			endif;

			var string sLH = GetLeftHandWeapon();
			var string sAr = GetArmor();
			apxNodes.AddEntry(m_xTechTree.FindNode(sLH));
			apxNodes.AddEntry(m_xTechTree.FindNode(sAr));

			var int i, iC		 = apxNodes.NumEntries();
			for (i=0) cond(i<iC) iter(++i) do
				var ^CTechTree.CNode pxCur = apxNodes[i];
				fDmg 			+= pxCur^.GetSubValueF("damage");
				fMinDmg			+= pxCur^.GetSubValueF("mindamage");
				fProtect		+= pxCur^.GetSubValueF("defense");
				fRangedProtect	+= pxCur^.GetSubValueF("rangeddefense");
				fEndDmg			+= pxCur^.GetSubValueF("enddamage");
				fPoisonDmg		+= pxCur^.GetSubValueF("poison_damage");

				fArmorPiercing		= Math.Max(fArmorPiercing, pxCur^.GetSubValueF("armorpiercing"));

				fMinAttackRange		= Math.Max(fMinAttackRange, pxCur^.GetSubValueF("minattackrange"));

				fHitrange			= Math.Max(fHitrange, pxCur^.GetSubValueF("hitrange"));
				fAttackRange		= Math.Max(fAttackRange, pxCur^.GetSubValueF("range"));
				iPoisonMaxTickCount	= Math.Max(iPoisonMaxTickCount, pxCur^.GetSubValueI("poison_tick_count"));

				bPenetration	= bPenetration || pxCur^.GetSubValue("penetration")=="1";
				fPenetrationAngle	= Math.Max(fPenetrationAngle, pxCur^.GetSubValueF("penetration_angle"));
			endfor;

			if(bProjectile)then
				fDmg *= GetTechTreeModifier("ranged_damage",true);
				fDmg += GetTechTreeModifier("ranged_damage",false);
			endif;

			SetDmg(fDmg * GetTechTreeModifier("Damage",true) + GetTechTreeModifier("Damage",false));
			SetMinDmg(fMinDmg);
			SetProtection(Math.Clamp(fProtect * GetTechTreeModifier("Defence",true) + GetTechTreeModifier("Defence",false), 0.0f, 99.0f));
			SetRangedProtection(Math.Clamp(fRangedProtect * GetTechTreeModifier("RangedDefence",true) + GetTechTreeModifier("RangedDefence",false), 0.0f, 99.0f));
			SetArmorPiercing(fArmorPiercing);
			SetMinAttackRange(fMinAttackRange);
			SetPenetration(bPenetration);
			SetPenetrationAngle(fPenetrationAngle);
			SetHitRange(fHitrange);
			SetEndDmg(fEndDmg);
			SetPoisonDmg(fPoisonDmg);
			SetPoisonMaxTickCount(iPoisonMaxTickCount);
			SetWeaponSizeClass(iWeaponSizeClass);
			if(p_sPrimaryWeapon==GetRightHandWeapon()) then
				SetAttackRange(fAttackRange * GetTechTreeModifier("Range",true) + GetTechTreeModifier("Range",false));
				SetRealMinAttackRange(fMinAttackRange);
				SetRealHitRange(fHitrange);
			endif;
		endif;
		UpdateWeaponBoni();
		AddWeaponCache();
	endproc;
	
	proc real GetAICheatModifier()
		var real fValue=1.0;
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return fValue; endif;
		var ^CAiPlayer pxPlayer = cast<CAiPlayer>(pxLevel^.GetPlayer(GetOwner()));
		if(pxPlayer==null)then return fValue; endif;
		var ^CLevelInfo.CPlayerSlot pxPlayerSlot=pxPlayer^.GetPlayerSlot();
		if(pxPlayerSlot==null)then return fValue; endif;
		var int iDiff=pxPlayerSlot^.GetValueInt("Difficulty");
		if(iDiff>=9)then
			fValue=0.9;
		elseif(iDiff>=8)then
			fValue=0.95;
		endif;
		return fValue;
	endproc;

	proc void ClearWeaponCache()
		m_axWeaponCaches = 0;
	endproc;

	proc void AddWeaponCache()
		var ^CFightingObj.CWeaponCache pxWeapon = ^(m_axWeaponCaches.NewEntryRef());

		pxWeapon^.m_sWeaponPath = m_sCurrentWeapon;
		pxWeapon^.m_iWeaponSizeClass = m_iWeaponSizeClass;
		pxWeapon^.m_sProjectile = m_sProjectile;
		pxWeapon^.m_fProjectileFallOff = m_fProjectileFallOff;
		pxWeapon^.m_fProjectileSpeed = m_fProjectileSpeed;
		pxWeapon^.m_fProjectileJitter = m_fProjectileJitter;
		pxWeapon^.m_fWeaponDuration = m_fWeaponDuration;
		pxWeapon^.m_axAnims = m_axFightAnims;

		pxWeapon^.m_fDmg = m_fDamage;
		pxWeapon^.m_fProtection = m_fProtection;
		pxWeapon^.m_fRangedProtection = m_fRangedProtection;
		pxWeapon^.m_fArmorPiercing = m_fArmorPiercing;
		pxWeapon^.m_fMinAttackRange = m_fMinAttackRange;
		pxWeapon^.m_bPenetration = m_bPenetration;
		pxWeapon^.m_fPenetrationAngle = m_fPenetrationAngle;
		pxWeapon^.m_fHitRange = m_fHitRange;
		pxWeapon^.m_fEndDmg = m_fEndDmg;
		pxWeapon^.m_fPoisonDmg = m_fPoisonDmg;
		pxWeapon^.m_iPoisonMaxTickCount = m_iPoisonMaxTickCount;;
		pxWeapon^.m_fAttackRange = m_fAttackRange;
		pxWeapon^.m_xAttackBoni = m_xAttackBoni;
		pxWeapon^.m_xDefenseBoni = m_xDefenseBoni;

	endproc;

	proc void ReloadWeaponCache(^CFightingObj.CWeaponCache p_pxWeapon)

		m_sCurrentWeapon = p_pxWeapon^.m_sWeaponPath;
		m_iWeaponSizeClass = p_pxWeapon^.m_iWeaponSizeClass;
		m_sProjectile = p_pxWeapon^.m_sProjectile;
		m_fProjectileFallOff = p_pxWeapon^.m_fProjectileFallOff;
		m_fProjectileSpeed = p_pxWeapon^.m_fProjectileSpeed;
		m_fProjectileJitter = p_pxWeapon^.m_fProjectileJitter;
		m_fWeaponDuration = p_pxWeapon^.m_fWeaponDuration;

/*		ClearFightAnims();
		var int i, iC = p_pxWeapon^.m_axAnims.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			AddFightAnim(p_pxWeapon^.m_axAnims[i]);
		endfor;
*/
		m_axFightAnims = p_pxWeapon^.m_axAnims;

		SetDmg(p_pxWeapon^.m_fDmg);
		SetProtection(p_pxWeapon^.m_fProtection);
		SetRangedProtection(p_pxWeapon^.m_fRangedProtection);
		m_fArmorPiercing = p_pxWeapon^.m_fArmorPiercing;
		m_fMinAttackRange = p_pxWeapon^.m_fMinAttackRange;
		m_bPenetration = p_pxWeapon^.m_bPenetration;
		m_fPenetrationAngle = p_pxWeapon^.m_fPenetrationAngle;
		m_fHitRange = p_pxWeapon^.m_fHitRange;
		m_fEndDmg = p_pxWeapon^.m_fEndDmg;
		m_fPoisonDmg = p_pxWeapon^.m_fPoisonDmg;
		m_iPoisonMaxTickCount = p_pxWeapon^.m_iPoisonMaxTickCount;
		m_fAttackRange = p_pxWeapon^.m_fAttackRange;
		m_xAttackBoni = p_pxWeapon^.m_xAttackBoni;
		m_xDefenseBoni = p_pxWeapon^.m_xDefenseBoni;

	endproc;

	///////
	//	UpdateSizeClass()
	///////
	proc void UpdateSizeClass()
		m_iSizeClass=m_xTechTree.GetValueI(GetObjPath()+"/unit_size",0);
	endproc;


	///////
	//	UpdateSpeed()
	///////
	proc void UpdateSpeed()
		var int iOldMaxSpeed=GetMaxSpeed();
		var int iNewMaxSpeed=m_xTechTree.GetValueI(GetObjPath()+"/maxspeed",2);
		SetDefaultSpeed(m_xTechTree.GetValueI(GetObjPath()+"/defaultspeed",2));
		SetMaxSpeed(iNewMaxSpeed);
		if(iNewMaxSpeed!=iOldMaxSpeed)then
			if(HasWalkAction())then
				TerminateAction();
			endif;
		endif;

	endproc;

	///////
	//	GetDefaultSpeed()
	///////
	export proc int GetDefaultSpeed()
		//KLog.LogSpam("TechTree","GetDefaultSpeed() defaultspeed="+m_iDefaultSpeed.ToString());
		return Math.Clamp(m_iDefaultSpeed.ToReal() + GetBonusSum(CFightingObj.BONUS_DEFAULTSPEED), 1.0f, GetMaxSpeed().ToReal()).ToInt();
	endproc;

	///////
	//	SetDefaultSpeed()
	///////
	export proc void SetDefaultSpeed(int p_iSpeed)
		m_iDefaultSpeed = p_iSpeed;
	endproc;

	///////
	//	GetMaxSpeed()
	///////
	export proc int GetMaxSpeed()
		//L KLog.LogSpam("TechTree","GetMaxSpeed() maxspeed="+m_iMaxSpeed.ToString());
		return m_iMaxSpeed;
	endproc;

	///////
	//	SetMaxSpeed()
	///////
	export proc void SetMaxSpeed(int p_iSpeed)
		m_iMaxSpeed = p_iSpeed;
	endproc;

	///////
	//	GetLeftHandWeapon()
	///////
	export proc string GetLeftHandWeapon()
		return m_pxWeaponMgr^.GetLeftHandWeapon();
	endproc;

	///////
	//	GetRightHandWeapon()
	///////
	export proc string GetRightHandWeapon()
		//return m_sRightHandWeapon;
		return m_pxWeaponMgr^.GetRightHandWeapon();
	endproc;

	export proc string GetCurrentWeapon()
		return m_sCurrentWeapon;
	endproc;

	export proc string GetSecondaryWeaponM()
		//return m_sSecondaryWeaponM;
		return m_pxWeaponMgr^.GetSecondaryWeaponM();
	endproc;

	export proc string GetSecondaryWeaponS()
		//return m_sSecondaryWeaponS;
		return m_pxWeaponMgr^.GetSecondaryWeaponS();
	endproc;

	///////
	//	GetArmor()
	///////
	export proc string GetArmor()
		//return m_sArmor;
		return m_pxWeaponMgr^.GetArmor();
	endproc;

	///////
	//	UpdateWepaonBoni()
	///////
	export proc void UpdateWeaponBoni()

		m_xAttackBoni.Clear();
		m_xDefenseBoni.Clear();

		AddBoni(GetCurrentWeapon()+"/AttackBonus",m_xAttackBoni);
		AddBoni(GetLeftHandWeapon()+"/AttackBonus",m_xAttackBoni);
		AddBoni(GetArmor()+"/AttackBonus",m_xAttackBoni);

		AddBoni(GetCurrentWeapon()+"/DefenseBonus",m_xDefenseBoni);
		AddBoni(GetLeftHandWeapon()+"/DefenseBonus",m_xDefenseBoni);
		AddBoni(GetArmor()+"/DefenseBonus",m_xDefenseBoni);

		if (GetEffectFlag(EFFECT_ITEM_AMULETT1)) then
			m_xDefenseBoni.AddBonus("Type", "ANML", 15.0f);
		endif;
		ClearDamageCache();
	endproc;

	///////
	//	AddBoni()
	///////
	export proc void AddBoni(string p_sPath, ref CBonus p_rxBonus)

		var int i;

		for(i=0)cond(i<m_xTechTree.NumSubs(p_sPath+"/Type"))iter(i++)do

			var string sPath = m_xTechTree.GetSubAbsPath(p_sPath+"/Type",i);
			var real fBonus = m_xTechTree.GetValueR(sPath,0.0);
			sPath = sPath.Mid(sPath.FindRev('/')+1);
			//L KLog.LogSpam("TechTree","AddBoni: sPath = "+sPath);
			p_rxBonus.AddBonus("Type",sPath, fBonus);

		endfor;

		for(i=0)cond(i<m_xTechTree.NumSubs(p_sPath+"/Class"))iter(i++)do

			var string sPath = m_xTechTree.GetSubAbsPath(p_sPath+"/Class",i);
			var real fBonus = m_xTechTree.GetValueR(sPath,0.0);
			sPath = sPath.Mid(sPath.FindRev('/')+1);
			//L KLog.LogSpam("TechTree","AddBoni: sPath = "+sPath);
			p_rxBonus.AddBonus("Class",sPath, fBonus);

		endfor;

	endproc;

	///////
	//	GetAttackBoni()
	///////
	export proc ref CBonus GetAttackBoni()
		return m_xAttackBoni;
	endproc;

	///////
	//	AddTemporaryAttackBoni()
	///////
	export proc real CalcAttackBoni(real p_fDamage)
		var real fValue = p_fDamage;

		if (GetTribeName() == "Aje") then
			//relative values

			//absolut values
		elseif (GetTribeName()=="Hu") then
			//relative values

			//absolut values
		elseif (GetTribeName()=="Ninigi") then
			//relative values

			//absolut values

		endif;
		
		if(GetEffectFlag(EFFECT_MAMMOTH_TRUMPET))then
			fValue *= 0.8;
		endif;
		if(GetEffectFlag(EFFECT_TRICERATOPS_PAW))then
			fValue *= 0.8;
		endif;
		if(GetEffectFlag(EFFECT_CHTR_WARCRY_5))then
			fValue *= 1.2;
		elseif(GetEffectFlag(EFFECT_CHTR_WARCRY_4))then
			fValue *= 1.15;
		elseif(GetEffectFlag(EFFECT_CHTR_WARCRY_3))then
			fValue *= 1.1;
		endif;
		if(GetEffectFlag(EFFECT_AJE_WARPAINT_5))then
			fValue *= 0.8;
		elseif(GetEffectFlag(EFFECT_AJE_WARPAINT_4))then
			fValue *= 0.85;
		elseif(GetEffectFlag(EFFECT_AJE_WARPAINT_3))then
			fValue *= 0.9;
		endif;
		if(GetEffectFlag(EFFECT_WILDBOAR_RAGE))then
			fValue *= 1.15;
		endif;
		if(GetEffectFlag(EFFECT_MEGALO_DRUMS))then
			fValue *= 1.2;
		endif;
		if(GetEffectFlag(EFFECT_NINIGI_CAULDRON))then
			fValue *= 1.25;
		endif;
		fValue += GetBonusSum(BONUS_DAMAGE);

		return fValue;
	endproc

	export proc real AddTemporaryAttackBoni(real p_fDamage)
		var real fValue = CalcAttackBoni(p_fDamage);

		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			var int iValue;
			if(fValue<p_fDamage)then
				iValue = Math.Floor(fValue-p_fDamage).ToInt();
			else
				iValue = Math.Ceil(fValue-p_fDamage).ToInt();
			endif;

			pxAttr^.SetValue("TmpAttackBoni",iValue);

		endif;

		RemoveRangedBuff("more_damage");
		RemoveRangedBuff("less_damage");
		if(fValue>p_fDamage)then
			AddRangedBuff("more_damage");
		elseif(fValue<p_fDamage)then
			AddRangedBuff("less_damage");
		endif;

		return fValue;
	endproc;

	///////
	//	AddTemporaryDefenseBoni()
	///////
	export proc real AddTemporaryDefenseBoni(real p_fProtection)

		var real fValue = p_fProtection;

		if (GetTribeName()=="Aje") then
			// nix :(
		else
			if(GetEffectFlag(EFFECT_RHINO_PENNANT))then
				fValue += 20.0;
			endif;
		endif;

		fValue += GetBonusSum(BONUS_DEFENSE);

		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			var int iValue;
			if(fValue<p_fProtection)then
				iValue = Math.Floor(fValue-p_fProtection).ToInt();
			else
				iValue = Math.Ceil(fValue-p_fProtection).ToInt();
			endif;

			pxAttr^.SetValue("TmpDefenseBoni",iValue);
		endif;

		RemoveRangedBuff("more_defense");
		RemoveRangedBuff("less_defense");
		if(fValue>p_fProtection)then
			AddRangedBuff("more_defense");
		elseif(fValue<p_fProtection)then
			AddRangedBuff("less_defense");
		endif;

		return fValue;
	endproc;

	export proc real AddTemporaryRangeBoni()
		var real fVal = GetBonusSum(BONUS_RANGE);

		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null) then
			if(pxA^.GetValueInt("TmpRangeBoni")!=fVal.ToInt())then
				pxA^.SetValue("TmpRangeBoni",fVal.ToInt());
			endif;
		endif;

		RemoveRangedBuff("more_range");
		RemoveRangedBuff("less_range");
		if(fVal>0.0)then
			AddRangedBuff("more_range");
		elseif(fVal<0.0)then
			AddRangedBuff("less_range");
		endif;

		return fVal;
	endproc;

	export proc real AddTemporaryRangedDefenseBoni(real p_fProtection)

		var real fValue = p_fProtection;

		fValue += GetBonusSum(BONUS_RANGEDDEFENSE);

		// add wall defense bonus
		if(GetOnWall())then
			fValue += m_xTechTree.GetValueR("MiscValues/"+GetPlayerTribeName()+"/Defence_On_Wall",0.0);
		endif;

		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			var int iValue;
			if(fValue<p_fProtection)then
				iValue = Math.Floor(fValue-p_fProtection).ToInt();
			else
				iValue = Math.Ceil(fValue-p_fProtection).ToInt();
			endif;

			pxAttr^.SetValue("TmpRangedDefenseBoni",iValue);
		endif;

		return fValue;
	endproc;

	///////
	//	GetDefenseBoni()
	///////
	export proc ref CBonus GetDefenseBoni()
		return m_xDefenseBoni;
	endproc;

	///////
	//	GetObjPath()
	///////
	export proc string GetObjPath()
		return m_sObjPath;
	endproc;

	///////
	//	UpdateObjPath()
	///////
	proc void UpdateObjPath()
		var string sTribe=GetTribeName();
		if(sTribe.IsEmpty())then return; endif;
		var string sClassName=GetClassName();
		var ^CTechTree.CNode pxObjNode=m_xTechTree.FindNode("Objects/"+sTribe+"/"+GetType().AsString()+"/"+sClassName);
		if(pxObjNode==null)then
			var ^CTechTree.CNode pxTribeNode=m_xTechTree.FindNode("Objects/"+sTribe);
			if(pxTribeNode==null) then return; endif;
			pxObjNode=pxTribeNode^.FindNodeRecursiveByName(sClassName);
		endif;
		if(pxObjNode==null) then return; endif;
		m_sObjPath=pxObjNode^.GetAbsPath();
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("ObjPath",m_sObjPath);
		endif;
		//KLog.LogWarn("CHP","ObjPath: "+m_sObjPath);
	endproc;

	///////
	//	OnTechTreeChange()
	///////
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
//		CSrvWrap.LogInfo("CaOr",GetName()+"::OnTechTreeChange(ref CTechTreeMgr.TTTFilterList)");

		m_xTechTree = GetTechTree();

		ExamineFlags();

		if(!m_bTechTreeInitialized)then
			UpdateObjPath();
		endif;

		if(!m_sObjPath.IsEmpty()) then
			m_bTechTreeInitialized=true;
		endif;

		var string sTribe = GetTribeName();
		if(sTribe.IsEmpty())then return;endif;

		var string sAllWeaponPath = "/Objects/"+sTribe+"/Weapons/";
		var string sObjPath="/"+GetObjPath();
		var string sInventObjPath="/Objects/"+sTribe+"/InventObjects/";
		var string sModPath= "/Modifications/" + sTribe + "/" + GetType().AsString();
		var string sModClassPath= "/Modifications/" + sTribe + "/" + GetClassName();

		var int i,iC;
		var bool bWeaponChanged = false;

		var int iOps=0;

		var bool bUpdate_Mods=false;
		var bool bUpdate_HP=false;
		var bool bUpdate_Gfx=false;
		var bool bUpdate_FOW=false;
		var bool bUpdate_Boni=false;
		var bool bUpdate_Attribs=false;
		var bool bUpdateRageUnit=false;
		var bool bSpecialAbilities=false;

		for(i=0) cond(i<p_rasChanges.NumEntries()) iter(i++) do
			var string sVal=p_rasChanges[i];
			//CSrvWrap.LogError("FightingObj",i.ToString()+":"+sVal);
			if(sVal.Find("/ForceWeaponUpdate")!=-1)then
				bWeaponChanged = true;
				bUpdateRageUnit = true;
				bSpecialAbilities = true;
			elseif(!bWeaponChanged && sVal.Find(sAllWeaponPath)!=-1)then
				var string sTmp=sVal;
				sTmp.Replace(sAllWeaponPath,"");
				sTmp=sTmp.Left(sTmp.Find("/"));
				sTmp=sAllWeaponPath+sTmp;
				var ^CTechTree.CNode pxWeapon=m_xTechTree.FindNode(sTmp);
				if(pxWeapon==null)then continue; endif;
				var ^CTechTree.CNode pxUsers=pxWeapon^.GetSub("Users");
				if(pxUsers==null)then continue; endif;
				if(pxUsers^.FindNodeRecursiveByValue(GetClassName())==null)then continue; endif;
				bWeaponChanged = true;
			elseif((sModPath.Find(sVal)!=-1)||(sVal.Find(sModPath)!=-1) || (sModClassPath.Find(sVal)!=-1)||(sVal.Find(sModClassPath)!=-1)) then
				bWeaponChanged = true;
				bUpdate_HP=true;
				bUpdate_FOW=true;
				bUpdate_Mods=true;
			elseif((sVal.Find(sObjPath)!=-1)||(sObjPath.Find(sVal)!=-1)) then
				bUpdate_Attribs=true;
				bUpdate_Mods=true;
				bUpdate_Gfx=true;
				bUpdate_FOW=true;
				bUpdate_HP=true;
				if(sVal.Find("special_abilities")!=1)then
					bSpecialAbilities=true;
				endif;
				// copied from TransportObj.usl
				var ^CTechTree.CNode pxFlags=m_xTechTree.FindNode(GetObjPath()+"/flags");

				if(pxFlags!=null)then
					var int i,iC=pxFlags^.NumSubs();
					var ^CAttribs pxAttr = GetAttribs();
					if(pxAttr!=null)then
						if(iC>0)then
							if(pxFlags^.GetSub(0)!=null) then
								pxAttr^.SetValue("ObjFlag",pxFlags^.GetSub(0)^.GetName());
								if(GetProduceUnit().IsValid())then
									var ^CAttribs pxAttr=GetProduceUnit().GetObj()^.GetAttribs();
									if(pxAttr!=null)then
										pxAttr^.SetValue("ObjFlag",pxFlags^.GetSub(0)^.GetName());
									endif;
								endif;
							endif;
						else
							pxAttr^.SetValue("ObjFlag","");
						endif;
					endif;
				endif;

				if(sVal.Right(6)=="_bonus") then
					var int iIdx = sVal.FindRev('/');
					if(iIdx>=0) then
						var int iVal = m_xTechTree.GetValueI(sVal, -1);

						var string sBonus = sVal.Mid(iIdx+1);
						sBonus.Replace("_bonus","");
						var ^CBoniBucket pxBB = null;

						if(sBonus.Find("bldgdamage")>=0) then
							pxBB = GetBoniBucket(CFightingObj.BONUS_DAMAGE_BLDG);
						elseif(sBonus.Find("damage")>=0) then
							pxBB = GetBoniBucket(CFightingObj.BONUS_DAMAGE);
						elseif(sBonus.Find("rangeddefense")>=0) then
							pxBB = GetBoniBucket(CFightingObj.BONUS_RANGEDDEFENSE);
						elseif(sBonus.Find("defense")>=0) then
							pxBB = GetBoniBucket(CFightingObj.BONUS_DEFENSE);
						elseif(sBonus.Find("range")>=0) then
							pxBB = GetBoniBucket(CFightingObj.BONUS_RANGE);
						endif;
						if(pxBB!=null) then
							if(iVal>0) then
								pxBB^.AddEntry(sBonus, iVal.ToReal());
							else
								pxBB^.RemEntry(sBonus);
							endif;
							bUpdate_Boni=true;
						endif;
					endif;
				endif;
			elseif((sInventObjPath.Find(sVal)!=-1)||(sVal.Find(sInventObjPath)!=-1))then
				bUpdate_Gfx=true;
			endif;
			if((sVal.Find("wild_boar_rage")!=1) || (sVal.Find("infantry_rage")!=1))then
				bUpdateRageUnit=true;
			endif;
		endfor;

		if(bUpdate_HP)then
			iOps++;
			ChangeMaxHitpoints(GetTechTreeHitpoints());
			var ^CAttribs pxAttr=GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("skulls",GetScalpValue());
			endif;
		endif;
		if(bUpdate_Attribs)then
			iOps++;
			UpdateSpeed();
			UpdateAggressive();
			UpdateSizeClass();
		endif;
		if(bUpdate_Mods)then
			iOps++;
			UpdateMods();
		endif;
		if(bUpdate_Gfx)then
			iOps++;
			UpdateGfx();
			UpdateGfxFlags();
		endif;
		if(bUpdate_FOW)then
			iOps++;
			UpdateFOW();
		endif;
		if(bUpdate_Boni)then
			iOps++;
			ForceBoniUpdate();
			UpdateWeaponBoni();
			UpdateRangeNDamageInformation();
		endif;
		if(bWeaponChanged)then
			iOps++;
			ClearWeaponCache();
			GetBestWeapon(null, true);
			UpdateWeaponBoni();
			UpdateRangeNDamageInformation();
			AddTemporaryAttackBoni(GetDmg());
			AddTemporaryDefenseBoni(GetProtection());
			AddTemporaryRangedDefenseBoni(GetRangedProtection());
			UpdateWeaponsGfx();
		endif;
		if(bUpdateRageUnit)then
			UpdateRageUnit();
		endif;

		if(bWeaponChanged || bUpdate_Boni || bUpdate_Mods || bUpdate_HP || bUpdate_Attribs)then
			UpdateFormationAttribs();
		endif;
		
		UpdateDeliveries();

//		KLog.LogWarn("CaOr","TTChange "+iOps.ToString()+" "+GetName());

		var ^CTechTree.CNode pxNode = m_xTechTree.FindNode(m_sObjPath+"/special_abilities");
		m_xAbilities.AddAbilities(pxNode, true);

		if(bSpecialAbilities)then
			var ^CFightingObj.CSpecialAbility pxAb = m_xAbilities.GetAbility("self_heal", true);
			DeleteTimer(TIMER_SELFHEAL);
			if(pxAb!=null) then	
				CreateTimer(TIMER_SELFHEAL, CGameTimeSpan.OneSecond() * 1.0, true);
				m_fSelfHealAmount=pxAb^.GetValueF("amount");
			endif;
		endif;

	endproc;

	///////
	//	OnTechTreeChange()
	///////
	export proc void OnTechTreeChange()
		var CStringArray asArray;
		asArray.AddEntry("/ForceWeaponUpdate");
		asArray.AddEntry("/Objects/");

		OnTechTreeChange(asArray);
	endproc;

	proc void UpdateRangeNDamageInformation()

			var real fMAXREAL = 100000000.0f;
			var real fMINREAL = -100000000.0f;
			var real fMinRange = fMAXREAL;
			var real fMaxRange = fMINREAL;
			var real fRangeDmg = fMINREAL;
			var real fMeleeDmg = fMINREAL;
			var bitset dwDmgType = 0b;

			var string sWeaponL = GetRightHandWeapon();
			var string sWeaponM = GetSecondaryWeaponM();
			var string sWeaponS = GetSecondaryWeaponS();

			if(!sWeaponL.IsEmpty())then
				var ^CTechTree.CNode pxWeaponL = m_xTechTree.FindNode(sWeaponL);
				if(pxWeaponL!=null)then
					var ^CTechTree.CNode pxWeaponL_Projectiles = pxWeaponL^.GetSub("Projectile");
					if(pxWeaponL_Projectiles!=null && pxWeaponL_Projectiles^.NumSubs()>0)then // long range weapon is a projectile weapon
						fMaxRange = Math.Max(fMaxRange,pxWeaponL^.GetSubValueF("range",fMINREAL));
						fMinRange = Math.Min(fMinRange,pxWeaponL^.GetSubValueF("minattackrange",fMAXREAL));
						fRangeDmg = pxWeaponL^.GetSubValueF("damage",fMINREAL);
						fRangeDmg *= GetTechTreeModifier("Damage",true);
						fRangeDmg += GetTechTreeModifier("Damage",false);
						fRangeDmg *= GetTechTreeModifier("ranged_damage",true);
						fRangeDmg += GetTechTreeModifier("ranged_damage",false);

						if(pxWeaponL^.GetSubValueF("poison_damage",-1.0f)>0.0f)then
							dwDmgType |= dwRANGE_POISON;
						endif;
						if(pxWeaponL^.GetSubValueF("hitrange",-1.0f)>0.0f)then
							dwDmgType |= dwRANGE_AREA;
						endif;
						if(pxWeaponL^.GetSubValueI("penetration",0)==1)then
							dwDmgType |= dwRANGE_AREA;
						endif;
						if(pxWeaponL^.GetSubValueF("armorpiercing",-1.0f)>0.0f)then
							dwDmgType |= dwRANGE_PIERCE;
						endif;

						if(!sWeaponS.IsEmpty())then
							var ^CTechTree.CNode pxWeaponS = m_xTechTree.FindNode(sWeaponS);
							if(pxWeaponS!=null)then
								//fMaxRange = Math.Max(fMaxRange,pxWeaponS^.GetSubValueF("range",fMINREAL));
								fMinRange = Math.Min(fMinRange,pxWeaponS^.GetSubValueF("minattackrange",fMAXREAL));
								fMeleeDmg = pxWeaponS^.GetSubValueF("damage",fMINREAL);
								fMeleeDmg *= GetTechTreeModifier("Damage",true);
								fMeleeDmg += GetTechTreeModifier("Damage",false);

								if(pxWeaponS^.GetSubValueF("poison_damage",-1.0f)>0.0f)then
									dwDmgType |= dwMELEE_POISON;
								endif;
								if(pxWeaponS^.GetSubValueF("hitrange",-1.0f)>0.0f)then
									dwDmgType |= dwMELEE_AREA;
								endif;
								if(pxWeaponS^.GetSubValueI("penetration",0)==1)then
									dwDmgType |= dwMELEE_AREA;
								endif;
								if(pxWeaponS^.GetSubValueF("armorpiercing",-1.0f)>0.0f)then
									dwDmgType |= dwMELEE_PIERCE;
								endif;
							endif;
						endif;
					else
						fMaxRange = Math.Max(fMaxRange,pxWeaponL^.GetSubValueF("range",fMINREAL));
						fMinRange = Math.Min(fMinRange,pxWeaponL^.GetSubValueF("minattackrange",fMAXREAL));
						fMeleeDmg = pxWeaponL^.GetSubValueF("damage",fMINREAL);
						fMeleeDmg *= GetTechTreeModifier("Damage",true);
						fMeleeDmg += GetTechTreeModifier("Damage",false);

						if(pxWeaponL^.GetSubValueF("poison_damage",-1.0f)>0.0f)then
							dwDmgType |= dwMELEE_POISON;
						endif;
						if(pxWeaponL^.GetSubValueF("hitrange",-1.0f)>0.0f)then
							dwDmgType |= dwMELEE_AREA;
						endif;
						if(pxWeaponL^.GetSubValueI("penetration",0)==1)then
							dwDmgType |= dwMELEE_AREA;
						endif;
						if(pxWeaponL^.GetSubValueF("armorpiercing",-1.0f)>0.0f)then
							dwDmgType |= dwMELEE_PIERCE;
						endif;
					endif;
				endif;
			endif;

			if(fMinRange >= fMAXREAL)then
				fMinRange = 0.0f;
			endif;
			if(fMaxRange < 0.0f)then
				fMaxRange = 0.0f;
			endif;
			if(fMeleeDmg < 0.0f)then
				fMeleeDmg = 0.0f;
			endif;
			if(fRangeDmg < 0.0f)then
				fRangeDmg = 0.0f;
			endif;

			var real fTmpMeleeBonus = CalcAttackBoni(fMeleeDmg);
			var int iTmpMeleeBonus = 0;
			if(fMeleeDmg > 0.0f)then
				if(fTmpMeleeBonus<fMeleeDmg)then
					iTmpMeleeBonus = Math.Floor(fTmpMeleeBonus-fMeleeDmg).ToInt();
				else
					iTmpMeleeBonus = Math.Ceil(fTmpMeleeBonus-fMeleeDmg).ToInt();
				endif;
			endif;

			var real fTmpRangeBonus = CalcAttackBoni(fRangeDmg);
			var int iTmpRangeBonus = 0;
			if(fRangeDmg > 0.0)then
				if(fTmpRangeBonus<fRangeDmg)then
					iTmpRangeBonus = Math.Floor(fTmpRangeBonus-fRangeDmg).ToInt();
				else
					iTmpRangeBonus = Math.Ceil(fTmpRangeBonus-fRangeDmg).ToInt();
				endif;
			endif;

			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("min_attackrange",Math.Ceil(fMinRange).ToInt());
				pxAttr^.SetValue("max_attackrange",Math.Ceil(fMaxRange).ToInt());
				pxAttr^.SetValue("meleedamage",Math.Ceil(fMeleeDmg).ToInt());
				pxAttr^.SetValue("rangedamage",Math.Ceil(fRangeDmg).ToInt());
				pxAttr^.SetValue("TmpMeleeAttackBoni",iTmpMeleeBonus);
				pxAttr^.SetValue("TmpRangeAttackBoni",iTmpRangeBonus);
				pxAttr^.SetValue("damagetype",dwDmgType.ToInt());
			endif;

	endproc;

	///////
	//	UpdateGfx()
	///////
	export proc bool UpdateGfx()
		if(GetEffectFlag(EFFECT_AJE_CAMOUFLAGE))then return true; endif;
		//KLog.LogSpam("TechTree","UpdateGfx: "+m_xTechTree.GetValueS(GetObjPath()+"/gfx","")+" =?= "+GetGfxName());
		var string sGFX = m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
		if(sGFX.IsEmpty()) then return false; endif;
		if(sGFX != GetGfxName())then
			SetGFX(sGFX);
			m_xWalkSet="defn";
			if(!HasWalkSet(m_xWalkSet)) then m_xWalkSet="def"; endif;
			SetDefaultWalkSet(GetWalkSet());
			return true;
		endif;
		return false;
	endproc;

	///////
	//	UpdateFOW()
	///////
	proc void UpdateFOW()
//		var string s="/Lvl_"+(GetLevel()+1).ToString();
		var real fFOW = m_xTechTree.GetValueR(GetObjPath()+"/FOW",20.0)*GetTechTreeModifier("FOW",true) + GetTechTreeModifier("FOW",false);
		SetFOWRange(fFOW);
	endproc;

	export proc void UpdateMods()
		// Overload this
	endproc;

	///////
	//	GetTechTreeModifier()
	///////
	export proc real GetTechTreeModifier(string p_sType, bool p_bRelative)
		var string sPath = "/Modifications/";
		sPath += GetTribeName()+"/";
		sPath += GetType().AsString()+"/";
		sPath += p_sType+"/";
		// boeser HACK :)
		sPath += "tec_";

		var real fValue;

		if(p_bRelative)then
			sPath += "rel";
			fValue = 1.0;
		else
			sPath += "abs";
			fValue = 0.0;
		endif;

		return(m_xTechTree.GetValueR(sPath,fValue));
	endproc;

	export proc real GetClassTechTreeModifier(string p_sType, bool p_bRelative)
		var string sPath = "/Modifications/";
		sPath += GetTribeName()+"/";
		sPath += GetClassName()+"/";
		sPath += p_sType;

		var real fValue;

		if(p_bRelative)then
			sPath += "/rel";
			fValue = 1.0;
		else
			sPath += "/abs";
			fValue = 0.0;
		endif;

		return(m_xTechTree.GetValueR(sPath,fValue));
	endproc;

	export proc real GetTechTreeActionModifier(string p_sClass, string p_sType)

		var string sTempClass = p_sClass;
		var string sClass = sTempClass.Mid(sTempClass.FindRev('/')+1);
		sTempClass.Delete(sTempClass.FindRev('/'),sClass.GetLength()+1);
		var string sType = sTempClass.Mid(sTempClass.FindRev('/')+1);
		var string sSort;
		if(sType!="Invent")then
			sTempClass.Delete(sTempClass.FindRev('/'),sType.GetLength()+1);
			sSort = sTempClass.Mid(sTempClass.FindRev('/')+1);
			sTempClass.Delete(sTempClass.FindRev('/'),sSort.GetLength()+1);
		else
			sSort = sType;
		endif;

		var string sPath = "/Modifications/"+GetPlayerTribeName()+"/"+sSort;

		if(sSort=="Build")then
			sPath += "/"+sType;
		endif;

		sPath += "/"+p_sType;
		return m_xTechTree.GetValueR(sPath,1.0);

	endproc;

	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="LE_SetTTFilters")then
			var ^CTechTreeDef pxTTDef=GetTechTreeDef();
			if(pxTTDef==null)then return; endif;
			pxTTDef^.ClearFilters();

			var array string asFilter;
			p_sMiscParams.Split(asFilter,"\n",true);
			var int i,iC=asFilter.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				pxTTDef^.EnableFilter(asFilter[i]);
			endfor;
		elseif(p_sCommand=="LE_SetLevel")then
			var int iLvl=p_sMiscParams.ToInt();
			SetLevelClean(iLvl);
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;


	proc bool GiveCommandsToTransportObj(string p_sCommand, string p_sMiscParams)
		var ^CGameObj pxTransportObj=GetTransportObj().GetObj();
		if(pxTransportObj!=null)then
			 if(p_sCommand == "Cancel")then return true; endif;
		endif;
		return false;
	endproc;


	proc void SetDefensiveMode(string p_sMiscParams)
		var ^CTechTreeDef pxTTDef=GetTechTreeDef();
		if(pxTTDef==null)then return; endif;
		var bool bOn = m_bDefensiveMode = p_sMiscParams.Find("mode_on")>=0;
		var CTechTree xTT = GetTechTree();
		var ^CTechTree.CNode pxAction = xTT.FindNode(p_sMiscParams);
		if(pxAction!=null) then
			var ^CTechTree.CNode pxRes = pxAction^.GetSub("results");
			if(pxRes!=null) then
				var int i, iC = pxRes^.NumSubs();
				for(i=0) cond(i<iC) iter(++i) do
					if(bOn) then
						pxTTDef^.EnableFilter(pxRes^.GetSub(i)^.GetValue());
					else
						pxTTDef^.DisableFilter(pxRes^.GetSub(i)^.GetValue());
					endif;
				endfor;
				m_bDefensiveMode = bOn;
			endif;
		endif;

		if(bOn)then
			var CObjHndl xMode = AddFX("fx_defensive_mode", -1.0);
			var CFourCC xLink;
			if(xMode.IsValid())then
				xMode.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
		else
			RemoveFX("fx_defensive_mode");
		endif;


		OnTechTreeChange();
		// HACK
		if(HasWalkAction()) then
			var vec3 vP = GetCurWalkTarget();
			WalkAction(vP,GetDefaultSpeed());
		endif;
		// ENDHACK
	endproc;

	export proc void AbortTask()
		BreakCurTask();
		TerminateAction();
	endproc;

	proc bool ProcessTTFilter(^CGameObj p_pxObj, string p_sTTP, bool p_bSetFilter)
		if(p_pxObj==null)then
			//L KLog.LogSpam("MaZi","p_pxObj==null");
			return false;
		endif;
		if(p_pxObj^.GetType()!="ANML")then
			//L KLog.LogSpam("MaZi","p_pxObj^.GetType()!=\"ANML\"");
			return false;
		endif;

		var CTechTree xTechTree = p_pxObj^.GetTechTree();

		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var int iOwner = p_pxObj^.GetOwner();
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(iOwner);

		var int i = 0;

		var string sResult = "Start";
		var string sResultPath = "Start";

		while(sResultPath!="")do
			sResult = p_sTTP+"/results/"+i.ToString();
			sResultPath = xTechTree.GetValueS(sResult,"");
			var string sResultClass = xTechTree.GetValueS(sResult+"/class","");
			var string sType = xTechTree.GetValueS(sResult+"/type", "deactivate");

			var ^CTechTreeDef pxTechTreeDef;

			if(sResultClass=="local")then
				pxTechTreeDef = p_pxObj^.GetTechTreeDef();
			else
				pxTechTreeDef = ^(pxPlayer^.GetPlayerTechTreeDef());
			endif;

			if(p_bSetFilter) then
				if(pxTechTreeDef!=null)then
					if(sType=="deactivate") then
						pxTechTreeDef^.DisableFilter(sResultPath);
						//KLog.LogSpam("MaZi", "DisableFilter("+sResultPath+") - "+sResultClass+"/"+sType);
					else
						pxTechTreeDef^.EnableFilter(sResultPath);
						//KLog.LogSpam("MaZi", "EnableFilter("+sResultPath+") - "+sResultClass+"/"+sType);
					endif;
				endif;
			endif;
			++i;
			sResultPath = xTechTree.GetValueS(p_sTTP+"/results/"+i.ToString(),"");
		endwhile;
		return true;
	endproc;

	export proc void AutoScout()
		if(!IsAbleToWalk())then return; endif;
		var ^CAutoScout pxTask=cast<CAutoScout>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"AutoScou"));
		pxTask^.Init(GetHandle(), GetPos());
		pxTask^.SetUserCommand(false);
		AddTask(pxTask,false);
	endproc;

	///////
	//	HandleGAmePlayCommand()
	///////
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(!IsDead())then
			// bQueued isn't used by CFightingObj::HandleGamePlayCommand yet, remove comment if you plan to use it!!!
			// SB#16564
			var bool bQueued=false;
			if(p_sCommand.Left(2)=="Q_")then
				bQueued=true;
				p_sCommand.Delete(0,2);
			endif;

			if(p_sCommand=="Attack" || p_sCommand=="Fight")then
				if (p_pxObject!=null) then
					Fight(p_pxObject, p_pxObject^.GetPos(), true);
				endif;
			elseif(p_sCommand=="Kill")then
				DiePerHarakiri();
			elseif(p_sCommand=="PickUp")then
	        	if(p_pxObject!=null)then
					PickUp(p_pxObject^.GetHandle(),false);
				endif;
			elseif (p_sCommand=="SetRallyPoint") then
				var CObjHndl xHndl;
				if(p_pxObject!=null)then
					xHndl = p_pxObject^.GetHandle();
				endif;
				//L KLog.LogSpam("Pickpoint","Recieved Vec3 FightingObj: "+p_vPos.ToString());
				var vec3 vPos;
				if(p_sMiscParams == "") then
					vPos = p_vPos;
				else
					vPos.FromString(p_sMiscParams);
				endif;
				//L KLog.LogSpam("Pickpoint","Tunneled vec3 is: "+p_sMiscParams+" ("+vPos.ToString()+")");
				SetRallyPoint(vPos,xHndl);
			elseif(p_sCommand=="CTheLite")then
				var ^CTheLite pxTask = cast<CTheLite>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"CTheLite"));
				pxTask^.Init(GetHandle(), p_vPos);
				AddTask(pxTask,true);
	      	elseif(p_sCommand == "setlevel")then
	        	var bool b = SetLevel(p_sMiscParams.ToInt());
	        	if(!b) then
					InvalidateAttrib("level");					// if level was not changed, make sure client receives old level again
				endif;
	        elseif(p_sCommand == "setlevelcheat")then
	        	SetLevelClean(Math.Min(GetLevel()+1,4));
	        elseif(p_sCommand == "setlevelcheatai")then
	        	SetLevelClean(Math.Clamp(p_sMiscParams.ToInt(), 0, 4));
	        elseif(p_sCommand == "upgradecheatai")then
				ProcessTTFilter(this, p_sMiscParams, true);
	        elseif(p_sCommand == "Dock")then
	        	if(p_pxObject!=null)then
					GoToObj(p_pxObject^.GetHandle(),true, false);
		        endif;
        		//HandleWalkCommand(p_vPos, p_sMiscParams);
			elseif(p_sCommand=="Action")then
				if(p_sMiscParams.Find("/GoAway") != -1)then
	        		// go away only if not on wall
	        		if(!GetOnWall() && !GetTransportObj().IsValid())then
						GoTo(p_vPos, false, GetDefaultSpeed(), true, true, false, true);
	        		endif;
				elseif(p_sMiscParams.Find("LevelUp")!=(-1))then
					var bool b = SetLevel(GetLevel()+1);
			        if(!b) then InvalidateAttrib("level"); endif;
	        	elseif(p_sMiscParams.Find("/Walk")>=0) then
	        		HandleWalkCommand(p_vPos, p_sMiscParams);
	        	elseif(p_sMiscParams.Find("/SetPos")>=0) then
	        		SetPos(p_vPos);
				elseif(p_sMiscParams.Find("/AddPriorityTarget")!=-1)then
					if(IsAbleToFight() && p_pxObject!=null)then
						AddPriorityTarget(p_pxObject^.GetHandle());
					endif;
				elseif(p_sMiscParams.Find("/ClearPriorityList")!=-1)then
					ClearPriorityList();
				elseif(p_sMiscParams.Find("/AttackSrv")!=-1)then
					Fight(p_pxObject,p_vPos,false);
				elseif(p_sMiscParams.Find("/Attack")!=-1)then
					if(IsAbleToFight())then
						Fight(p_pxObject,p_vPos,true);
					else
						var CGameObj.CAdvanceActionParams xParams;
						var CObjHndl xTarget;
						if(p_pxObject!=null)then
							xTarget=p_pxObject^.GetHandle();
						else
							xParams.m_vGoalOffset=p_vPos;
						endif;
						xParams.m_iPrefSpeed=GetMaxSpeed();
						var string sParam=p_sMiscParams.Mid(p_sMiscParams.Find("/RangeToWalk="));
						sParam=sParam.Mid(sParam.Find("=")+1);
						xParams.m_fMinDistance=sParam.ToReal();
						GoTo(xTarget,xParams, true, false);
					endif;
				elseif(p_sMiscParams.Find("/FountainHeal")>=0) then
					FountainHeal(p_pxObject);
				elseif(p_sMiscParams.Find("/BoardTransporter")!=-1)then
					BoardTransport(p_pxObject, p_vPos, true, p_sMiscParams);
				elseif(p_sMiscParams.Find("/AggroState_")!=-1)then

					var string sMode = p_sMiscParams.Mid(p_sMiscParams.FindRev('_')+1);
					if(!m_bIsBerserker)then
						SetAggressionState(sMode.ToInt());
					endif;
				elseif(p_sMiscParams.Find("/AggressiveTarget")!=-1)then
					var ^CTask pxTask = m_pxTaskMgr^.GetCurTask();
					if(pxTask!=null)then
						if(pxTask^.Break())then
							pxTask^.EndTask();
						endif;
					endif;
					UpdateAggressionPos(p_vPos);
					m_bAggressionWalk = true;
					m_bAggrTNoAnml=false;
					if(p_sMiscParams.Find("/AggrTNoAnml")!=-1) then m_bAggrTNoAnml=true; endif;
					var array vec3 avPos; avPos.AddEntry(p_vPos);
					StartPatrol(avPos, 0, GetDefaultSpeed());
					CheckPatrol();
				elseif(p_sMiscParams.Find("/Kill")!=-1)then
					DiePerHarakiri();
				elseif(p_sMiscParams.Find("/Notify")>=0) then
					Notify(p_sMiscParams);
				elseif(p_sMiscParams.Find("/Stop")>=0) then
					StopEverything();
				elseif(p_sMiscParams.Find("/defensive_mode")>=0) then
					if(CheckSpecialActionTimer(p_sMiscParams)) then
						SetDefensiveMode(p_sMiscParams);
					endif;
				else
					super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
				endif;
			elseif(p_sCommand == "Cancel")then
				CancelAction(p_sMiscParams);
			elseif(p_sCommand == "Execute_Q_Walk")then
				var CObjHndl xInitiator;
				xInitiator.FromInt(p_sMiscParams.ToInt());
				if(xInitiator==GetHandle()) then
					//we are already starting the new Task, invoke walkaction
					var ^CWalkToPos pxCurWalkTask=cast<CWalkToPos>(GetCurTask());
					if(pxCurWalkTask!=null) then pxCurWalkTask^.InvokeWalkAction(); endif;
				else
					if(m_pxTaskMgr^.NumSubs()>=2) then
						var ^CWalkToPos pxTask=cast<CWalkToPos>(m_pxTaskMgr^.GetSubState(1));
						if(pxTask!=null&&pxTask^.GetTargetPos()==p_vPos) then
							//KLog.LogWarn("CHP","Execute_Q_Walk: "+GetName());
							m_pxTaskMgr^.StopCurTask();
						endif;
					endif;
				endif;
			else
				super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
			endif;
		else
			CSrvWrap.LogInfo("FightingObj","HandleGamePlayCommand: Object is dead, it cannot do anything!");
		endif;
	endproc;

	export proc void AddPriorityTarget(CObjHndl p_xTarget)
		m_xPriorityList.AddEntry(p_xTarget);
		/*AI:
		if(!IsInFight())then
			ExamineEnemies(false, false);
		endif;
		*/
	endproc;

	export proc void ClearPriorityList()
		m_xPriorityList.Clear();
	endproc;

	export proc void StopEverything()
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.Break();
			if(HasWalkAction())then
				TerminateAction();
			endif;
			if(m_pxPatrolInfo!=null)then
				delete m_pxPatrolInfo;
				m_pxPatrolInfo=null;
			endif;
		endif;
		UpdateAggressionPos(GetPos());
	endproc;

	export proc void CancelAction(string p_sTTPath)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.RemoveAction(p_sTTPath);
		endif;
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","none");
			pxAttr^.SetValue("CurProcessObj","");
			pxAttr^.SetValue("CurProcess",0);
		endif;
	endproc;


	proc void Notify(string p_sMiscParams)
		var bool bQueued = false;
		var string sDest = "";
		var array string asToks;
		p_sMiscParams.Split(asToks, "/", true);
		var int i, iC = asToks.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var array string asDef;
			asToks[i].Split(asDef, "=", true);
			if(asDef.NumEntries()==1) then
				if(asDef[0].Find("Queued")>=0) then
					bQueued=true;
				endif;
			elseif(asDef.NumEntries()==2) then
				if(asDef[0].Find("Notify")>=0) then
					sDest=asDef[1];
				endif;
			endif;
		endfor;

		var ^CNotify pxTask=cast<CNotify>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Notify"));
		pxTask^.Init(GetHandle(), sDest);
		pxTask^.SetUserCommand(true);
		AddTask(pxTask, bQueued);
	endproc;

	export proc void HandleWalkCommand(vec3 p_vPos, string p_sMiscParams)
		var bool bQueued=false;
		var bool bPatrol=false;
        var int iSpeed = GetMaxSpeed();
        var bool bUseMaterial = true;
        var bool bUsePF = true;
        var bool bHeightAdapt = true;

		if(p_vPos!={0.0,0.0,0.0})then
			UpdateAggressionPos(p_vPos);
			var array string asToks;
        	p_sMiscParams.Split(asToks, "/", true);

           	var int i, iC = asToks.NumEntries();
        	for(i=0) cond(i<iC) iter(++i) do
        		var array string asDef;
        		asToks[i].Split(asDef, "=", true);
        		if(asDef.NumEntries()==1) then
        			if(asDef[0].Find("Queued")>=0) then
        				bQueued=true;
        			endif;
        			if(asDef[0].Find("Patrol")>=0) then
        				bPatrol=true;
        			endif;
        			if(asDef[0].Find("NoPF")>=0) then
        				bUsePF=false;
        			endif;
        			if(asDef[0].Find("NoHeightAdapt")>=0) then
        				bHeightAdapt=false;
        			endif;
        		elseif(asDef.NumEntries()==2) then
        			if(asDef[0].Find("Speed")>=0) then
        				iSpeed = asDef[1].ToInt();
        			endif;
        			if(asDef[0].Find("UseMaterial")>=0) then
        				bUseMaterial = asDef[1]!="false";
        			endif;
        		endif;
        	endfor;
        	if(bPatrol)then
        		AddPatrolPoint(p_vPos,iSpeed);
        	else
        		GoTo(p_vPos, true, iSpeed, bUsePF, bHeightAdapt, false, bQueued, bUseMaterial);
        	endif;
        endif;
		UpdateWalkTargetAttribs();
		UpdatePatrolTargetAttribs();
	endproc;

	export proc void UpdateWalkTargetAttribs()

		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;

		var array vec3 avPos;

		var int i,iC=m_pxTaskMgr^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CWalkToPos pxTask=cast<CWalkToPos>(m_pxTaskMgr^.GetSubState(i));
			if(pxTask==null)then continue; endif;
			if(pxTask^.GetTargetPos()=={0.0,0.0,0.0})then continue; endif;
			avPos.AddEntry(pxTask^.GetTargetPos());
		endfor;

		var string sTargets;

		iC=Math.Min(avPos.NumEntries(),10);
		for(i=0)cond(i<iC)iter(i++)do
			sTargets+=avPos[i].ToString()+"|";
		endfor;

		pxAttr^.SetValue("WalkTargets",sTargets);
	endproc;

	export proc void UpdatePatrolTargetAttribs()

		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr==null)then return; endif;

		var array vec3 avPos;
		if(m_pxPatrolInfo!=null)then
			avPos=m_pxPatrolInfo^.m_avWaypoints;
		endif;

		var string sTargets;

		var int i,iC=Math.Min(avPos.NumEntries(),10);
		for(i=0)cond(i<iC)iter(i++)do
			sTargets+=avPos[i].ToString()+"|";
		endfor;
		pxAttr^.SetValue("PatrolTargets",sTargets);
	endproc;


	export proc bool SetRallyPoint(vec3 p_vPoint, CObjHndl p_xTarget)
		var vec3 vPos = p_vPoint;
		m_xRallyTarget = CObjHndl.Invalid();
		var ^CGameObj pxRallyTarget = p_xTarget.GetObj();
        var ^CAttribs pxAttr = GetAttribs();

		if(pxRallyTarget!=null)then
			var CFourCC xLink = "Ex_1";
			if (!pxRallyTarget^.GetLinkPosWorld(xLink,vPos)) then
				vPos=pxRallyTarget^.GetPos();
			endif;
			m_xRallyTarget = p_xTarget;
		else
			var bitset dwLT=CObjMgrHost.GFPLT_Land;
			if (pxAttr!=null) then
				var bool bHarbour = pxAttr^.GetValueBool("fishDelivery");
				if(bHarbour) then
					dwLT=CObjMgrHost.GFPLT_Water;
				endif;
			endif;
/*
			if(!CSrvWrap.GetObjMgr()^.GetFreePos(vPos,this,vPos,null,true,false,true,1.0f,dwLT)) then
				return false;
			endif;
*/
		endif;

		var real fHeight = CSrvWrap.GetScapeMgr().GetHeight(vPos.GetX(), vPos.GetY());
		var real fSeaHeight = CSrvWrap.GetScapeMgr().GetSeaLevel();
		if(fSeaHeight>fHeight)then
			fHeight = fSeaHeight;
		endif;

		vPos.SetZ(fHeight);

		if (pxAttr!=null) then
			pxAttr^.SetValue("RallyPoint", vPos.ToString());
			pxAttr^.Invalidate("RallyPoint");					// if level was not changed, make sure client receives old level again
		endif;

		//KLog.LogWarn("CHP","rallypoint changed from "+m_vRallyPos.ToString()+" to "+vPos.ToString());
		m_vRallyPos = vPos;
        return(true);
	endproc;

	export proc vec3 GetRallyPosition(int p_iPrevention)

		if(p_iPrevention>10)then return {0.0,0.0,0.0}; endif;

		if(m_xRallyTarget.IsValid())then
			var ^CBuilding pxBuilding = cast<CBuilding>(m_xRallyTarget.GetObj());
			if(pxBuilding!=null)then
				return pxBuilding^.GetRallyPosition(p_iPrevention+1);
			endif;
		endif;
		return m_vRallyPos;
	endproc;

	export proc ref CObjHndl GetRallyTarget()
		return m_xRallyTarget;
	endproc;
	
	proc void SetRageUnit(bool p_bValue)
		m_bIsRageUnit=p_bValue;
	endproc;

	proc bool GetRageUnit()
		return m_bIsRageUnit;
	endproc;

	proc void SetRallySite(bool p_bRally)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		if(p_bRally)then
			pxAttr^.SetValue("IsRallySite",1);
		else
			pxAttr^.SetValue("IsRallySite",0);
		endif;
	endproc;

	export proc bool GetRallySite()
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return false; endif;
		return (pxAttr^.GetValueInt("IsRallySite")==1);
	endproc;

	export proc void HealMe(real p_fAddHitpoints)
		AddRangedBuff("is_getting_healed");
		
		if(GetHitpoints()<GetMaxHitpoints())then
			DeleteTimer(TIMER_ISGETTINGHEALED_FX);
			CreateTimer(TIMER_ISGETTINGHEALED_FX,CGameTimeSpan.OneSecond() * 2.5, false);
			
			var CObjHndl xHndl=AddFX("fx_heal_passive",-1.0);
			var CFourCC xLink;
			if(xHndl.IsValid())then
				xHndl.GetObj()^.LinkAction(GetHandle(),xLink);
			endif;
		endif;
		DeleteTimer(TIMER_ISGETTINGHEALED);
		CreateTimer(TIMER_ISGETTINGHEALED,CGameTimeSpan.OneSecond() * 2.5, false);
		if((GetHitpoints()+p_fAddHitpoints) > GetMaxHitpoints())then
			SetHitpoints(GetMaxHitpoints());
			return;
		endif;
		SetHitpoints((GetHitpoints()+p_fAddHitpoints));
	endproc;

	export proc void FullHeal()
		SetHitpoints(GetMaxHitpoints());
	endproc;

	export proc void FountainHeal(^CGameObj p_pxO)
		if(p_pxO!=null) then
			var ^CFountainHeal pxFH = cast<CFountainHeal>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"FntnHeal"));
			pxFH^.Init(GetHandle(), p_pxO^.GetHandle());
			pxFH^.SetUserCommand(true);
	    	AddTask(pxFH, false);
		endif;
	endproc;

	export proc int GetTransportClass()
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			return pxAttr^.GetValueInt("transportclass");
		endif;
		return 0;
	endproc;

	export proc void BoardTransport(^CGameObj p_pxTransport, vec3 p_vPos,  bool p_bUserCommand, string p_sParams)

		if(GetTransportObj().IsValid())then return; endif;

		if(p_pxTransport==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;

		if(p_pxTransport^.GetOwner()!=GetOwner())then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;

		var ^CTransportObj pxObj=cast<CTransportObj>(p_pxTransport);

		if(pxObj==null)then
			GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			return;
		endif;

		var int iSelfType=GetTransportClass();
		var int iTransporterType=pxObj^.GetTransportClass();
		var string sTaskName=m_pxTaskMgr^.GetCurTaskName();

		if(iTransporterType<=iSelfType)then
			if(sTaskName!="BoardTra")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;

		var bool bQueued=false;
		if(p_sParams.Find("/Queued")!=-1)then
			bQueued=true;
		endif;

		if(pxObj^.NumFreeSeats()<NeededSpaceInTransport())then
			if(sTaskName!="BoardTra" && sTaskName!="BoardPas")then
				GoTo(p_vPos, true, GetDefaultSpeed(), true, true, GetOnWall(), false, true);
			endif;
			return;
		endif;

		var ^CManagedBoardingPassenger pxTask=cast<CManagedBoardingPassenger>(m_pxTaskMgr^.GetCurTask());
		if(pxTask!=null)then
			if(bQueued)then
				return;
			else
				BreakCurTask();
			endif;
		endif;
		pxTask=cast<CManagedBoardingPassenger>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BoardPas"));
		if(pxTask!=null)then
			pxTask^.SetUserCommand(true);
			pxTask^.Init(GetHandle(),p_pxTransport^.GetHandle());
			AddTask(pxTask,false);
		endif;
	endproc;

	export proc void StopBoarding()
		var ^CManagedBoardingPassenger pxPasTask=cast<CManagedBoardingPassenger>(m_pxTaskMgr^.GetCurTask());
		var ^CManagedBoardingTransporter pxTraTask=cast<CManagedBoardingTransporter>(m_pxTaskMgr^.GetCurTask());
		if(pxPasTask!=null || pxTraTask!=null)then
			BreakCurTask();
		endif;
	endproc;

	export proc int NeededSpaceInTransport()
		return 1;
	endproc;

	export proc bool IsOnShip()
		return (m_xTransportObj.IsValid() && m_xTransportObj.GetObj()^.GetType()=="SHIP");
	endproc;


	export proc bool IsOnOpenTransporter()
		return false;
	endproc;


    export proc void SetTaskDescription(string p_sDesc)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null && pxAttr^.GetValue("TaskDescription")!=p_sDesc)then
			pxAttr^.SetValue("TaskDescription",p_sDesc);
		endif;
	endproc;


	///////
	//	Rotate2Obj()
	///////
	export proc void Rotate2Obj(CObjHndl p_xObj)
		var ^CGameObj pxObj=p_xObj.GetObj();
		if(pxObj==null)then return; endif;
		var vec3 vDir=pxObj^.GetPos()-GetPos();
		var Quat qTRot;
		qTRot.FromXYDir(vDir.GetX(),vDir.GetY());
		RotateAction(qTRot);
	endproc;

	export proc void SetTrumpetEffect()
		if(GetType()=="BLDG")then return; endif;

		//TUNING: Duration of trumpet effect
		var real fDuration = 15.0;

		DeleteTimer(TIMER_MAMMOTH_TRUMPET);
		SetEffectFlag(EFFECT_MAMMOTH_TRUMPET, true);
		ForceBoniUpdate();
		CreateTimer(TIMER_MAMMOTH_TRUMPET,CGameTimeSpan.OneSecond() * fDuration, false);
	endproc;

	export proc void SetStoned(real p_fDuration)
		TerminateAction();
		SetTrapped(p_fDuration);
		DeleteTimer(TIMER_STONED);
		SetEffectFlag(EFFECT_ITEM_STONED, true);
		CreateTimer(TIMER_STONED, CGameTimeSpan.OneSecond() * p_fDuration, false);
	endproc;

	export proc void SetIced(real p_fDuration)
		var real fImmunityTime=30.0f;
		if(HasTimer(TIMER_FROST))then
			DeleteTimer(TIMER_FROST);
		endif;
		if(HasTimer(TIMER_FROSTIMMUNITY))then
			return;
		endif;
		SetIcedFlag(true);
		SetTrapped(p_fDuration);
		SetEffectFlag(EFFECT_ITEM_STONED, true);
		CreateTimer(TIMER_FROST,CGameTimeSpan.OneSecond()*p_fDuration, false);
		//CreateTimer(TIMER_FROSTIMMUNITY,CGameTimeSpan.OneSecond()*fImmunityTime, false);
	endproc;

	export proc void SetPawEffect()

		//TUNING: Duration of trumpet effect
		var real fDuration = 15.0;

		DeleteTimer(TIMER_TRICERATOPS_PAW);
		SetEffectFlag(EFFECT_TRICERATOPS_PAW, true);
		CreateTimer(TIMER_TRICERATOPS_PAW,CGameTimeSpan.OneSecond() * fDuration, false);

	endproc;

	export proc real GetProdSpeedFactor(CFourCC p_xType)
		if(p_xType=="ANML") then
			var real fS = GetBonusSum(CFightingObj.BONUS_PRODSPEED_ANML);
			if (fS == 0.0f) then
				return 1.0f;
			endif;
			return fS;
		else
			return 1.0f;
		endif;
	endproc;

	export proc ^CAttribs GetPlayerAttribs()
		var ^CLevel pxCurLevel = CSrvWrap.GetCurLevel();
		if (pxCurLevel==null) then return null; endif;

		var ^CPlayer pxP = pxCurLevel^.GetPlayer(GetOwner());
		if (pxP==null) then return null; endif;
		return pxP^.GetAttribs();
	endproc;

	export proc bool CanHarvest()
		var bool bResult=m_xTechTree.GetValueB(GetObjPath()+"/can_harvest",false);
		bResult = (bResult && !GetTransportObj().IsValid());
		return(bResult);
	endproc;

	export proc bool CanBuild()
		var bool bResult=m_xTechTree.GetValueB(GetObjPath()+"/can_build",false);
		bResult = (bResult && !GetTransportObj().IsValid());
		return(bResult);
	endproc;

	export proc void CreateSpirit()

		var ^CSpirit pxSpirit=CSrvWrap.GetSpiritMgr().CreateSpirit();
		var ^CAttribs pxAttr = GetAttribs();
		pxSpirit^.SetPos(GetPos());
		pxSpirit^.SetOwner(GetOwner());
		pxSpirit^.SetRotation(GetRotation());
		pxSpirit^.SetRadius(GetRadius());

		var CTechTree xTechTree=GetTechTree();
		var string sObjPath = pxAttr^.GetValue("ObjPath");
		if(!sObjPath.IsEmpty())then
			pxSpirit^.SetDescription(sObjPath);
			//var string sDescription=xTechTree.GetValueS(sObjPath+"/description",GetClassName());
			//pxSpirit^.SetDescription(sDescription);
		endif:

		pxSpirit^.SetClass(GetClassName());
		var int iLevel = pxAttr^.GetValueInt("level");
		pxSpirit^.SetLevel(iLevel);
		pxSpirit^.SetMaxHP(pxAttr^.GetValueInt("maxhitpoints"));


		var ^CTechTreeDef pxTTDef = GetTechTreeDef();
		if(pxTTDef!=null) then
			var CStringArray asTTFilters;
			var int i, iC = pxTTDef^.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				asTTFilters.AddEntry(pxTTDef^.GetFilter(i));
			endfor;
			pxSpirit^.SetTTFilters(asTTFilters);
		endif;
	endproc;

endclass;


class CBonus

	export var array real		m_afTypeValue;
	export var array string		m_asTypeClass;

	export var array real		m_afClassValue;
	export var array string		m_asClassClass;

	export constructor()
	endconstructor;

	export proc void AddBonus( string p_sType, string p_sClass, real p_fValue)
		var int i;
		var int iIdx;
		if(p_sType=="Type")then
			iIdx = m_asTypeClass.FindEntry(p_sClass);
			if(iIdx!=-1)then
				m_afTypeValue[iIdx]+=p_fValue;
			else
				iIdx = m_asTypeClass.AddEntry(p_sClass);
				m_afTypeValue.AddEntry(p_fValue);
			endif;
		elseif(p_sType=="Class")then
			iIdx = m_asClassClass.FindEntry(p_sClass);
			if(iIdx!=-1)then
				m_afClassValue[iIdx]+=p_fValue;
			else
				iIdx = m_asClassClass.AddEntry(p_sClass);
				m_afClassValue.AddEntry(p_fValue);
			endif;
		endif;
		return;
	endproc;

	export proc ref CBonus op_Assign( ref CBonus p_rxN)

		m_asTypeClass=p_rxN.m_asTypeClass;
		m_afTypeValue=p_rxN.m_afTypeValue;

		m_asClassClass=p_rxN.m_asClassClass;
		m_afClassValue=p_rxN.m_afClassValue;

		return this^;
	endproc;

	export proc void Clear()
		m_asTypeClass = 0;
		m_afTypeValue = 0;
		m_asClassClass = 0;
		m_afClassValue = 0;
	endproc;

	export proc real GetBonus(string p_sType, string p_sClass)

		var real fBonus = 0.0;
		var int iIdx = m_asTypeClass.FindEntry(p_sType);
		if(iIdx!=-1)then
			fBonus += m_afTypeValue[iIdx];
		endif;
		iIdx = m_asClassClass.FindEntry(p_sClass);
		if(iIdx!=-1)then
			fBonus += m_afClassValue[iIdx];
		endif;
		return fBonus;

	endproc;

	export proc int NumBoni()
		return m_asTypeClass.NumEntries();
	endproc;

endclass;


class CAreaDamage

	var ^CTimerTick		m_pxTick;

	var ^CFightingObj 	m_pxFighter;
	var vec3			m_vTarget;
	var CObjHndl		m_xFighter;
	var int				m_iOwner;
	var int				m_iSizeClass;

	export constructor()
	endconstructor;

	export constructor(^CFightingObj p_pxFO, vec3 p_vTarget)

		/*if(p_pxFO==null)then return; endif;
		var real fHitRange = p_pxFO^.GetHitRange();
		if(fHitRange==0.0)then CSrvWrap.LogError("CAreaDamage","CAreaDamage created by "+p_pxFO^.GetName()+", but hitrange is 0.0!"); return; endif;
		if(p_pxFO^.GetDmg()==0.0)then CSrvWrap.LogError("CAreaDamage","CAreaDamage created by "+p_pxFO^.GetName()+", but damage is 0.0!"); return; endif;

		*/
		if(p_pxFO!=null)then
			m_iOwner = p_pxFO^.GetOwner();
			m_xFighter = p_pxFO^.GetHandle();
			m_pxFighter = p_pxFO;
			m_vTarget   = p_vTarget;
			m_iSizeClass=p_pxFO^.GetWeaponSizeClass();
			DoAreaDamage(p_pxFO^.GetHitRange(), p_pxFO^.GetDmg(), p_pxFO^.GetEndDmg());
		endif;
	endconstructor;

	export constructor(^CFightingObj p_pxFO, vec3 p_vTarget, real p_fRange, int p_iSizeClass)

		if(p_pxFO!=null)then
			m_iOwner = p_pxFO^.GetOwner();
			m_xFighter = p_pxFO^.GetHandle();
			m_pxFighter = p_pxFO;
			m_vTarget   = p_vTarget;
			m_iSizeClass=p_iSizeClass;
			DoAreaDamage(p_fRange, p_pxFO^.GetDmg(), p_pxFO^.GetEndDmg());
		endif;
	endconstructor;

	export constructor(^CFightingObj p_pxFO, vec3 p_vTarget, int p_iSizeClass)
		if(p_pxFO!=null)then
			m_iOwner = p_pxFO^.GetOwner();
			m_xFighter = p_pxFO^.GetHandle();
			m_pxFighter = p_pxFO;
			m_vTarget   = p_vTarget;
			m_iSizeClass=p_iSizeClass;
			DoAreaDamage(p_pxFO^.GetHitRange(), p_pxFO^.GetDmg(), p_pxFO^.GetEndDmg());
		endif;
	endconstructor;

	export constructor(^CFightingObj p_pxObj, string p_sTTPath, vec3 p_vTarget)
		if (p_pxObj!=null) then
			m_xFighter = p_pxObj^.GetHandle();
			m_iOwner = p_pxObj^.GetOwner();
			m_pxFighter = p_pxObj;
			m_vTarget = p_vTarget;
			var ^CPlayer pxPlayer = CSrvWrap.GetCurLevel()^.GetPlayer(m_iOwner);
			var CTechTree xTT;
			if(pxPlayer!=null) then
				xTT = pxPlayer^.GetPlayerTechTree();
			endif;

			var real fDmg 		= 0.0f;
			var real fEndDmg	= 0.0f;
			var real fHitRange	= 0.0f;
			m_iSizeClass		= 0;

			var ^CTechTree.CNode pxTTNode = xTT.FindNode(p_sTTPath);
			if(pxTTNode!=null)then
				fDmg 		= pxTTNode^.GetSubValueF("damage",0.0f);
				fEndDmg 	= pxTTNode^.GetSubValueF("enddamage",0.0f);
				fHitRange 	= pxTTNode^.GetSubValueF("hitrange",0.0f);
				m_iSizeClass= pxTTNode^.GetSubValueI("unit_size",0);
			endif;
			DoAreaDamage(fHitRange, fDmg, fEndDmg);
		endif;
	endconstructor;

	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos)
		m_iOwner = p_iOwner;
		m_vTarget = p_vPos;
		DoAreaDamage(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;

	export constructor(real p_fHitRange, real p_fDmg, real p_fEndDmg, int p_iOwner, vec3 p_vPos,int p_iSizeClass)
		m_iOwner = p_iOwner;
		m_vTarget = p_vPos;
		m_iSizeClass=p_iSizeClass;
		DoAreaDamage(p_fHitRange, p_fDmg, p_fEndDmg);
	endconstructor;

	proc void DoAreaDamage(real p_fHitRange, real p_fDmg, real p_fEndDmg)

		if(p_fHitRange<=0.0)then
			p_fHitRange=1.0;
		endif;
		
		if(m_xFighter.IsValid())then
			m_pxFighter^.UpdateFightFactors();
		endif;
		
		var CObjList xEnemies;
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(m_iOwner, xQuery, false);
		xQuery.SetOwner(-1, true);
		xQuery.SetType("CHTR");
		xQuery.SetType("SHIP",true);
		xQuery.SetType("ANML",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("BLDG",true);
		xQuery.SetType("FGHT",true);
		xQuery.SetType("NEST",true);
		xQuery.RegionCircle(m_vTarget, p_fHitRange+20.0);

		xQuery.Execute(xEnemies);

		var int i, iC=xEnemies.NumEntries();
		for (i=0) cond(i<iC) iter(++i) do
			var ^CFightingObj pxFO = cast<CFightingObj>(xEnemies[i].GetObj());
			if(pxFO==null)then continue; endif;
			if(pxFO^.GetTransportObj().IsValid())then continue; endif;

			var real fDistance = (pxFO^.GetPos() - m_vTarget).Abs2();
			fDistance-=pxFO^.GetCollisionRadius();
			if(fDistance>=p_fHitRange)then xEnemies.DeleteEntry(i);i--; iC--; continue; endif;
			if(fDistance<0.0)then fDistance=0.0; endif;

			var real fEndDamageFactor = 0.0;
			if(p_fDmg!=0.0)then
				fEndDamageFactor = p_fEndDmg / p_fDmg;
			endif;
			var real fFactor = ( (1.0 - fEndDamageFactor) * ((p_fHitRange - fDistance) / p_fHitRange) ) + fEndDamageFactor;

			//L CSrvWrap.LogInfo("AreaDamage","p_fDmg/p_fEndDmg/fFactor "+p_fDmg.ToString()+"/"+p_fEndDmg.ToString()+"/"+fFactor.ToString());


			if(m_xFighter.IsValid())then
				pxFO^.TakeDmg(m_pxFighter, fFactor);
				pxFO^.AddEnemy(m_xFighter, true);
			else
				pxFO^.TakeDirectDmg(p_fDmg*fFactor);
			endif;
		endfor;

		if(m_iSizeClass>0) then
			CFightingObj.InvokeAreaThrow(m_vTarget,xEnemies,m_iSizeClass);
		endif;

		m_pxTick = new CTimerTick();
		m_pxTick^.m_xOnTick = OnDelete;
		m_pxTick^.SetTimer(0.5);

	endproc;

	export destructor()
		delete m_pxTick;
	enddestructor;

	proc void OnDelete()
		delete this;
	endproc;

endclass;


class CAttribBonus
	export var real		m_fBonus;
	export var int		m_iType;
	export var string	m_sIdentifier;			// used to identify this boni when removing

	export proc void Set(int p_iType, string p_sID, real p_fBonus)
		m_iType = p_iType;
		m_sIdentifier = p_sID;
		m_fBonus = p_fBonus;
	endproc;
endclass;

class CBoniBucket

	export var int 				m_iType;
	var array CAttribBonus		m_axBoni;

	export proc int NumEntries()
		return m_axBoni.NumEntries();
	endproc;

	export proc int FindEntry(string p_sID)
		var int i, iC = m_axBoni.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			if (m_axBoni[i].m_sIdentifier == p_sID) then
				return i;
			endif;
		endfor;
		return -1;
	endproc;

	export proc void AddEntry(ref CAttribBonus p_rxBonus)
		if (p_rxBonus.m_iType == m_iType) then
			if (FindEntry(p_rxBonus.m_sIdentifier)<0) then
				m_axBoni.AddEntry(p_rxBonus);
			else
				m_axBoni[FindEntry(p_rxBonus.m_sIdentifier)].m_fBonus = p_rxBonus.m_fBonus;
			endif;
		endif;
	endproc;

	export proc void AddEntry(string p_sID, real p_fBonus)
		var CAttribBonus xB;
		xB.Set(m_iType, p_sID, p_fBonus);
		AddEntry(xB);
	endproc;

	export proc void RemEntry(int p_iIdx)
		m_axBoni.DeleteEntryUS(p_iIdx);
	endproc;

	export proc void RemEntry(string p_sID)
		var int iIdx = FindEntry(p_sID);
		if (iIdx >= 0) then
			m_axBoni.DeleteEntryUS(iIdx);
		endif;
	endproc;

	export proc ref CAttribBonus op_Index(int p_iIdx)
		return m_axBoni[p_iIdx];
	endproc;

	export proc real GetBonusValue(int p_iID)
		return m_axBoni[p_iID].m_fBonus;
	endproc;

endclass;
