/*?
	?group URS.Scripts.Server.Classes
	?item CBuilding
	?desc This Class describes a Building in the Game.
	?prefix CBuilding
?*/
class CBuilding inherit CFightingObj

	var	bool					m_bStoneDelivery;				// can Characters deposite stone here
	var	bool					m_bWoodDelivery;				// can Characters deposite wood here
	var	bool					m_bFoodDelivery;				// can Characters deposite food here
	var	bool					m_bIronDelivery;				// can Characters deposite iron here
	var	bool					m_bResinDelivery;				// can Characters deposite resin (harz) here
	var	bool					m_bBoneDelivery;				// can Characters deposite bone here
	var	bool					m_bHideDelivery;				// can Characters deposite hide (tierhaut) here

	var bool					m_bBuildingReady;			//declares if building is ready or not

	var	bool					m_bUpgradeRes;				// can Characters deposite resin (harz) here
	var	bool					m_bUpgradeNat;				// can Characters deposite bone here
	var	bool					m_bUpgradeTec;				// can Characters deposite hide (tierhaut) here

	var bool					m_bHealthBuilding;				// can Charcters gain Health here
	var real					m_fHealingValue;

	var array string			m_asLimits;					//names of the limit attribs in player
	var array int				m_aiResLimits;				//resource limits update values

	var real					m_fProcess;

	var bool 					m_bNight;					// is it Night?
	var bool					m_bPartyMode;

	var string 					m_sClass;					// sets class for RallyPoint
	var string					m_sRalPos;

	var bool					m_bQuickHarvest;

	var int						m_iMaxBuilders;
	var CRepairDesc				m_xRepairDesc;

	//Test
	var	bool					m_bDeliverProduct;			//Sets if the product is allowed to deliver

	var array CBuilding.CBuildUpLink m_axBuildUpLinks;		//Array of BuildUp links available


	const real 					WORK_ANIM_TIMEOUT=6.0;
	const int					WORK_ANIM_TIMER_ID=724;
	const int 					NIGHT_TIMER=196;
	const int 					FUNCTION_TIMER=201;


	export const string			WORK_ANIM_NAME="work";
	export const string			WORK_FINISHED_ANIM_NAME="work_finished";


	class CBuildUpLink
		export var CFourCC	m_xLink;
		export var int		m_iWorkers;
		export var vec3		m_vPos;

		export proc bool op_Greater(ref CBuilding.CBuildUpLink p_rxOther)
			return (m_iWorkers>p_rxOther.m_iWorkers);
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			var string sA = m_xLink.AsString();
			p_rxArc << sA;
			m_xLink = sA;
			p_rxArc << m_iWorkers;
			p_rxArc << m_vPos;
		endproc;
	endclass;


	constructor()
		m_bPartyMode		= false;
	endconstructor;

	destructor()

		var ^CBasePlayer pxBasePlayer = CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			pxBasePlayer^.DestroyLimitCountBuilding(GetHandle());
		endif;

	enddestructor;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Bldg")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^<<m_bBuildingReady;
			if(p_pxReaderNode^.GetVersion()>=2) then
				m_xRepairDesc.DoKArc(pxArc);
			endif;
			if(p_pxReaderNode^.GetVersion()>=3) then
				var int i, iC;
				pxArc^ << iC;
				m_aiResLimits = iC;
				for(i=0)cond(i<iC)iter(i++)do
					pxArc^ << m_aiResLimits[i];
				endfor;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Bldg"; //Building base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bBuildingReady;
		m_xRepairDesc.DoKArc(pxArc);
		var int i, iC = m_aiResLimits.NumEntries();
		pxArc^ << iC;
		for(i=0)cond(i<iC)iter(i++)do
			pxArc^ << m_aiResLimits[i];
		endfor;
		pxWalk^.Close();
	endproc;


	export proc bool IsBuildMode()
		return (GetConstructLevel()<4);
	endproc;


	export proc void Die()
		CBLDGMgr.Get().RemoveBuilding(this);
		CBLDGConditionsMgr.Get().DeleteBuilding(this);
		super.Die();
	endproc;

	export proc bool CreateBuildingCorpse()
		return false;
	endproc;


/*?
	?item 	OnActionStart(void)
	?desc	Is called on Start of an Action
?*/
	proc void OnActionStart()
		GetFSM()^.Enable(false);			// Deactivate the FSM
	endproc;

/*?
	?item	OnInit(bool p_bLoad)
	?desc	Is called after construction to initialize this Structure
	?param	p_bLoad		true if the Initializing-Data have to be loaded
?*/
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(true);
		if(!p_bLoad) then															// If the object is created
			m_bBuildingReady = false;
    		SetType("BLDG");															// ... set the Type ...
         	SetSelectable(true);														// ... make it selectable ...
        	SetHitable(true);															// ... and hitable.
			InitAttribs();														// Initializes the Attributes
			
			var ^CAttribs pxAttr = GetAttribs();

			if(cast<CVirtualProduceUnit>(this)==null) then //no ui sound for VPU
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				if (pxLevel!=null) then
			
					// no building placed fx for virtual produce units or during loading of level
					if (!pxLevel^.IsLoading()) then
						InvokeGenericSCEvent(4,3.0f);	// Place building FX
					endif;
					
					var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
					if (pxPlayer!=null) then
						CSrvWrap.SendGenericEvtToPlayer(pxPlayer^.GetID(), "Placed\t"+GetClassName());
					endif;
				endif;
			endif;

			if(pxAttr!=null)then
				pxAttr^.SetValue("AIRelevant", false);
			endif;
    	endif;

		CBLDGMgr.Get().AddBuilding(this);
    	UpdateAttribs(p_bLoad);

   		AddUnit();

		// Sets the Type of Classes on which the Function has Effect ...
		m_xFunctionUnits.SetType("CHTR");											// ... this are Characters ...
		m_xFunctionUnits.SetType("ANML",true);										// ... this are Animals ...
		m_xFunctionUnits.SetType("VHCL",true);										// ... this are Vehicles ...
		m_xFunctionUnits.SetType("SHIP",true);										// ... this are Ships ...

		InitTimers();																// Initializes the Timers

       	InitInventory(6);															// Initializes the Inventory

		m_asLimits.AddEntry("max_units");
		m_asLimits.AddEntry("max_stone");
		m_asLimits.AddEntry("max_wood");
		m_asLimits.AddEntry("max_food");
		m_asLimits.AddEntry("max_iron");
		m_asLimits.AddEntry("max_resin");
		m_asLimits.AddEntry("max_bone");
		m_asLimits.AddEntry("max_hide");

		m_aiResLimits = 8;

		var ^CFSM pxFSM=GetFSM();													// Initializes the FiniteStateMachine
		// Creates the Idle-States
		var ^CState pxIdleState;

		SetDmg(0.0);
		SetMovableInFight(false);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);

		m_bDeliverProduct=false;
		m_bQuickHarvest=false;

		SetPlaceBlocker(true);

		OnTechTreeChange();

        if(!p_bLoad)then
			StartTT();
			SetCanFightAttrib(false);
		endif;
		SetMaxBuilders(10);
		CScareMap.Get().AddScareSource(GetPos(), GetRadius()*2.0f, 10.0f);
		CBuildingCost.Register(this);
		m_xRepairDesc.Init(GetHandle());

	endproc;
	
	export proc void SetIced(real p_fDuration)
		//buildings can't get iced
	endproc;

	proc void CheckAge()

		// track the time we reached a new techtree level for the statistics
		//var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		//var ^CStatisticMgr pxStatisticMgr=^(pxLevel^.GetStatisticMgr());
		var CGameTime xTime=CTimeMgr.Get().GetTime();

		var int iOldAge = GetAge();
		var string sTribe = GetPlayerTribeName();

		if(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_5/invented",false)) then
			SetAge(5);
			//pxStatisticMgr^.AddSample( CStatisticSample.Epoch.ToInt(), GetOwner(), 5 );
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"5");
			//KLog.LogWarn("CHP","age 5");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_4/invented",false)) then
			SetAge(4);
			//pxStatisticMgr^.AddSample( CStatisticSample.Epoch.ToInt(), GetOwner(), 4 );
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"4");
			//KLog.LogWarn("CHP","age 4");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_3/invented",false))then
			SetAge(3);
			//pxStatisticMgr^.AddSample( CStatisticSample.Epoch.ToInt(), GetOwner(), 3 );
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"3");
			//KLog.LogWarn("CHP","age 3");
		elseif(m_xTechTree.GetValueB("/Objects/"+sTribe+"/InventObjects/age_2/invented",false))then
			SetAge(2);
			//pxStatisticMgr^.AddSample( CStatisticSample.Epoch.ToInt(), GetOwner(), 2 );
			CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"2");
			//KLog.LogWarn("CHP","age 2");
		else
			SetAge(1);
			//KLog.LogWarn("CHP","age 1");
			//pxStatisticMgr^.AddSample( CStatisticSample.Epoch.ToInt(), GetOwner(), 1 );
			//CSrvWrap.GetGameLogger().Log("Age",GetOwner().ToString(),"1");
		endif;

		var ^CAttribs pxAttribs = GetPlayerAttribs();
		if ( pxAttribs!=null && iOldAge != GetAge() ) then
			pxAttribs^.SetValue("age", GetAge());
		endif;
	endproc;

	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="LE_SetReady")then

		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;


	export proc bool DoesCountInUnitLimit()
		return false;
	endproc;


	export proc void SetProcess(int p_iP)
		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null) then
			pxA^.SetValue("CurProcess", p_iP);
		endif;
	endproc;

	export proc void UpdateAttribs(bool p_bLoad)
		super.UpdateAttribs(p_bLoad);
		var ^CAttribs pxAttribs=GetAttribs();
		if(pxAttribs==null)then return; endif;
		if(!p_bLoad)then
			pxAttribs^.SetValue("CurTask","Ready");									//new_attr: currently processed task in this building
			pxAttribs^.SetValue("CurProcess",100);									//new_attr: currently processing state in CurTask
			pxAttribs^.SetValue("CurProcessObj","");								//new_attr: currently processed object
		endif;
	endproc;

	export proc void UpdateDeliveries()
		if(m_bBuildingReady)then
			super.UpdateDeliveries();
		endif;
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		//don't do than in OnInit, because VirtualProduceUnit's OnInit can be called later
		if(!IsBuildMode())then
			SetReady();
		endif;
	endproc;

	proc void OnDefend(^CGameObj p_pxEnemy)
		if(cast<CWall>(this)==null)then
			ShoutForHelp(false);
		endif;
	endproc;

	proc void UpdateFOW()
		if(m_bBuildingReady)then
			var real fFOW = m_xTechTree.GetValueR(GetObjPath()+"/FOW",25.0);
			SetFOWRange(fFOW);
		else
			SetFOWRange(0.0);
		endif;
	endproc;

	export proc bool UpdateGfx()
		var bool bReturn=super.UpdateGfx();
		if(bReturn || m_axBuildUpLinks.NumEntries()==0)then
			var int i;
			for(i=0)cond(i<10)iter(i++)do
				var CFourCC xLink = "Bl_"+i.ToString();
				var vec3 vPos;
				if(GetLinkPosWorld(xLink, vPos))then
					var ^CBuilding.CBuildUpLink pxLink = ^(m_axBuildUpLinks.NewEntryRef());
					pxLink^.m_xLink = xLink;
					pxLink^.m_vPos = vPos;
				endif;
			endfor;
		endif;
		return bReturn;
	endproc;

	export proc CFourCC OccupyLink(vec3 p_vBuilderPos)

		m_axBuildUpLinks.QSort();
		var int i, iC = m_axBuildUpLinks.NumEntries();
		var CFourCC xReturn = "INVD";

		if(iC==0)then return xReturn; endif;
		var int iMaxWorker = m_axBuildUpLinks[0].m_iWorkers;
		var real fMinDist = 999999999.9;
		var int iIndex = -1;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axBuildUpLinks[i].m_iWorkers>iMaxWorker)then break; endif;
			var real fSqDist = (m_axBuildUpLinks[i].m_vPos-p_vBuilderPos).Abs2S();
			if(fSqDist<fMinDist)then
				fMinDist = fSqDist;
				iIndex = i;
			endif;
		endfor;

		if(iIndex==-1)then return xReturn; endif;

		xReturn = m_axBuildUpLinks[iIndex].m_xLink;
		m_axBuildUpLinks[iIndex].m_iWorkers++;

		return xReturn;
	endproc;

	export proc void FreeLink(CFourCC p_xLink)

		if(p_xLink=="INVD")then return; endif;
		var int iIndex = -1;
		var int i, iC = m_axBuildUpLinks.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axBuildUpLinks[i].m_xLink==p_xLink)then
				iIndex = i;
				break;
			endif;
		endfor;
		if(iIndex == -1)then return; endif;
		m_axBuildUpLinks[iIndex].m_iWorkers--;
	endproc;

/*?
	?item 	SetOwner(int p_iNewOwner)
	?desc	Sets a new Owner for this Building
	?param	p_iNewOwner		The ID of the PlayerSlot of the new Owner
?*/
	export proc void SetOwner(int p_iNewOwner)
		if (GetOwner()==p_iNewOwner) then return; endif;
		// Upadte the Ressource-Limits of the old Owner
		CBLDGMgr.Get().RemoveBuilding(this);
		if(m_bBuildingReady)then
			var ^CBasePlayer pxBasePlayer = CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.RemoveLimitCountBuilding(GetHandle());
			endif;
			CBLDGConditionsMgr.Get().DeleteBuilding(this);
		endif;

		// Call the Method of the Superclass to set a new Owner
		super.SetOwner(p_iNewOwner);

		CBLDGMgr.Get().AddBuilding(this);

		if(m_bBuildingReady)then
			var ^CBasePlayer pxBasePlayer = CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.AddLimitCountBuilding(GetHandle());
			endif;
			CBLDGConditionsMgr.Get().AddBuilding(this);
		endif;

		OnTechTreeChange();
	endproc;

/*?
	?item 	InitTimer(void)
	?desc	Initializes the Timers
?*/
	proc void InitTimers()


		if(!m_bBuildingReady)then return; endif;										// if the Build-Mode is active, return.

		//healing building timer
		if(m_bHealthBuilding && !HasTimer(FUNCTION_TIMER))then							// If this is a Healthbuilding ...
			CreateTimer(FUNCTION_TIMER,CGameTimeSpan.OneSecond()*2.0,true);		// Create a new one
			m_xLastFunctionTime=CTimeMgr.Get().GetTime();								// Update the last Timer, the Function called
		endif;

		//night mode timer
		if(!HasTimer(NIGHT_TIMER))then
			if(m_bPartyMode)then
				CreateTimer(NIGHT_TIMER,CGameTimeSpan.OneSecond()*0.2f,true);		// creates the Timer
			else
				CreateTimer(NIGHT_TIMER,CGameTimeSpan.OneSecond()*20.0f,true);		// creates the Timer
			endif;

		endif;
	endproc;

	export proc void OnWork()
		DeleteTimer(WORK_ANIM_TIMER_ID);
		CreateTimer(WORK_ANIM_TIMER_ID,CGameTimeSpan.OneSecond()*WORK_ANIM_TIMEOUT,false);
		//KLog.LogWarn("CHP","OnWork:"+GetCurrentAnimName()+" "+HasAnim(WORK_ANIM_NAME).ToString());
		if((GetCurrentAnimName()!=WORK_ANIM_NAME||GetCurrentAnimMode()!=3)&&HasAnim(WORK_ANIM_NAME)) then
			SetAnim(WORK_ANIM_NAME,3);
		endif;
	endproc;

	export proc void OnWorkFinished()
		if(HasAnim(WORK_FINISHED_ANIM_NAME)) then
			if(HasAction()) then
				SetAnim(WORK_FINISHED_ANIM_NAME,1);
			else
				AnimAction(WORK_FINISHED_ANIM_NAME);
			endif;
		else
			SetIdleAnim();
		endif;
	endproc;

	export proc void StartWorkAnim()
		if(GetCurrentAnimName()!=WORK_ANIM_NAME&&HasAnim(WORK_ANIM_NAME)) then
			SetAnim(WORK_ANIM_NAME,3);
		endif;
	endproc;

	export proc void StopWorkAnim()
		if(GetCurrentAnimName()==WORK_ANIM_NAME) then
			EndCurrentLoopAnim();
		endif;
	endproc;

	export proc int GetAggressive()
		if(!IsBuildMode())then
			return GetTechTreeAggressiv();
		else
			return -1;
		endif;
	endproc;

	//Sets whether the worker is supposed to work on that building immediately.
	export proc void SetQuickHarvest(bool p_bParam)
		m_bQuickHarvest=p_bParam;
	endproc;

	export proc bool GetQuickHarvest()
		return(m_bQuickHarvest);
	endproc;

	export proc void SetMaxBuilders(int p_iMaxBuilders)
		m_iMaxBuilders = p_iMaxBuilders;
	endproc;

	export proc ref int GetMaxBuilders()
		return m_iMaxBuilders;
	endproc;

	export proc void SetPFBlocking()
		CSrvWrap.GetPathfinder().UpdatePFBlocker(this);
	endproc;

/*?
	?item 	SetReady(void)
	?desc	Sets this building Ready. This means that the building is built
			up and ready to use.
?*/
	export proc void SetReady()
		// show feedback message if build up is finished
		begin userfeedback;
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if (!m_bBuildingReady && pxLevel!=null) then
				if(cast<CVirtualProduceUnit>(this)==null) then //no ui sound for VPU
					var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
					if (pxPlayer!=null) then
						CSrvWrap.SendGenericEvtToPlayer(pxPlayer^.GetID(), "Delivered\t"+GetClassName());
						CFeedback.Print(pxPlayer^.GetID(),  CFeedback.ECONOMY, "_NT_BldgDone\t"+GetTechTreeDesc(), GetPos());
					endif;
				endif;
			endif;
		end userfeedback;

		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("building_ready",true);
		endif;

		var bool bBuildingWasAlreadyReady=m_bBuildingReady;
		m_bBuildingReady = true;
		SetConstructLevel(4);	// Deactivates the BuildMode ...

		if(pxAttr!=null)then
			pxAttr^.SetValue("AIRelevant", true);
		endif;

		var CFourCC xFCCB;
		xFCCB="Cr_1";RemLinkGFX(xFCCB);
		xFCCB="Cr_2";RemLinkGFX(xFCCB);
		xFCCB="Cr_3";RemLinkGFX(xFCCB);
		xFCCB="Cr_4";RemLinkGFX(xFCCB);

		InitTimers();
		//Fieser dreckiger Hack /  ja da hast du völlig recht !!! //Ich kannte mal einen Hack aus Letland... //moment, war das der mit der blondine als freundin?
		/*var ^CGrowingField pxField = cast<CGrowingField>(this);
		var ^CTrap pxTrap = cast<CTrap>(this);
		if(pxField==null && pxTrap==null)then
			CSrvWrap.GetPathfinder().AddPFBlocker(this);
		endif;*/
		SetPFBlocking();

		CBLDGConditionsMgr.Get().AddBuilding(this);

		var bool bNight = !CTimeMgr.Get().IsVirtualDay();
		SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_NIGHTMODE,m_bNight);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_INIGHTMODE,!m_bNight);
		OnTechTreeChange();
		if(!bBuildingWasAlreadyReady) then
			if(cast<CVirtualProduceUnit>(this)==null) then 
				// no building ready fx for virtual produce units or during loading of level
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				if (pxLevel!=null) then
						if (!pxLevel^.IsLoading()) then
							InvokeGenericSCEvent(5,3.0f);
						endif;
					endif;
			endif;
		endif;

		var ^CBasePlayer pxBasePlayer = CBasePlayer.GetPlayer(GetOwner());
		if(pxBasePlayer!=null)then
			pxBasePlayer^.AddLimitCountBuilding(GetHandle());
		endif;

		SetIdleAnim();

		begin UpdateLinked;
			var CGuid xPar;
			if(GetGroupedParent(xPar))then
				var ^CBuilding pxBuilding=cast<CBuilding>(CSrvWrap.GetObjMgr()^.GetObjByGuid(xPar));
				if(pxBuilding!=null)then
					pxBuilding^.OnTechTreeChange();
				endif;
			endif;
		end UpdateLinked;
	endproc;

	export proc void SetReadyBuild()
		SetReady();
		CProdLog.AddEntry(GetOwner(),GetClassName());
		CGameOverMgr.Get().OnReadyBuild(this);
	endproc;


	//Returns true if building is ready
	export proc bool IsReady()
		return(m_bBuildingReady);
	endproc;

	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		m_fHealingValue = m_xTechTree.GetValueR("Objects/"+GetPlayerTribeName()+"/InventObjects/Healing/value",1.0);
		var int i,iC=p_rasChanges.NumEntries();
		var bool bUpdateLimits = false;
		for(i=0) cond(i<iC) iter(i++) do
			if(p_rasChanges[i].Find("/UpdateLimits/max_")>0)then
				bUpdateLimits=true;
			endif;
		endfor;

		if(bUpdateLimits) then
			var ^CBasePlayer pxBasePlayer = CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				pxBasePlayer^.UpdateLimits(false);
			endif;
		endif;
	endproc;

	export proc void SetTrapped(CObjHndl p_xTrapHndl)
		if(!m_bBuildingReady)then return; endif;
		super.SetTrapped(p_xTrapHndl);
	endproc;

	export proc void SetTrapped(bool p_bTrapped)
		if(!m_bBuildingReady)then return; endif;
		super.SetTrapped(p_bTrapped);
	endproc;

	export proc void SetTrapped(real p_fDuration)
		if(!m_bBuildingReady)then return; endif;
		super.SetTrapped(p_fDuration);
	endproc;

	export proc void UpdateTechTree()
	endproc;
/*
	export proc real GetTechTreeHitpoints()
		var real fOwnMaxHitpoints=super.GetTechTreeHitpoints();

		var int i,iC=GetMaxGroupedChildSlots();
		for(i=0)cond(i<iC)iter(i++)do
			var CGuid xWalk;
			if(GetGroupedChild(i,xWalk))then
				var ^CBuilding pxB=cast<CBuilding>(CSrvWrap.GetObjMgr()^.GetObjByGuid(xWalk));
				if(pxB!=null)then
					fOwnMaxHitpoints+=pxB^.GetTechTreeHitpoints();
				endif;
			endif;
		endfor;
		return fOwnMaxHitpoints;
	endproc;
*/
	proc void SetStoneDelivery(bool p_bStone)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bStoneDelivery = p_bStone;
		pxAttr^.SetValue("stoneDelivery",p_bStone);
	endproc;

	proc void SetWoodDelivery(bool p_bWood)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bWoodDelivery = p_bWood;
		pxAttr^.SetValue("woodDelivery",p_bWood);
	endproc;

	proc void SetFoodDelivery(bool p_bFood)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bFoodDelivery = p_bFood;
		pxAttr^.SetValue("foodDelivery",p_bFood);
	endproc;

	proc void SetIronDelivery(bool p_bIron)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bIronDelivery = p_bIron;
		pxAttr^.SetValue("ironDelivery",p_bIron);
	endproc;

	proc void SetResinDelivery(bool p_bResin)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bResinDelivery = p_bResin;
		pxAttr^.SetValue("resinDelivery",p_bResin);
	endproc;

	proc void SetBoneDelivery(bool p_bBone)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bBoneDelivery = p_bBone;
		pxAttr^.SetValue("boneDelivery",p_bBone);
	endproc;

	proc void SetHideDelivery(bool p_bHide)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;
		m_bHideDelivery = p_bHide;
		pxAttr^.SetValue("hideDelivery",p_bHide);
	endproc;

	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		//dont defend
		return false;
	endproc;

	//////////////////////// IDLE STATE ////////////////////////////////
	export proc void OnIdleEnter(^CState p_pxFrom, ^CState p_pxTo)
		SetIdleAnim();
		super.OnIdleEnter(p_pxFrom,p_pxTo);
	endproc;

	export proc void OnIdleTick(int p_iTime)
		super.OnIdleTick(p_iTime);
	endproc;

	export proc void OnIdleLeave(^CState p_pxFrom, ^CState p_pxTo)
		super.OnIdleLeave(p_pxFrom,p_pxTo);
	endproc;

	export proc void SetIdleAnim()
		if(HasAnim("standanim"))then
			if(GetCurrentAnimName()!="standanim")then
				SetAnim("standanim",3);
			endif;
		elseif(HasAnim("work"))then
			if(GetCurrentAnimName()!="work")then
				SetAnim("work",1);
			else
				EndCurrentLoopAnim();
			endif;
		elseif(HasAnim("deliver"))then
			if(GetCurrentAnimName()!="deliver")then
				SetAnim("deliver",1);
			else
				EndCurrentLoopAnim();
			endif;
		endif;
	endproc;

	///////////////////////////////////////////////////////////////////

/*?
	?item 	DoBuildFunction(void)
	?desc	Processes the autmatic Function of this Building. This can be
			Health.
?*/
	proc void DoBuildingFunction()

		//TODO: use regions instead of CObjQuery

		if (!m_bBuildingReady) then return; endif;
		if (!m_bHealthBuilding)then return; endif;			// If this Building do not have such a Function return.
		var CGameTime xNow=CTimeMgr.Get().GetTime();						// Gets th ecurrent GameTime ...
		var CGameTimeSpan xDT=xNow-m_xLastFunctionTime;					// ... and sets the DeltaTime between now and the last call.
		var real fTime = xDT.GetSecondsF();
		if (fTime==0.0) then return; endif;
		m_xLastFunctionTime=xNow;
		var CObjList xUnits;

		CSrvWrap.GetDiplomacyMgr().AddMyFriendsToSearch(GetOwner(), m_xFunctionUnits);
		m_xFunctionUnits.RegionCircle(GetPos(),GetHealingRadius());					// ... this is the Function Radius ...

		if(!m_xFunctionUnits.Execute(xUnits))then return; endif;				// Process the Execute-Methode and return on fail.
		var int i,iC=xUnits.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do										// Loop through all units in radius ...
	    	var ^CFightingObj pxFWalk=cast<CFightingObj>(xUnits[i].GetObj());
	    	if(pxFWalk!=null)then
	    		var real fValue = fTime*GetHealingAmount(pxFWalk);
				pxFWalk^.HealMe(fValue);//		... change the hitpoints.
			endif;
		endfor;
	endproc;


	export proc void SetUnlimitedBuilding(bool p_bState)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			if(p_bState)then
				pxAttr^.SetValue("UnlimitedBuilding",1);
			else
				pxAttr^.SetValue("UnlimitedBuilding",0);
			endif;
		endif;
	endproc;

	export proc void SetConvertBuilding(bool p_bState)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			if(p_bState)then
				pxAttr^.SetValue("ConvertBuilding",1);
			else
				pxAttr^.SetValue("ConvertBuilding",0);
			endif;
		endif;
	endproc;

	export proc void SetInventSite(bool p_bState)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			if(p_bState)then
				pxAttr^.SetValue("IsInventSite",1);
			else
				pxAttr^.SetValue("IsInventSite",0);
			endif;
		endif;
	endproc;

	export proc void Action(string p_sTTPath)
		if(p_sTTPath.Find("Kill")!=-1)then
			DiePerHarakiri();
			return;
		endif;
		//L KLog.LogWarn("CaOr","Action "+p_sTTPath);
		var CObjHndl xPyCO;
		var CAction.CResourceCosts xCosts;
		if(CRequirementsMgr.Get().CheckConditionsAndPay(this, p_sTTPath, xPyCO, xCosts))then
			//L KLog.LogWarn("CaOr","Check ok");
			// Create a Invent-Task
			var ^CAction pxTask= cast<CAction>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Action"));
			pxTask^.Init(GetHandle(),p_sTTPath,xCosts);
			pxTask^.SetPyCO(xPyCO);
			AddTask(pxTask, true);
		else
			//L KLog.LogWarn("CaOr","Check fail");
	    endif;
    endproc;

	export proc void CancelAction(string p_sTTPath)
		if(m_pxTaskMgr!=null)then
			m_pxTaskMgr^.RemoveAction(p_sTTPath);
		endif;
	endproc;

/*?
	?item 	Die(void)
	?desc	Set the Die-Task
?*/

	export proc void Delete()
		if(!CreateBuildingCorpse())then
			if(cast<CWall>(this)==null && cast<CVirtualProduceUnit>(this)==null && m_bBuildingReady)then
				var ^CBuildingCorpse pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
				if(pxGameObj!=null)then
					//pxGameObj^.SetConstructLevel(6);
					//KLog.LogSpam("MaZi", GetClassName()+" / "+GetGfxName());
					pxGameObj^.SetSource(this);
					pxGameObj^.Init(GetGfxName(), GetName(), 8.0, GetAge());
				endif;
			endif;
		endif;
		super.Delete();
	endproc;

/*?
	?item 	BuildUp(string p_sClass)
	?desc	Set the BuildUp-Task. The Building has to be build.
	?param	p_sClass		Classname of the Object to build.
?*/
/*	proc void BuildUp(string p_sClass)
		SetConstructLevel(0);
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","BuildUp");
			pxAttr^.SetValue("CurProcess",0);
		endif;
	endproc;
*/
	proc void BuildUp(string p_sPath)
		SetConstructLevel(0);

		var CFourCC xFCCB;
		var string sTribe=GetTribeName();
		//if (sTribe!="Ninigi") then   // Ninigi Cranes are still missing 08.02.05 RT#10806
			xFCCB="Cr_1";if(HasLink(xFCCB)) then SetLinkGFX(xFCCB,sTribe+"_Crane_01","none"); endif;
			xFCCB="Cr_2";if(HasLink(xFCCB)) then SetLinkGFX(xFCCB,sTribe+"_Crane_01","none"); endif;
			xFCCB="Cr_3";if(HasLink(xFCCB)) then SetLinkGFX(xFCCB,sTribe+"_Crane_02","none"); endif;
			xFCCB="Cr_4";if(HasLink(xFCCB)) then SetLinkGFX(xFCCB,sTribe+"_Crane_02","none"); endif;
		//endif;

		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("CurTask","BuildUp");
			pxAttr^.SetValue("CurProcess",0);
		endif;
    	var ^CBuildUpBuilding pxTask=cast<CBuildUpBuilding>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BuildUpB"));
    	pxTask^.Init(GetHandle(), p_sPath);
		m_pxTaskMgr^.SetTask(pxTask);
	endproc;

	proc void BuildDown(string p_sPath)
		if(m_pxTaskMgr==null)then return; endif;
		var int i,iC=m_pxTaskMgr^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CBuildDownBuilding pxBldDown=cast<CBuildDownBuilding>(m_pxTaskMgr^.GetSubState(i));
			if(pxBldDown!=null)then
				return;
			endif;
		endfor;
    	var ^CBuildDownBuilding pxTask=cast<CBuildDownBuilding>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BldDownB"));
    	pxTask^.Init(GetHandle(),p_sPath);
		AddTask(pxTask,true);
	endproc;

/*?
	?item 	HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
	?desc 	This Method Handles the recieved GamePlayCommands.
	?param	p_sCommand		a string describing the Command
	?param	p_pxObject		a possibility to pass a CGameObj to this Function
	?param	p_vPos			a possibility to pass a Position to this Function
	?param	p_sMiscParam	a string containing whatever you want and need
?*/
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		//L KLog.LogWarn("CaOr","GPCmd "+p_sCommand);
		if(p_sCommand=="Delete")then
			Delete();
		elseif(p_sCommand=="Action")then
			if(p_sMiscParams.Find("BuildDown")!=-1)then
				BuildDown(p_sMiscParams);
			elseif(p_sMiscParams.Find("/Attack")==-1 && p_sMiscParams.Find("/Walk")==-1 && p_sMiscParams.Find("/Stop")==-1 && p_sMiscParams.Find("/LevelUp")==-1 && p_sMiscParams.Find("/Kill")==-1)then
				Action(p_sMiscParams);
			else
				super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
			endif;
		elseif(p_sCommand == "BuildUp")then
			BuildUp(p_sMiscParams);
		elseif(p_sCommand == "Cancel")then
			CancelAction(p_sMiscParams);
		else
			super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;

/*?
	?item	HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
	?desc	Handles the incoming Events
	?param	p_rxEvtPtr		Reference to the recieved Event
?*/
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()=="BuildUp")then
			//BuildUp(p_rxEvtPtr.GetString());
			//L KLog.LogSpam("BuildUp","BuildUp(1)");
			BuildUp("");
		elseif(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==196)then
				var bool bNight = !CTimeMgr.Get().IsVirtualDay();
				if(m_bPartyMode)then bNight=!m_bNight; endif;
				if(m_bNight != bNight)then
					m_bNight=bNight;
					SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_NIGHTMODE,m_bNight);
					SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_INIGHTMODE,!m_bNight);
				endif;
			elseif(p_rxEvtPtr.GetInt(0)==FUNCTION_TIMER)then
				DoBuildingFunction();
			elseif(p_rxEvtPtr.GetInt(0)==WORK_ANIM_TIMER_ID)then
				StopWorkAnim();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_EXPLOSION)then
				DeleteTimer(TIMER_EXPLOSION);
				Delete();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

/*?
	?item	PlayDieAnim(void)
	?desc	Starts the Die-Animation
?*/
	export proc void PlayDieAnim()
    	AnimAction("dying");
    endproc;
/*?
	?item	GetDamageValue(void)
	?desc	Returns the DamageValue.
?*/
	export proc real GetDamageValue()
    	var	real fDamageValue=20.0f;
    	return fDamageValue;
    endproc;

	export proc void UpdateMods()
		if(m_bBuildingReady)then
			var ^CBasePlayer pxBasePlayer = CBasePlayer.GetPlayer(GetOwner());
			if(pxBasePlayer!=null)then
				//pxBasePlayer^.UpdateLimits(false);
			endif;
		endif;
	endproc;

	export proc bool CanDeliver(string p_sTTPath)
		if(!CRequirementsMgr.Get().CheckFreeSlotNonVirtual(GetOwner(),p_sTTPath))then
			return false;
		endif;
		return true;
	endproc;

	export proc bool CalculateDelivery(string p_sProduct)
		if(p_sProduct=="CHTR")then
			var CObjQuery xZeroSearch;
			var CObjList xZeroers;
			xZeroSearch.SetType("CHTR");
			xZeroSearch.SetOwner(GetOwner());
			xZeroSearch.SetAttribsPos("level",0);
			xZeroSearch.Execute(xZeroers);
			if(xZeroers.NumEntries()<32)then
				SetDeliveryAllowed(true);
			endif;
		endif;
		return(true);
	endproc;

	export proc bool SetDeliveryAllowed(bool p_bAllowed)
		m_bDeliverProduct=p_bAllowed;
		return(true);
	endproc;

	export proc bool GetDeliveryAllowed()
		return(m_bDeliverProduct);
	endproc;

	export proc void UpdateHitpoints()
		super.UpdateHitpoints();
		m_xRepairDesc.Update();
	endproc;

	export proc bool Repair(real p_fValue)
		if(GetHitpoints()+p_fValue<=m_fMaxHitpoints)then
			SetHitpoints(GetHitpoints()+p_fValue);
			return m_xRepairDesc.PayForRepair(p_fValue);
		else
			SetHitpoints(m_fMaxHitpoints);
			m_xRepairDesc.PayForRepair(p_fValue);
			return false;
		endif;
	endproc;

endclass;

class CNoFreeBorderBlockerBuilding inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
	endproc;
endclass;

class CRallyBuilding inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;
endclass;

//Hu: Hu_Stone_Cottage
//Aje: Aje_Tent
//Ninigi: ??
class CSmallestHouse inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;

	/*export proc void Die()
		if(!m_bDead && GetGfxName()=="Aje_Big_Tent")then
			var ^CBuildingCorpse pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				//pxGameObj^.SetConstructLevel(6);
				pxGameObj^.Init("Aje_Big_Tent", GetName(), 20.0);
			endif;
		endif;
		super.Die();
	endproc;*/

endclass;

//Hu: Hu_Small_House
//Aje: Aje_Small_House
//Ninigi: Ninigi_Small_House_S1
class CMediumHouse inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;
endclass;

//Hu: Hu_Large_House
//Aje: ??
//Ninigi: ??
class CLargeHouse inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;
endclass;

class CTurret inherit CGameObj
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad) then
			SetType("TRRT");
			InitAttribs();
		endif;
	endproc;

	export proc void AddHitpoints(real p_fH)
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			var real fH = pxAttr^.GetValueFloat("hitpoints");
			pxAttr^.SetValue("hitpoints", fH+p_fH);
		endif;
	endproc;

	export proc void Delete()
		TerminateAction();
		super.Delete();
	endproc;

endclass;

class CSeasBigCannon inherit CTower

	var CObjHndl m_xBirdie;
	var bool m_bActivated;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			m_bActivated=false;
			SetTurretLink("we");
			SetTurret("seas_hq_big_cannon_rotator");
			m_sTurretAttackAnim="attack_front";
		endif;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SBig")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xBirdie.DoKArc(pxArc^);
			pxArc^ << m_bActivated;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SBig";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xBirdie.DoKArc(pxArc^);
		pxArc^ << m_bActivated;
		pxWalk^.Close();
	endproc;

	export proc void AbortTask()
		if(!m_bActivated)then
			m_bActivated=true;
			var ^CGameObj pxO=CSrvWrap.GetObjMgr()^.CreateObj("seas_hq_big_cannon_cannon", GetOwner());
			AddGroupedChildren(pxO^.GetGuid());
			var CFourCC xLink="we";
			pxO^.LinkAction(m_xTurret,xLink);
			m_xBirdie=pxO^.GetHandle();
		endif;
	endproc;

	export proc bool CreateBuildingCorpse()
		var ^CBuildingCorpse pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(m_xTurret.GetObj());
			pxGameObj^.Init("seas_hq_big_cannon_rotator", GetName(), 8.0, GetAge());
			if(m_xTurret.IsValid())then
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
				m_xTurret.GetObj()^.Delete();
			endif;
		endif;
		pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init("seas_hq_big_cannon", GetName(), 8.0, GetAge());
		endif;
		return true;
	endproc;

	export proc void Delete()
		if(m_xBirdie.IsValid())then m_xBirdie.GetObj()^.Delete(); endif;
		super.Delete();
	endproc;

	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(!m_bActivated)then return false; endif;
		var bool bReturned=super.AttackEnemy(p_pxEnemy,p_vTarget,p_rbRotated);
		var ^CGameObj pxBuildUp=m_xBirdie.GetObj();
		if(pxBuildUp!=null && !p_rbRotated)then
			pxBuildUp^.SetAnim("attack_front",1);
		endif;
		return bReturned;
	endproc;
endclass;

class CRocketRamp inherit CTower

	var CObjHndl m_xBirdie;

	export proc void OnInit(bool p_bLoad)
		SetTurretLink("RE_1");
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetTurret("ninigi_rb_top");
			m_sTurretAttackAnim="attack_front";
			var ^CBirdieBuildUp pxO=cast<CBirdieBuildUp>(CSrvWrap.GetObjMgr()^.CreateObj("ninigi_rb_bird", GetOwner()));
			AddGroupedChildren(pxO^.GetGuid());
			var CFourCC xLink="we";
			pxO^.LinkAction(m_xTurret,xLink);
			m_xBirdie=pxO^.GetHandle();
			pxO^.StartIdleAnims("");
		endif;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="RoRa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xBirdie.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="RoRa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xBirdie.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
	endproc;

	export proc void AddHitpoints(real p_fH)
		super.AddHitpoints(p_fH);
		if(m_xTurret.IsValid()) then
			var ^CTurret pxT = cast<CTurret>(m_xTurret.GetObj());
			if(pxT!=null) then
				pxT^.AddHitpoints(p_fH);
			endif;
		endif;
	endproc;

	export proc bool CreateBuildingCorpse()
		var ^CBuildingCorpse pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(m_xTurret.GetObj());
			pxGameObj^.Init("ninigi_rb_top", GetName(), 8.0, GetAge());
			if(m_xTurret.IsValid())then
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
			endif;
		endif;
		pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(m_xBirdie.GetObj());
			pxGameObj^.Init("ninigi_rb_bird", GetName(), 8.0, GetAge());
			if(m_xTurret.IsValid())then
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
			endif;
		endif;
		pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
		if(pxGameObj!=null)then
			pxGameObj^.SetSource(this);
			pxGameObj^.Init("ninigi_rocket_ramp", GetName(), 8.0, GetAge());
		endif;
		return true;
	endproc;

	export proc void Delete()
		if(m_xBirdie.IsValid())then m_xBirdie.GetObj()^.Delete(); endif;
		super.Delete();
	endproc;

	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		var bool bReturned=super.AttackEnemy(p_pxEnemy,p_vTarget,p_rbRotated);
		var ^CBirdieBuildUp pxBuildUp=cast<CBirdieBuildUp>(m_xBirdie.GetObj());
		if(pxBuildUp!=null && !p_rbRotated)then
			pxBuildUp^.AttackEnemy();
		endif;
		return bReturned;
	endproc;
endclass;

class CBirdieBuildUp inherit CProduct

	const int TIMER_IDLEANIMS=103;
	var array string m_asIdleAnims;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_001");
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_002");
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_003");
		m_asIdleAnims.AddEntry("ninigi_rb_bird_idle_004");
	endproc;

	export proc void StartIdleAnims(string p_sAnim)
		if(HasTimer(TIMER_IDLEANIMS))then
			DeleteTimer(TIMER_IDLEANIMS);
		endif;
		NextAnim(p_sAnim);
	endproc;

	export proc void NextAnim(string p_sForceAnim)
		var real fDuration=3.0;
		if(p_sForceAnim.IsEmpty())then
			var int iRandom=Random.GetInt()%4;
			if(HasAnim(m_asIdleAnims[iRandom]))then
				SetAnim(m_asIdleAnims[iRandom],1);
				fDuration=GetCurrentAnimLength();
			endif;
		else
			fDuration=6.0;
			if(HasAnim(p_sForceAnim))then
				SetAnim(p_sForceAnim,1);
				fDuration=GetCurrentAnimLength();
			endif;
		endif;
		CreateTimer(TIMER_IDLEANIMS,CGameTimeSpan.OneSecond()*fDuration,false);
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		super.HandleEvent(p_rxEvtPtr);
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_IDLEANIMS)then
				DeleteTimer(TIMER_IDLEANIMS);
				NextAnim("");
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	export proc void AttackEnemy()
		StartIdleAnims("ninigi_rb_bird_shoot");
	endproc;

endclass;

class CNinigiSmallTower inherit CTower

	export proc void OnInit(bool p_bLoad)
		SetTurretLink("we");
		super.OnInit(p_bLoad);
	endproc;


	export proc void UpdateGfxFlags()
		if(!m_xTurret.IsValid()&&m_xTechTree.GetValueB("/Objects/Ninigi/InventObjects/tower_sordes_upgrade/invented",false))then
			SetTurret("ninigi_small_tower_upgrade");
		endif;
	endproc;

endclass;


//Hu: Hu_Tower
//Aje: ??
//Ninigi: ??
class CTower inherit CBuilding

	var CObjHndl	m_xTurret;
	var string		m_sTurretAttackAnim;
	var CFourCC		m_xTurretLink;


	export constructor()
		m_xTurretLink = "Proj";
	endconstructor;

	export proc vec3 GetProjectileStartPos()

		if(!m_xTurret.IsValid())then return super.GetProjectileStartPos(); endif;

		var vec3 vBuildUpBasePos;
		var vec3 vProjectilePos;

		var CFourCC xProjectileLink = "Proj";

		if(!GetLinkPosWorld(m_xTurretLink, vBuildUpBasePos))then return super.GetProjectileStartPos(); endif;

		var ^CGameObj pxObj = m_xTurret.GetObj();
		if(pxObj==null)then return super.GetProjectileStartPos(); endif;

		if(!pxObj^.GetLinkPosWorld(xProjectileLink, vProjectilePos))then return super.GetProjectileStartPos(); endif;

		vProjectilePos = vProjectilePos-vBuildUpBasePos;

		var Quat qAdditionalRot = pxObj^.GetAdditionalRot();

		qAdditionalRot.VecRotateU(vProjectilePos);

		return (vBuildUpBasePos+vProjectilePos);

	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
		UpdateAggressive();

		if(!p_bLoad)then
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("AttackBuilding", true);
			endif;
			SetCanFightAttrib(true);
			if(GetClassName()=="hu_large_tower")then
				CreatePersonalProduceUnit();
			endif;
		endif;
		m_sTurretAttackAnim = "attack_front";
		SetWallMapObj(true);
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		var ^CGameObj pxO = m_xTurret.GetObj();
		if(pxO!=null)then
			pxO^.LinkAction(GetHandle(), m_xTurretLink);
		endif;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ToBa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xTurret.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()>=2)then
				var string sLink;
				(pxArc^) << sLink;
				m_xTurretLink = sLink;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ToBa"; //Tower base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xTurret.DoKArc(pxArc^);
		var string sLink = m_xTurretLink.AsString();
		(pxArc^) << sLink;
		pxWalk^.Close();
	endproc;

	proc void SetTurretLink(string p_sLink)
		m_xTurretLink = p_sLink;
	endproc;

	destructor()
		if(m_xTurret.IsValid()) then
			m_xTurret.GetObj()^.Delete();
		endif;
	enddestructor;

	proc void BuildDown(string p_sPath)
		if(m_pxTaskMgr==null)then return; endif;
		var int i,iC=m_pxTaskMgr^.NumSubs();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CBuildDownBuilding pxBldDown=cast<CBuildDownBuilding>(m_pxTaskMgr^.GetSubState(i));
			if(pxBldDown!=null)then
				return;
			endif;
		endfor;
    	var ^CBuildDownBuilding pxTask=cast<CBuildDownBuilding>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"BldDownB"));
    	pxTask^.Init(GetHandle(),p_sPath);
		AddTask(pxTask,false);
	endproc;

	export proc void Action(string p_sTTPath)
		var ^CVirtualProduceUnit pxProduceUnit = cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxProduceUnit==null)then
			super.Action(p_sTTPath);
		else
			pxProduceUnit^.Action(p_sTTPath);
		endif;

	endproc;

	///////
	//	Fight()
	///////
	export proc void Fight(^CGameObj p_pxTarget, vec3 p_vPos, bool p_bUserCommand)

		if(!m_bBuildingReady)then return; endif;
		var ^CBuildDownBuilding pxBldDown = cast<CBuildDownBuilding>(GetCurTask());
		if(pxBldDown!=null)then return; endif;
		super.Fight(p_pxTarget, p_vPos, p_bUserCommand);

    endproc;

	export proc CObjHndl GetTurret()
		return(m_xTurret);
	endproc;

	export proc void SetTurret(string p_sObjName)
		if (m_xTurret.IsValid())then
			m_xTurret.GetObj()^.Delete();
		endif;

		if (p_sObjName.IsEmpty()) then return; endif;

		var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj(p_sObjName, GetOwner());
		if(pxO==null)then return();endif;
		pxO^.LinkAction(GetHandle(), m_xTurretLink);
		m_xTurret = pxO^.GetHandle();
		AddGroupedChildren(pxO^.GetGuid());
		var ^CAttribs pxA = pxO^.GetAttribs();
		if(pxA!=null) then
			pxA^.SetValue("maxhitpoints", GetAttribs()^.GetValueFloat("maxhitpoints"));
			pxA^.SetValue("hitpoints", GetAttribs()^.GetValueFloat("hitpoints"));
		endif;
	endproc;

	proc void OnDefend(^CGameObj p_pxEnemy)
		if(m_bBuildingReady)then
			//L KLog.LogInfo("Fight",GetName()+" defends himself!");
			if(p_pxEnemy!=null)then
				HandleGamePlayCommand("Action",p_pxEnemy, p_pxEnemy^.GetPos(), "/AttackSrv");
			endif;
		endif;
	endproc;

	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(IsBuildMode())then return false; endif;
		if(GetProjectile()!="") then
			if (m_xTurret.IsValid()) then
				var ^CGameObj pxWO = m_xTurret.GetObj();
				var vec3 vCurDir = {0.0,1.0,0.0};
				pxWO^.GetRot().VecRotateU(vCurDir);
				var vec3 vCur = vCurDir;
				pxWO^.GetAdditionalRot().VecRotateU(vCur);

				var vec3 vAEDir;
				if(p_pxEnemy!=null)then
					vAEDir = (p_pxEnemy^.GetPos() - GetPos());
				else
					vAEDir = (p_vTarget - GetPos());
				endif;

				var Quat qOld; qOld.FromXYDir(vCur.GetX(), vCur.GetY());
				var Quat qR; qR.FromXYDir(vAEDir.GetX(), vAEDir.GetY());

				var real fD = (qR - qOld).Abs();//(vAEDir-vCur).Abs();
				if (pxWO^.GetSecActionDesc()=="CAct" && (fD > 0.0001f || fD < -0.0001f)) then
					qR /= pxWO^.GetRot();
					pxWO^.SecRotAction(qR, 0.8f);
					p_rbRotated=true;
					ResetHitDone();
					return false;
				endif;
			endif;
			CreateProjectileAndShoot(p_pxEnemy, p_vTarget);
			if(GetFightAnim()!="" && HasAnim(GetFightAnim()))then
				SetAnim(GetFightAnim(),1);
			endif;
			if(!m_sTurretAttackAnim.IsEmpty() && m_xTurret.IsValid()) then
				m_xTurret.GetObj()^.SetAnim(m_sTurretAttackAnim, 1);
			endif;
			return false;
		endif;
		return false;
	endproc;

	export proc void SetReady()
		super.SetReady();
  		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
  		pxWM^.SetReady(GetHandle());
	endproc;

	export proc void Delete()
		var int i,iC=GetMaxGroupedChildSlots();
		for(i=0)cond(i<iC)iter(i++)do
			RemGroupedChildren(i);
		endfor;
		super.Delete();
	endproc;

	export proc void UpdateGfxFlags()
		if(GetClassName()=="hu_large_tower")then
			m_xTurretLink = "we";
			if(!m_xTurret.IsValid() && m_xTechTree.GetValueB("/Objects/Hu/InventObjects/hu_ballista_upgrade/invented",false))then
				if(m_bBuildingReady) then
					SetTurret("Hu_Large_Tower_Upgrade_Balista");
				endif;
			endif;
		endif;
	endproc;

	export proc bool IsAbleToFight()
  		if(m_pxTaskMgr^.GetCurTaskName()=="BuildUpB") then
  			return false;
  		endif;
  		return true;
  	endproc;


	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;
	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		m_fHealingValue = m_xTechTree.GetValueR("Objects/"+GetPlayerTribeName()+"/InventObjects/Healing/value",1.0);
	endproc;

	export proc void SetConstructLevel(int p_iLvl)
		super.SetConstructLevel(p_iLvl);
		if(m_xTurret.IsValid()) then
			m_xTurret.GetObj()^.SetConstructLevel(p_iLvl);
		endif;
	endproc;

	export proc void SetDestructLevel(int p_iLvl)
		super.SetDestructLevel(p_iLvl);
		if(m_xTurret.IsValid()) then
			m_xTurret.GetObj()^.SetDestructLevel(p_iLvl);
		endif;
	endproc;

	export proc bool CreateBuildingCorpse()
		if(m_bBuildingReady && m_xTurret.IsValid())then
			var ^CBuildingCorpse pxGameObj = cast<CBuildingCorpse>(CSrvWrap.GetObjMgr()^.CreateObj("BuildingCorpse",GetOwner(),GetPos(),GetRotation()));
			if(pxGameObj!=null)then
				pxGameObj^.SetSource(m_xTurret.GetObj());
				pxGameObj^.Init(m_xTurret.GetObj()^.GetGfxName(), GetName(), 8.0, GetAge());
				pxGameObj^.SetRot(m_xTurret.GetObj()^.GetRot());
				pxGameObj^.SecRotAction(m_xTurret.GetObj()^.GetAdditionalRot(),0.0);
			endif;
		endif;
		return false;
	endproc;

endclass;

class CStealthBuilding inherit CBuilding

	var real			m_fRadius;
	var bool			m_bActive;

	var array string	m_asHidingTypes;

	export constructor()
		m_asHidingTypes=1;
		m_asHidingTypes[0]="BLDG";
	endconstructor;

	proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_fRadius=35.0;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("RangeMarker","Smoking/"+(m_fRadius+2.5f).ToInt().ToString()+";");
		endif;

		if(!p_bLoad)then
			SetCanFightAttrib(false);
		endif;

		m_xSink.m_xOnObjAdd = OnObjAdd;
		m_xSink.m_xOnObjRem = OnObjRem;
	endproc;


	export proc void SetReady()
		super.SetReady();
		if(!HasPersonalRegion())then
			var vec3 vP;vP.SetXYZ(m_fRadius,m_fRadius,0.0f);
			CreatePersonalRegion("SmokerRegion_"+Random.GetInt().ToString(), vP, 010b);
			AddRangedBuff("owner_invisibility_bldg");
		endif;
	endproc;


	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="STba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^ << xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	proc bool OnObjAdd(CObjHndl p_xObj)

		if (GetHandle()==p_xObj) then return false; endif;

		if(m_xRegionObjects.FindEntry(p_xObj)!=-1)then return false; endif;

		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());

		if(pxFO==null)then return false; endif;
		if(pxFO^.GetOwner()!=GetOwner())then return false; endif;
		if(m_asHidingTypes.FindEntry(pxFO^.GetType().AsString())==-1)then return false; endif;
		if(pxFO^.GetClassName() == GetClassName())then return false; endif;
		if(cast<CWarpGate>(pxFO)!=null)then return false; endif;
		if(cast<CDefenderObj>(pxFO)!=null)then return false; endif;

		m_xRegionObjects.Include(p_xObj);

		pxFO^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS, true);
		pxFO^.AddRangedBuff("is_invisible");

		var ^CTower pxTower=cast<CTower>(p_xObj.GetObj());
		if(pxTower!=null)then
			var CObjHndl xTurret=pxTower^.GetTurret();
			if(xTurret.IsValid())then
				var ^CFightingObj pxTmp=cast<CFightingObj>(xTurret.GetObj());
				if(pxTmp!=null)then
					pxTmp^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS, true);
					pxTmp^.AddRangedBuff("is_invisible");
				endif;
			endif;
		endif;
		return true;
	endproc;

	proc bool OnObjRem(CObjHndl p_xObj)
		if(m_xRegionObjects.FindEntry(p_xObj)==-1)then return false; endif;

		m_xRegionObjects.RemEntry(p_xObj);

		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO==null)then return false; endif;

		pxFO^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS, false);
		if(!pxFO^.GetCamouflage())then
			pxFO^.RemoveRangedBuff("is_invisible");
	
			var ^CTower pxTower=cast<CTower>(p_xObj.GetObj());
			if(pxTower!=null)then
				var CObjHndl xTurret=pxTower^.GetTurret();
				if(xTurret.IsValid())then
					var ^CFightingObj pxTmp=cast<CFightingObj>(xTurret.GetObj());
					if(pxTmp!=null)then
						pxTmp^.SetEffectFlag(CFightingObj.EFFECT_SMOKER_INVIS,false);
						pxTmp^.RemoveRangedBuff("is_invisible");
					endif;
				endif;
			endif;
		endif;
		return true;
	endproc;

endclass;

class CSeasTurretTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);

		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("seas_turret");
			m_sTurretAttackAnim = "attack_front";
		endif;
	endproc;
endclass;

class CSeasMGTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);

		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("seas_hq_machinegun_nest_top");
			m_sTurretAttackAnim = "attack_front";
		endif;
	endproc;
endclass;

class CSeasDefenseTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);

		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("seas_hq_defense_turret_top");
			m_sTurretAttackAnim = "attack_front";
		endif;
	endproc;
endclass;

class CSeasSteelwork inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;

	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
	endproc;

endclass;

class CTeslaTower inherit CTower
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);

		if(!p_bLoad)then
			SetTurretLink("we");
			SetTurret("aje_tesla_tower_canon");
		endif;
		m_sTurretAttackAnim = "gun_shoot";
	endproc;

endclass;

class CTradingOrder
	export var int m_iSellIndex;
	export var int m_iBuyIndex;
	export var int m_iSellAmount;
	export var int m_iBuyAmount;
endclass;

//Hu: Hu_Warehouse
//Aje: Aje_Storehouse
//Ninigi: ??
class CWarehouse inherit CRallyBuilding

	var bool			m_bMarketplace;
	var array string	m_asResources;
	var array real		m_afChangeValues;

	var array CTradingOrder	m_axTradingOrders;

	constructor()		
	endconstructor;

	destructor()
		/*var ^CFlyingTrader pxTrader = CFlyingTraderMgr.GetFlyingTrader();
		if (pxTrader!=null) then
			pxTrader^.DeRegisterTradeBuilding(this);
		endif;*/
	enddestructor;

	export proc void OnInit(bool p_bLoad)
		m_bMarketplace = false;
		super.OnInit(p_bLoad);
		
		m_afChangeValues=0;
		m_afChangeValues.AddEntry(1.0);	//food
		m_afChangeValues.AddEntry(1.0);	//wood
		m_afChangeValues.AddEntry(1.0);	//stone
		var CPropDB xDB;
		if(xDB.Load(CSrvWrap.GetUrsRelPath()+"/Data/Base/Scripts/Server/settings/NewPointBuyCosts.txt"))then
			var ^CPropDB.CNode pxResources=xDB.FindNode("Resources",false);
			if(pxResources!=null)then
				var ^CPropDB.CNode pxTribe=pxResources^.Get(GetTribeName());
				if(pxTribe!=null)then
					m_afChangeValues[0]=pxTribe^.GetValueR("food",1.0);
					m_afChangeValues[1]=pxTribe^.GetValueR("wood",1.0);
					m_afChangeValues[2]=pxTribe^.GetValueR("stone",1.0);
				endif;
			endif;
		endif;
		
		ExamineFlags();

	endproc;

	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr != null)then
			pxAttr^.SetValue("TradeBuilding",1);
		endif;
	endproc;

	export proc void AcceptTrader()
		if(!m_bMarketplace)then return; endif;
		if(!HasAnim("open_gate"))then return; endif;
		InvokeGenericSCEvent(24,4.0f);
	endproc;

	export proc void ExamineFlags()
		if (GetTribeName()=="Hu") then
			if(!m_bMarketplace && m_xTechTree.GetValueI(GetObjPath()+"/flags/hu_marketplace",0)!=0)then
				SetMarketplace(true);
				SetRallySite(true);
			endif;
		elseif (GetTribeName()=="Aje") then
			if(!m_bMarketplace && m_xTechTree.GetValueI(GetObjPath()+"/flags/aje_bazaar",0)!=0)then
				SetMarketplace(true);
				SetRallySite(true);
			endif;
		elseif (GetTribeName()=="Ninigi") then
			if(!m_bMarketplace && m_xTechTree.GetValueI(GetObjPath()+"/flags/ninigi_warehouse",0)!=0)then
				SetMarketplace(true);
				SetRallySite(true);
			endif;
		endif;
		super.ExamineFlags();
	endproc;

	proc void SetMarketplace(bool p_bStatus)
		m_bMarketplace = p_bStatus;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr != null)then
			pxAttr^.SetValue("Marketplace",p_bStatus);
		endif;

		if (m_bMarketplace) then
			/*var ^CFlyingTrader pxTrader = CFlyingTraderMgr.GetFlyingTrader();
			if (pxTrader!=null) then
				pxTrader^.RegisterTradeBuilding(this);
			endif;*/
		endif;
	endproc;

	proc void Buy(string p_sResource, int p_iAmount)
		KLog.LogSpam("AnTr","Buy: "+p_sResource+", Amount: "+p_iAmount.ToString());
		var ^CPlayer pxPlayer = CSrvWrap.GetCurLevel()^.GetPlayer(GetOwner());
		if (pxPlayer==null) then return; endif;
		var ^CBasePlayer pxBasePlayer = cast<CBasePlayer>(pxPlayer);
		if (pxBasePlayer==null) then return; endif;
		var ^CAttribs pxPlAttr = pxPlayer^.GetAttribs();
		if(pxPlAttr==null)then return; endif;
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr==null)then return; endif;

		var int iPlayerSkullAmount	= pxPlAttr^.GetValueInt("iron");
		var int iPlayerAmount		= pxPlAttr^.GetValueInt(p_sResource);
		var int iPlayerMaxAmount	= pxPlAttr^.GetValueInt("max_"+p_sResource);

		if(iPlayerSkullAmount<=0)then
			CFeedback.Print(GetOwner(), CFeedback.ECONOMY, "_NT_BldgFailNotEnoughSkulls");
			return;
		endif;

		var real fChangeValue		= 1.0;
		if(p_sResource=="stone")then
			fChangeValue=m_afChangeValues[2];
		elseif(p_sResource=="wood")then
			fChangeValue=m_afChangeValues[1];
		elseif(p_sResource=="food")then
			fChangeValue=m_afChangeValues[0];
		endif;

		if(iPlayerSkullAmount<p_iAmount)then
			p_iAmount=iPlayerSkullAmount;
		endif;

		if(iPlayerAmount>=iPlayerMaxAmount)then
			CFeedback.Print(GetOwner(), CFeedback.ECONOMY, "_NT_BldgFailRscCap");
			return;
		endif;

		p_iAmount = Math.Min(p_iAmount, (iPlayerMaxAmount-iPlayerAmount));

		var int iValue=Math.Round(p_iAmount.ToReal()/fChangeValue).ToInt();

		if(p_sResource=="stone")then
			pxBasePlayer^.AddStone(iValue);			
		elseif(p_sResource=="wood")then			
			pxBasePlayer^.AddWood(iValue);			
		elseif(p_sResource=="food")then			
			pxBasePlayer^.AddFood(iValue);			
		endif;
		pxBasePlayer^.AddSkulls(-p_iAmount);		
	endproc;

	export proc bool TraderArrived()
		return false;
	endproc;

	proc int Resource2Index(string p_sResource)
		var ^CLevelInfoHost pxLevelInfo=CSrvWrap.GetLevelInfo(false);
		if(pxLevelInfo==null)then return -1; endif;
		var ^CLevelInfo.CPlayerSlot pxPlSlot = pxLevelInfo^.GetOwnerPlayerSlot(GetOwner());
		if(pxPlSlot==null)then return -1; endif;

		var string sTribe = GetTribeName();

		var int i, iC = m_xTechTree.NumSubs("Resources/"+sTribe);
		var int iReturn = 0;
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xTechTree.GetValueS("Resources/"+sTribe+"/"+i.ToString(),"")!=p_sResource)then continue; endif;
			iReturn = i;
			break;
		endfor;
		return iReturn;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		KLog.LogSpam("AnTr","HandleGamePlayCommand: "+p_sCommand);
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("buy_")!=-1)then
				KLog.LogSpam("AnTr","Command: '"+p_sCommand+"'");
				Buy(p_sMiscParams.Mid(p_sMiscParams.FindRev('_')+1),100);
			else
				super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
			endif;
		else
			super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;

endclass;

class CLadder inherit CBuilding

	class CBuildUpInfo
		export var int		m_iGroupCmdID;	///< group command id, used for build up the ladder
		export var CObjHndl	m_xLadder;		///< ladder to build up
	endclass;

	static var array CBuildUpInfo 	ms_axBUI;
	var CDockInfo					m_xDockInfo;

	export static proc void RegisterLadderBuildUp(int p_iCmdID,CObjHndl p_xLadder)
		var CBuildUpInfo xNew;
		xNew.m_iGroupCmdID=p_iCmdID;
		xNew.m_xLadder=p_xLadder;
		ms_axBUI.AddEntry(xNew);
	endproc;

	export static proc CObjHndl GetLadderBuildUp(int p_iCmdID)
		var int i,iC=ms_axBUI.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(ms_axBUI[i].m_iGroupCmdID==p_iCmdID)then
				return ms_axBUI[i].m_xLadder;
			endif;
		endfor;
		return CObjHndl.Invalid();
	endproc;

	export static proc void UnregisterLadderBuildUp(CObjHndl p_xLadder)
		var int i,iC=ms_axBUI.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(ms_axBUI[i].m_xLadder==p_xLadder)then
				ms_axBUI.DeleteEntry(i);
				return;
			endif;
		endfor;
	endproc;

	export constructor()
		m_xDockInfo.SetMoveCallback(Climb);
	endconstructor;

	export proc ref CDockInfo GetDockInfo()
		return m_xDockInfo;
	endproc;

	proc real Climb(CObjHndl p_xActor,bool p_bUp)
		//L KLog.LogSpam("MaMa","Climb Up:"+p_bUp.ToString());
		var ^CCharacter pxActor=cast<CCharacter>(p_xActor.GetObj());
		if(pxActor==null)then return -1.0f; endif;
		return pxActor^.StartLadderClimb(GetHandle(),p_bUp,false);
	endproc;

	export proc void SetReady()
		super.SetReady();
		m_xDockInfo.SetDockedDocker(true,GetHandle());
		UnregisterLadderBuildUp(GetHandle());
	endproc;

	export proc void Delete()
		m_xDockInfo.SetDockedDocker(false,GetHandle());
		super.Delete();
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Ladd";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xDockInfo.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Ladd")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xDockInfo.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
	endproc;

endclass;

class CNinigi_Defense_Skewer inherit CWall

	constructor()
	endconstructor;

	destructor()
	enddestructor;

	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor,real p_fHitDelay)
		var real fReturn=super.TakeDmg(p_pxEnemy, p_fFactor, p_fHitDelay);
		if(fReturn==0.0)then
			fReturn=5.0;
		endif;
		return fReturn;
	endproc;

endclass;

class CNinigi_Defense_Skewer_Gate inherit CGate

	constructor()
	endconstructor;

	destructor()
	enddestructor;

	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor,real p_fHitDelay)
		var real fReturn=super.TakeDmg(p_pxEnemy,p_fFactor, p_fHitDelay);
		if(fReturn==0.0)then
			fReturn=5.0;
		endif;
		return fReturn;
	endproc;

endclass;

class CWall inherit CBuilding

	var bool	m_bStones;
	const int	STONES_RELOAD_TIMER=182;

	var vec3 		m_vBuildVector; //vector from getpos to buildposition
	var CObjList 	m_xParentGates;

	constructor()
	endconstructor;

	export proc void SetBuildVector(vec3 p_vPos)
		m_vBuildVector = p_vPos;
	endproc;

	export proc ref vec3 GetBuildVector()
		return m_vBuildVector;
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
		SetIsWall(true);
		SetWallMapObj(true);
	endproc;
	
	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="WaBa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xParentGates.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="WaBa"; //Wall base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParentGates.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;
	
	export proc void SetParentGate(CObjHndl p_xGate)
		if(m_xParentGates.NumEntries()==0) then
			p_xGate.GetObj()^.AddGroupedChild(this);
		endif;
		m_xParentGates.Validate();
		m_xParentGates.AddEntry(p_xGate);
	endproc;

	export proc void OnDeleteParentGate(CObjHndl p_xGate)
		p_xGate.GetObj()^.RemGroupedChild(this);
		m_xParentGates.Exclude(p_xGate);
		//we can have up to 4 parent gates
		if(m_xParentGates.Validate()>0) then
			m_xParentGates[0].GetObj()^.AddGroupedChild(this);
		endif;
	endproc;

	export proc void ExamineFlags()

		if(m_xTechTree.GetValueI("Objects/"+GetTribeName()+"/InventObjects/hu_falling_stones/invented",0)!=0)then
			m_bStones=true;
		else
			m_bStones=false;
		endif;
		super.ExamineFlags();
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy)
		return super.TakeDmg(p_pxEnemy);
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor)
		return super.TakeDmg(p_pxEnemy, p_fFactor);
	endproc;

	export proc real TakeDmg(^CFightingObj p_pxEnemy, real p_fFactor,real p_fHitDelay)
		if(m_xParentGates.Validate()>0) then
			//redirect dmg to parent gate
			return cast<CGate>(m_xParentGates[0].GetObj())^.TakeDmg(p_pxEnemy,p_fFactor,p_fHitDelay);
		endif;
		if(m_bStones && m_bBuildingReady && !HasTimer(STONES_RELOAD_TIMER))then
			CreateTimer(STONES_RELOAD_TIMER, CGameTimeSpan.OneSecond() * GetWeaponDuration() , false);
			var ^CAreaDamage pxDmg = new CAreaDamage(this, GetPos());
			var CObjHndl xFX = AddFX("Hu_Wallstones_Fx",0.8);
			var ^CFX pxFX = cast<CFX>(xFX.GetObj());
			if(pxFX!=null)then
				pxFX^.SetRot(GetAngleToQ(p_pxEnemy));
				pxFX^.SetAnim("anim",1);
			endif;
			//SetAnim("wall_stones",1);
		endif;

		return super.TakeDmg(p_pxEnemy, p_fFactor, p_fHitDelay);

	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		super.HandleEvent(p_rxEvtPtr);
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			if (p_rxEvtPtr.GetInt(0) == STONES_RELOAD_TIMER ) then
				DeleteTimer(STONES_RELOAD_TIMER);
			endif;
		endif;
	endproc;

	export proc bool UpdateGfx()
		var string sGFX = m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
		if(sGFX.IsEmpty()) then return false; endif;
		if(sGFX != GetGfxName())then
	  		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
	  		pxWM^.WallClassChanged(GetHandle(),sGFX);
	  		m_sMyBuildAction="";
			SetGFX(sGFX);
			UpdateObjPath();
			OnTechTreeChange();
			return true;
		endif;
		return false;
	endproc;

	export proc void SetReady()
		super.SetReady();
  		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
  		pxWM^.SetReady(GetHandle());
	endproc;

	export proc void SetOwner(int p_iNewOwner)
		super.SetOwner(p_iNewOwner);
		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
  		pxWM^.SetReady(GetHandle());
	endproc;

endclass;

class CGateFOWVIsible inherit CGate
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
    	SetVisInFOW(true);
	endproc;
endclass;

class CGate inherit CBuilding

	var int			m_iState;		///< GATE_STATE_OPEN/GATE_STATE_CLOSED/GATE_STATE_AUTO
	const int		BROCKEN_TIMER=188;
	const int		AUTO_GATE_TIMER=189;
	var int			m_iFormerState;
	var CObjList	m_xHackers;
	var CObjHndl	m_xWallL;
	var CObjHndl	m_xWallR;

	export const int VIS_FLAG_OST_BIT		= 11;
	export const int VIS_FLAG_WEST_BIT		= 7;
	export const int VIS_FLAG_OPEN_BIT		= 14;	///< bit for collision volumes in open state
	export const int VIS_FLAG_CLOSED_BIT	= 16;	///< bit for collision volumes in closed state

	export const bitset COL_DIRECTION_MASK	=    011111111100000b;	///< mask for direction flags
	export const bitset COL_OPEN_BIT		=   0100000000000000b;	///< bit for collision volumes on state change
	export const bitset COL_CLOSED_BIT		= 010000000000000000b;	///< bit for collision volumes in closed state

	export const int GATE_STATE_OPEN	=0;
	export const int GATE_STATE_CLOSED	=1;
	export const int GATE_STATE_AUTO	=2;
	
	export constructor()
		m_iState=-1;
	endconstructor;

	export destructor()
		CSrvWrap.GetPathfinder().UnregisterGate(this);
	enddestructor;

	export proc void Delete()
		var ^CWall pxWallL=cast<CWall>(m_xWallL.GetObj());
		var ^CWall pxWallR=cast<CWall>(m_xWallR.GetObj());
		if(pxWallL!=null) then
			pxWallL^.OnDeleteParentGate(GetHandle());
		endif;
		if(pxWallR!=null) then
			pxWallR^.OnDeleteParentGate(GetHandle());
		endif;
		super.Delete();
	endproc;
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetFreeBorderBlocker(false);
		SetIsGate(true);

		var bitset dwCol=GetPFBlockerMask()&COL_DIRECTION_MASK;
		CSrvWrap.GetPathfinder().RegisterGate(this,dwCol|COL_OPEN_BIT,dwCol|COL_CLOSED_BIT);

		var vec3 vPos=GetPos();
		var bool bNewGate=vPos.GetX().ToInt()%8==4&&vPos.GetY().ToInt()%8==4;
		if(bNewGate) then
	  		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
	  		var bool bDiagonal=pxWM^.IsGateDiagonal(this);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OST_BIT,bDiagonal);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_WEST_BIT,bDiagonal);
			
			if(!p_bLoad) then
				var CObjHndl xWL,xWR;
				pxWM^.GetGateConnectingWalls(this,m_xWallL,m_xWallR);
				var ^CWall pxWallL=cast<CWall>(m_xWallL.GetObj());
				var ^CWall pxWallR=cast<CWall>(m_xWallR.GetObj());
				if(pxWallL!=null) then
					pxWallL^.SetParentGate(GetHandle());
				endif;
				if(pxWallR!=null) then
					pxWallR^.SetParentGate(GetHandle());
				endif;
			endif;
		endif;

		SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,false);
		SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,true);

		SetWallMapObj(true);
		if(p_bLoad)then
			if(m_iState==GATE_STATE_OPEN)then
				m_iState=-1;
				Open();
			elseif(m_iState==GATE_STATE_CLOSED)then
				m_iState=-1;
				Close();
			elseif(m_iState==GATE_STATE_AUTO)then
				m_iState=-1;
				Auto();
			else
				m_iState=-1;
				Auto();
			endif;
		endif;
		SetLEGfxFlags();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Gaba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^<<m_iState;
			if(pxArc^.GetVersion()<2) then
				//in old versions this was a bool, (false==closed)
				if(m_iState!=0) then m_iState=GATE_STATE_OPEN; else m_iState=GATE_STATE_CLOSED; endif;
				return;
			endif;
			pxArc^<<m_iFormerState;
			if(pxArc^.GetVersion()>=3) then
				m_xWallL.DoKArc(pxArc^);
				m_xWallR.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Gaba"; //Gate base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,3);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxArc^ << m_iFormerState;
		m_xWallL.DoKArc(pxArc^);
		m_xWallR.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc bool UpdateGfx()
		var string sGFX = m_xTechTree.GetValueS(GetObjPath()+"/gfx","");
		if(sGFX.IsEmpty()) then return false; endif;
		if(sGFX != GetGfxName())then
	  		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
	  		pxWM^.WallClassChanged(GetHandle(),sGFX);
	  		m_sMyBuildAction="";
			SetGFX(sGFX);
			UpdateObjPath();
			OnTechTreeChange();

			var int iLastAnimFrame=50;
			if(sGFX.Find("_palisade")!=-1)then
				iLastAnimFrame=70;
			endif;

			if(m_iState==GATE_STATE_OPEN)then
				SetAnim("open",0,iLastAnimFrame);
			elseif(m_iState==GATE_STATE_CLOSED || m_iState==GATE_STATE_AUTO)then
				SetAnim("close",0,iLastAnimFrame);
			endif;
			return true;
		endif;
		return false;
	endproc;

	export proc void SetIdleAnim()
		//skip idle anim //WT#781
	endproc;

	proc void Open()
		if(m_iState==GATE_STATE_OPEN) then return; endif; //redundant
		if(m_xHackers.NumEntries()>0)then
			OpenViolently(true);
		endif;
		if(HasTimer(AUTO_GATE_TIMER)) then
			DeleteTimer(AUTO_GATE_TIMER);
		else
			SetAnim("open",1);
		endif;
		m_iState=GATE_STATE_OPEN;
		SetPFBlocking();
		UpdateStateAttrib();
	endproc;

	proc void Close()
		if(m_iState==GATE_STATE_CLOSED) then return; endif; //redundant
		if(HasTimer(BROCKEN_TIMER))then return; endif;
		var bool bSetAnim=true;
		if(HasTimer(AUTO_GATE_TIMER)) then
			DeleteTimer(AUTO_GATE_TIMER);
		elseif(m_iState==GATE_STATE_AUTO) then
			bSetAnim=false;
		endif;
		if(bSetAnim) then SetAnim("close",1); endif;
		m_iState=GATE_STATE_CLOSED;
		SetPFBlocking();
		UpdateStateAttrib();
	endproc;

	proc void Auto()
		if(m_iState==GATE_STATE_AUTO) then return; endif; //redundant
		if(HasTimer(BROCKEN_TIMER))then return; endif;
		if(m_iState!=GATE_STATE_CLOSED) then
			SetAnim("close",1);
		endif;
		m_iState=GATE_STATE_AUTO;
		SetPFBlocking();
		UpdateStateAttrib();
	endproc;

	proc void OnAutoGatePassUnit()
		if(m_iState!=GATE_STATE_AUTO) then return; endif;
		//KLog.LogWarn("CHP","Gate\n");
		if(HasTimer(AUTO_GATE_TIMER)) then
			DeleteTimer(AUTO_GATE_TIMER);
		else
			SetAnim("open",1);
		endif;
		CreateTimer(AUTO_GATE_TIMER,CGameTimeSpan.OneSecond()*8.0,false);
	endproc;

	proc void UpdateStateAttrib()
		var ^CAttribs pxAttr=GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("GateState",m_iState);
		endif;
	endproc;

	export proc void SetPFBlocking()
		//CSrvWrap.GetPathfinder().UpdatePFBlocker(this);
		var bitset dwState=CPathfinder.GS_Open;
		if(m_iState==GATE_STATE_CLOSED) then dwState=CPathfinder.GS_Closed; endif;
		if(m_iState==GATE_STATE_AUTO) then dwState=CPathfinder.GS_Auto; endif;
		CSrvWrap.GetPathfinder().UpdateGateState(this,dwState);
	endproc;

	proc void SetPFBlockerMask(bitset p_dwMask)
		super.SetPFBlockerMask(p_dwMask);
		if(m_bBuildingReady)then
			// validate pathfinding information
			SetPFBlocking();
		endif;
	endproc;

	proc void SetLEGfxFlags()
		if(CSrvWrap.GetCurLevel()==null||!CSrvWrap.GetCurLevel()^.IsEditable()) then return; endif;
		if(m_iState==0)then
			//we can't use anims inside LevelEd, so use Flags instead
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,false);
		elseif(m_iState==1)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,false);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,true);
		elseif(m_iState==2)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_OPEN_BIT,true);
			SetRndInvMaskSingleFlagInv(VIS_FLAG_CLOSED_BIT,true);
		endif;
	endproc;

	export proc void HandleEditorCommand(string p_sCommand,^CGameObj p_pxObject,vec3 p_vPos,string p_sMiscParams)
		if(p_sCommand=="LE_SetGateState")then
			var int iState=p_sMiscParams.ToInt();
			if(iState==0)then
				Open();
			elseif(iState==1)then
				Close();
			else
				Auto();
			endif;
			SetLEGfxFlags();
		else
			super.HandleEditorCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sCommand=="Action")then
			if(p_sMiscParams.Find("Open")!=-1)then
				if(m_bBuildingReady)then
					Open();
				else
					m_iState=GATE_STATE_OPEN;
					UpdateStateAttrib();
				endif;
			elseif(p_sMiscParams.Find("Close")!=-1)then
				if(m_bBuildingReady)then
					Close();
				else
					m_iState=GATE_STATE_CLOSED;
					UpdateStateAttrib();
				endif;
			elseif(p_sMiscParams.Find("Auto")!=-1)then
				if(m_bBuildingReady)then
					Auto();
				else
					m_iState=GATE_STATE_AUTO;
					UpdateStateAttrib();
				endif;
			else
				super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
			endif;
		else
			super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;

	export proc void SetReadyBuild()
		super.SetReadyBuild();
		if(m_iState==-1)then
			Auto();
		else
			if(m_iState==GATE_STATE_OPEN)then
				m_iState=-1;
				Open();
			elseif(m_iState==GATE_STATE_CLOSED)then
				m_iState=-1;
				Close();
			else
				m_iState=-1;
				Auto();
			endif;
		endif;
	endproc;

	export proc void SetReady()
		super.SetReady();
  		var ^CWallMapSrv pxWM=CSrvWrap.GetObjMgr()^.GetObjPlaceChecker()^.GetWallMap();
  		pxWM^.SetReady(GetHandle());
	endproc;

	export proc bool IsOpen()
		return m_iState==GATE_STATE_OPEN;
	endproc;

	export proc void AddHacker(CObjHndl p_xHacker)
		if(p_xHacker.IsValid())then
			m_xHackers.Include(p_xHacker);
		endif;
		var int i;
		for(i=0)cond(i<m_xHackers.NumEntries())iter(i++)do
			if(!m_xHackers[i].IsValid())then
				m_xHackers.DeleteEntry(i);
				i--;
			endif;
		endfor;
	endproc;

	//Anti-Virus-Programm
	export proc void RemoveHacker(CObjHndl p_xHacker)
		var int iIndex = m_xHackers.FindEntry(p_xHacker);
		if(iIndex!=-1)then
			m_xHackers.RemEntry(p_xHacker);
		endif;
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		super.HandleEvent(p_rxEvtPtr);
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			if(p_rxEvtPtr.GetInt(0) == BROCKEN_TIMER ) then
				DeleteTimer(BROCKEN_TIMER);
				if(m_iFormerState==GATE_STATE_CLOSED)then
					Close();
				endif;
			elseif(p_rxEvtPtr.GetInt(0)==AUTO_GATE_TIMER) then
				if(m_iState==GATE_STATE_AUTO) then
					SetAnim("close",1);
				endif;
			endif;
		endif;
	endproc;

	export proc bool OpenViolently(bool p_bOwn)
		if(!HasTimer(BROCKEN_TIMER)&& !IsOpen())then
			m_iFormerState=m_iState;
			CreateTimer(BROCKEN_TIMER, CGameTimeSpan.OneSecond() * 30.0 , false);
			if(!p_bOwn)then
				Open();
			endif;
			return true;
		endif;
		return false;
	endproc;

endclass;

//Hu: Hu_Fireplace
class CFireplace inherit CRallyBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		CheckAge();

	endproc;

	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		//KLog.LogWarn("CHP","onttch");
		super.OnTechTreeChange(p_rasChanges);
		var int i,iC=p_rasChanges.NumEntries();
		for(i=0) cond(i<iC) iter(i++) do
			if(p_rasChanges[i].Find("InventObjects/age_")!=-1) then
				//KLog.LogWarn("CHP","inv_age!!!");
				CheckAge();
			endif;
		endfor;
	endproc;
endclass;

class CNonInventGrill inherit CBuilding

	var CObjHndl 	m_xLight;

	constructor()
	endconstructor;

	destructor()
	enddestructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetRallySite(true);
	endproc;

	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetStoneDelivery(true);
		SetWoodDelivery(true);
		SetFoodDelivery(true);
		SetIronDelivery(true);
		SetResinDelivery(true);
		SetBoneDelivery(true);
		SetHideDelivery(true);
*/	endproc;

endclass;

class CTemple inherit CBuilding

	var CObjHndl m_xEffect;

	export proc void OnInit(bool p_bLoad)
		m_bHealthBuilding=true;
		super.OnInit(p_bLoad);
		SetRallySite(true);

		// overwrite types in objquery used for healing
		m_xFunctionUnits.SetType("CHTR");											// ... this are Characters ...
		m_xFunctionUnits.SetType("ANML",true);										// ... this are Animals ...
		m_xFunctionUnits.SetType("VHCL",true);										// ... this are Vehicles ...
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Templ")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xEffect.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Templ";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xEffect.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void SetReady()
		super.SetReady();
		if(!m_xEffect.IsValid())then
			m_xEffect = AddFX("fx_heal_area",-1.0);
			AddRangedBuff("owner_healing_temple");
		endif;
		var CFourCC xLink;
		if(m_xEffect.IsValid())then
			m_xEffect.GetObj()^.LinkAction(GetHandle(),xLink);
		endif;
	endproc;

endclass;



class CNPCSeller inherit CBuilding

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("NPCSeller",true);
			endif;
		endif;
		SetRallySite(true);
	endproc;

/*	proc void RecruitNPC(string p_sNPCClass)

		var string sNPCClass = p_sNPCClass.Mid(p_sNPCClass.FindRev('/')+1);

		var ^CTechTree.CNode pxBuildAction = m_xTechTree.FindNode(p_sNPCClass);
		if(pxBuildAction==null)then return; endif;

		var ^CTechTree.CNode pxResults = pxBuildAction^.GetSub("results");
		if(pxResults==null)then return; endif;

		var int i, iC = pxResults^.NumSubs();
		var string sTTDesc;
		for(i=0)cond(i<iC)iter(i++)do
			var string sResult = pxResults^.GetSubValue(i);
			var ^CTechTree.CNode pxObject = m_xTechTree.FindNode(sResult);
			if(pxObject==null)then continue; endif;
			sNPCClass = pxObject^.GetName();
			sTTDesc=pxObject^.GetSubValue("description",sNPCClass);
		endfor;

		var bool bFree = CNPCMgr.Get().IsAbleToBuyNPC(GetOwner(),sNPCClass);
		if(!bFree)then
			CFeedback.Print(GetOwner(), CFeedback.SYSTEM,"_NT_BldgFailNPCAlreadyHired\t"+sTTDesc);
		endif;
		var CObjHndl xPyCO;
		if(bFree && CRequirementsMgr.Get().CheckConditionsAndPay(this, p_sNPCClass, xPyCO))then

			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			if(pxLevel==null)then return; endif;
			var ^CPlayer pxPlayer=pxLevel^.GetPlayer(GetOwner());
			if(pxPlayer==null)then return; endif;
			var ^CAttribs pxPlayerAttr=pxPlayer^.GetAttribs();			if(pxPlayerAttr==null)then return; endif;

			pxPlayerAttr^.SetValue("virtual_units_"+sNPCClass.GetAt(sNPCClass.GetLength()-1).ToString(), pxPlayerAttr^.GetValueInt("virtual_units_"+sNPCClass.GetAt(sNPCClass.GetLength()-1).ToString())-1);

			var	vec3		vPos = GetPos();
			var CFourCC		xProduct = "Spwn";
			GetLinkPosWorld(xProduct,vPos);

			if(HasAnim("open_gate"))then
				InvokeGenericSCEvent(24,4.0f);
			endif;

			if(sNPCClass=="Stina_s0")then
				var ^CFightingObj pxHero = cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj("special_eusmilus",GetOwner(),vPos));
				if(pxHero!=null)then
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("CTheLite");
					xEvt.SetObjHandle(0,GetHandle());
					pxHero^.HandleEvent(xEvt);
				endif;
			else
				var ^CFightingObj pxHero = cast<CFightingObj>(CSrvWrap.GetObjMgr()^.CreateObj(sNPCClass,GetOwner(),vPos));
				if(pxHero!=null)then
					var CGameEvtPtr xEvt=CGameEvtPtr.CreateEvent("CTheLite");
					xEvt.SetObjHandle(0,GetHandle());
					pxHero^.HandleEvent(xEvt);
				endif;
			endif;

			OnWorkFinished();
			//CreatChar
		endif;
		if(xPyCO.IsValid())then
			CSrvWrap.GetObjMgr()^.DeleteObject(xPyCO.GetObj());
		endif;
	endproc;
*/
endclass;


/*?
	?group 	URS.Scripts.Server.Classes
	?item 	CRecruitPool
	?desc 	This class represents a global Pool of Characters.
			Every Player can access this Pool through Taverns and recruit
			Characters. If a Character was recruited, he will be removed
			from this Pool, so that he disappears in all Tavern of all
			Players.
			The RecruitPool is implemented as a Singleton and holds the
			Data of the Characters currently available. If the Data changes
			the CRecruitPool writes the new Data as strings into the GameAttribs,
			which are accessible to the client.
	?prefix CRecruitPool
?*/
class CRecruitPool
	/*?
	?group 	URS.Scripts.Server.Classes.CRecruitPool
	?item 	CRecruit
	?desc	This class describes a Character. It holds all Data
			needed to generate a CCharacter from this.
	?prefix	CRecruit
	?*/
	class CRecruit
		export var string	m_sCharClassname;			// Name of the Character 		( ex. "Hu_F_Nature_s1"   )
		export var string	m_sCharCaste;				// Caste of the Character		( "nat", "tec", "res"   )
		export var string	m_sCharRace;					// Race of the Character		( "Hu",  "Aje", "Ninigi")
		export var bool 	m_bCharMale;					// Gender of the Character		( true == male / false = female )
		export var int		m_iCharLevel;					// Level of the Character		( 0 - 4 )

		export var int		m_iWoodCost;					// Specifies how many Wood - Units it costs to recruit this one
		export var int		m_iFoodCost;					// Specifies how many Food - Units it costs to recruit this one
		export var int		m_iStoneCost;				// Specifies how many Stone- Units it costs to recruit this one
	endclass;

	static var ^CRecruitPool ms_pxInstance;				// one and only Instance of this Class
	var array ^CRecruit	 m_apxPool;					// an Array holding the available Chars in the Pool


	constructor()
		UpdateGameAttribs();
	endconstructor;

	destructor()
		// free the allocated Memory
		if (m_apxPool.NumEntries() != 0) then
			var int i;
			for (i=0) cond (i < m_apxPool.NumEntries()) iter (i++) do
				delete m_apxPool[i];
			endfor;

		endif;
	enddestructor;
/*?
	?item 	Get(void)
	?desc	returns the Singleton-Instance as Reference
	?return Reference to the Singleton-Instance
?*/
	export static proc ref CRecruitPool Get()
		if ( ms_pxInstance == null ) then					// check if there is an Instance
			// if there is no Instance ...
			ms_pxInstance = new CRecruitPool();			// create one

			// Create a Timer for the adding of New Chars
			// Each time this Timer ticks a new random Char is added to the Pool
			// REMARK: This Timer is not in the CRecruitPool Class. It's a static Variable in the CHuTavern
			// 		   Class.
			CHuTavern.ms_iTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 120.0 , true);
			CTimeMgr.Get().GetTimer(CHuTavern.ms_iTimer)^.SetEventTemplate(CGameEvtPtr.CreateStringEvent("Timer", "AddChar"));
		endif;

		return (ms_pxInstance^);						// returns the Instance
	endproc;

/*?
	?item	ShutStatic(void)
	?desc	Static Method to free the Memory used by the Singleton-Instance
?*/
	export static proc void ShutStatic()
		CTimeMgr.Get().DeleteTimer(CHuTavern.ms_iTimer);	// the Timer have to by deleted ...
		delete ms_pxInstance;							// ... and the Instance too
	endproc;

/*?
	?item 	UpdateGameAttribs(void)
	?desc 	This Method Updates the GameAttribs
			It writes the Data about the available Characters in the Pool in the GameAttribs
			whick can be accessed by the client.
?*/
	proc void UpdateGameAttribs()

		var int i;										// loop counter

		// Loop through the 8 Slots
		for (i=0) cond (i < 8 ) iter (i++) do
			if ( i >= m_apxPool.NumEntries() ) then		// is there an Entry for Slot No. 'i' in the Pool
				// ... if no, then create the "none" String to singnalize an empty Slot
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				pxLevel^.GetLevelInfo().GetAttribs().SetValue("TavernSlot_" + (i+1).ToString(), "none");
			else
				// ... if there is an Entry ...
				// ... create a String with all Informations. This String then is written to the
				// GameAttribs and can be used by the Client to display what Characters are available

				var string sCaste;
				if (m_apxPool[i]^.m_sCharCaste == "nat") then
					sCaste = "Nature";
				elseif (m_apxPool[i]^.m_sCharCaste == "res") then
					sCaste = "Resource";
				else
					sCaste = "Technics";
				endif;

				var string sTooltip = m_apxPool[i]^.m_sCharClassname + "\nVolk:  " + m_apxPool[i]^.m_sCharRace + "\nCaste:  " + sCaste;
				if (m_apxPool[i]^.m_bCharMale == true ) then sTooltip += "\nGeschlecht: Männlich"; else sTooltip += "\nGeschlecht: Weiblich"; endif;
				sTooltip += "\nLevel:  " + m_apxPool[i]^.m_iCharLevel.ToString();
				sTooltip += "\nKosten: W:" + m_apxPool[i]^.m_iWoodCost.ToString() + "   F:" + m_apxPool[i]^.m_iFoodCost.ToString();
				sTooltip += "   S:" + m_apxPool[i]^.m_iStoneCost.ToString() + "\n";

				// Write the created String to GameAttribs
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				pxLevel^.GetLevelInfo().GetAttribs().SetValue("TavernSlot_" + (i+1).ToString(), sTooltip);
			endif;
		endfor;
	endproc;

/*?
	?item	AddRandomChar(void)
	?desc	This is used to Add a new randomly generated Character to the Pool
			If the Pool is full, the Method returns immediatly
?*/
	export proc void AddRandomChar()

		if (m_apxPool.NumEntries() >= 8) then
			// Returns if the Pool is full
			return;
		endif;

		var ^CRecruit pxRecr = new CRecruit();			// Creates a new CRecruit - Instance

		var int iLevel 	= Random.GetInt() % 3;			// generates a Random Level
		var int iRace   = Random.GetInt() % 3;			// generates a Random Race-ID
		var int iCaste  = Random.GetInt() % 3;			// generates a Random Caste-ID

		var string sRace, sCaste, sName, sGender;			// Strings to hold the Character Informations
		var bool   bMale;

// HACK
		iRace = 0;									// This Hack sets the Character-Race always to Hu.
// ENDHACK

		// Craete the right Strings from the generated IDs
		if ((Random.GetInt() % 2) == 0 ) then	 bMale = false; sGender = "F"; else bMale = true; sGender="M"; endif;
		if (iRace == 0) then sRace = "Hu"; elseif (iRace == 1) then sRace = "Aje"; else sRace = "Ninigi"; endif;
		if (iCaste == 0) then sCaste = "Nature"; elseif (iCaste == 1) then sCaste = "Resource"; else sCaste = "Technics"; endif;

		// Build a Classname from them
		sName = sRace + "_" + sGender + "_"+ sCaste + "_s" + iLevel.ToString();

		// This is an Array with the cost for Characters of
		// a given Level

		var array int aiCosts;
		aiCosts.AddEntry(50);
		aiCosts.AddEntry(150);
		aiCosts.AddEntry(300);
		aiCosts.AddEntry(500);
		aiCosts.AddEntry(1000);

		// Writes the Cost-Values to the Structure
		pxRecr^.m_iWoodCost 		= aiCosts[iLevel]/2;
		pxRecr^.m_iFoodCost 		= aiCosts[iLevel];
		pxRecr^.m_iStoneCost		= aiCosts[iLevel]/2;
		pxRecr^.m_sCharClassname	= sName;

		// Creates the Caste-Strings
		if (sCaste == "Nature") then			pxRecr^.m_sCharCaste	= "nat";
		elseif (sCaste == "Resource") then 	pxRecr^.m_sCharCaste 	= "res";
		else								pxRecr^.m_sCharCaste	= "tec";
	endif;

		// Writes the Values to the Structure
		pxRecr^.m_sCharRace	= sRace;
		pxRecr^.m_bCharMale	= bMale;
		pxRecr^.m_iCharLevel= iLevel;

		m_apxPool.AddEntry(pxRecr);					// Add this Character to the Pool

		// ... and updates the GameAttribs
		UpdateGameAttribs();
	endproc;

/*?
	?item	RecruitCharacter(^CGameObj p_pxObj, int p_iSlot)
	?desc 	This is called, when an Tavern recieves the "Recruit" - GameplayCommand
			This Method checks if it is possible for the Player to recruit this Character and
			returns true, it it is, or false if the Resourceamount is too low, or the Units-Count
			to high
	?param	p_pxObj		Pointer to the Tavern-Object
	?param	p_iSlot		Number of the Slot where the Character is
	?return	true		if the recruition of the Character suceeded, else false
?*/
	export proc bool RecruitCharacter(^CGameObj p_pxObj, int p_iSlot)
		if ( p_iSlot < 0 || p_iSlot >= m_apxPool.NumEntries() ) then
			// if the given Slot is invalid return
			return false;
		endif;

		// Gets the Player Attributes
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CAttribs pxAttr = pxLevel^.GetPlayer(p_pxObj^.GetOwner())^.GetAttribs();

		if (pxAttr == null) then							// Check if it is a valid Pointer ...
			// ... returns if it is invalid
			CSrvWrap.LogError("RecruitPool","Could not get Attribs of Player " + p_pxObj^.GetOwner().ToString());
			return false;
		endif;

		// Checks the Ressources and Units Count ...
		if ( pxAttr^.GetValueInt("wood") <= m_apxPool[p_iSlot]^.m_iWoodCost  ||
		     pxAttr^.GetValueInt("food") <= m_apxPool[p_iSlot]^.m_iFoodCost  ||
		     pxAttr^.GetValueInt("stone")<= m_apxPool[p_iSlot]^.m_iStoneCost ||
		     pxAttr^.GetValueInt("units") + pxAttr^.GetValueInt("virtual_units") >= pxAttr^.GetValueInt("max_units") ) then
		     	//L CSrvWrap.LogInfo("RecruitPool","Cannot recruit the Character.");
		     	// ... and returns false if it isn't possible to recruit this Character
		     	return false;
		endif;

		// If we are here, it is possible to recruit this Character
		// Removes the Ressource-Cost from the Player
//L		KLog.LogInfo( "DaHo", "CRecruit::RecruitCharacter() needs sample point" );
		pxAttr^.SetValue("wood", pxAttr^.GetValueInt("wood")- m_apxPool[p_iSlot]^.m_iWoodCost);
		pxAttr^.SetValue("food", pxAttr^.GetValueInt("food")- m_apxPool[p_iSlot]^.m_iFoodCost);
		pxAttr^.SetValue("stone", pxAttr^.GetValueInt("stone")- m_apxPool[p_iSlot]^.m_iStoneCost);
		// Adds a Unit to the Unit-Counter
		pxAttr^.SetValue("virtual_units", pxAttr^.GetValueInt("virtual_units") +1);

		// Creates a new Object
		var ^CGameObj pxObj = CSrvWrap.GetObjMgr()^.CreateObj(m_apxPool[p_iSlot]^.m_sCharClassname, p_pxObj^.GetOwner(), p_pxObj^.GetPos());
		if (pxObj == null) then		// Checks if it is valid ...
			// ... returns if it's not.
			CSrvWrap.LogError("RecruitPool","Object not created.");
			return false;
		endif;

		var ^CCharacter pxChar = cast<CCharacter>(pxObj);		// Casts the Object to a CCharacter ...
		if (pxChar == null) then									// ... checks if the CCharcter-Pointer is valid ...
			// ... returns if it isn't.
			CSrvWrap.LogError("RecruitPool","Cast failed.");
			return false;
		endif;

		// Set the craeted Char to the Values specified by the CRecruit
		pxChar^.SetCaste(m_apxPool[p_iSlot]^.m_sCharCaste);
		pxChar^.SetLevelClean(m_apxPool[p_iSlot]^.m_iCharLevel);
		//pxChar^.GetBorn(p_pxObj^.GetHandle());

		// Remove the recruited Char from the Pool
		CRecruitPool.Get().RemoveCharFromSlot(p_iSlot);

		return true;											// YIPPIE!! We're lucky ;)
	endproc;

/*?
	?item 	RemoveCharFromPool(int p_iSlot)
	?desc 	Removes a Character from the Pool
	?param	p_iSlot			Number of the Slot, which have to be cleared
?*/
	proc void RemoveCharFromSlot(int p_iSlot)
		if (p_iSlot < 0 || p_iSlot >= m_apxPool.NumEntries() ) then	// Checks if the given Slot is valid ...
			return;											// ... returns if it isn't.
		endif;

		delete m_apxPool[p_iSlot];								// Free the allocated Heap ...
		m_apxPool.DeleteEntry(p_iSlot);							// ... delete the Array Entry ....
		UpdateGameAttribs();									// ... and update the GameAttribs.
	endproc;

endclass;

/*?
	?group 	URS.Scripts.Server.Classes
	?item 	CHuTavern
	?desc	Describes the Tavern and is inherited from CBuilding.
			The Tavern has a static Timer, which controlls the AddChar-Behaviour. ( The TimeSpan
			until a new Char is generated ).
			The Tavern checks in the OnInit()-Method if there is any Timer Subscribed. If there isn't
			one will be Subscribed. In the Destructor the Timer will be Unsubscribed. So we make sure
			that there is always only one AddChar-Timer, even if there are many Taverns in the Map.
	?prefix	CHuTavern
	?*/
class CHuTavern inherit CBuilding

	export static var int ms_iTimer;								// Static Timer-ID to hold the AddChar-Timer of the CRecruitPool
	var ^CGameEvtQueue m_pxQueue;							// A Pointer to the EventQueue

	export destructor()
		if (m_pxQueue != null) then
			// Unsubscribes the Timer if there is Data in the EventQueue - Pointer
			CTimeMgr.Get().GetTimer(ms_iTimer)^.Unsubscribe(m_pxQueue);
		endif;
	enddestructor;

	export constructor()

	endconstructor;

/*?
		?item	OnInit(bool p_bLoad)
		?desc	This is the initializing Method.
		?param	p_bLoad			true if the Data have to be load, else false
?*/
	export proc void OnInit(bool p_bLoad)
		CRecruitPool.Get();		// this call is needed to make sure that the timer is initialized

		super.OnInit(p_bLoad);											// Calls the OnInit()-Method of the Superclass ( CBuilding )

		m_pxQueue = GetEvents();										// Initielize the EventQueue-Pointer

		if (CTimeMgr.Get().GetTimer(ms_iTimer)^.NumSubscribers() <= 0 ) then	 // Check if the Count of Subscribers are at Zero ...
			if (m_pxQueue == null) then
				//L CSrvWrap.LogInfo("Building.Tavern","m_pxQueue == NULL");
			else
				// ... if it is, then Subscribe the Timer
				CTimeMgr.Get().GetTimer(ms_iTimer)^.Subscribe(m_pxQueue);
			endif;
		endif;
		SetRallySite(true);

	endproc;

/*?
	?item 	HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
	?desc 	This Method Handles the recieved GamePlayCommands.
	?param	p_sCommand		a string describing the Command
	?param	p_pxObject		a possibility to pass a CGameObj to this Function
	?param	p_vPos			a possibility to pass a Position to this Function
	?param	p_sMiscParam	a string containing whatever you want and need
?*/
	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		// If p_sCommand is "Recruit", then the wanted SlotNumber mußt be in p_sMiscParams
		if ( p_sCommand == "Recruit" ) then
			// Handles the Recruit-Command
			CRecruitPool.Get().RecruitCharacter(this, p_sMiscParams.ToInt() );
		else
			// Gives the Command up to the superclass ( in this case CBuilding )
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;

/*?
	?item	HandleEvent(ref CGameEvtPtr	p_rxEvtPtr)
	?desc	Handles the incoming Events
	?param	p_rxEvtPtr		Refernece to the incoming Event to Handle
?*/
	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		// then check if it is our AddChar-Timer from the CRecruitPool
		if (p_rxEvtPtr.GetClass().ToString() == "Timer") then
			if (p_rxEvtPtr.GetString() == "AddChar") then
				//L CSrvWrap.LogInfo("Building.Tavern","Timer tickt");
				// If we are here, then the AddChar-Timer has ticked ...
				CRecruitPool.Get().AddRandomChar();						// ... and we have to add a new Random Character
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;

		// Here we perform a check, if there is any AddChar-Timer Subscribed ...
		if (CTimeMgr.Get().GetTimer(ms_iTimer)^.NumSubscribers() <= 0) then
			// ... if no, then do this now.
			CTimeMgr.Get().GetTimer(ms_iTimer)^.Subscribe(m_pxQueue);
		endif;
	endproc;
endclass;


class CLumbermill inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;

	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetWoodDelivery(true);
		SetFoodDelivery(true);
*/	endproc;

endclass;

class CStonemason inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;

	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetStoneDelivery(true);
		SetIronDelivery(true);
*/	endproc;

endclass;

class CHuntingLodge inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;

	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetHideDelivery(true);
		SetFoodDelivery(true);
*/	endproc;

endclass;

class CNinigiLumbermill inherit CBuilding
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_bQuickHarvest=true;
	endproc;

	export proc void SetReady()
		super.SetReady();
		UpdateDeliveries();
/*		SetWoodDelivery(true);
		SetResinDelivery(true);
*/	endproc;

endclass;

class CNinigi_Dilophosaurus_Nest inherit CBuilding

	const real		ACTION_RADIUS		= 50.0f;	// the action radius

	var CObjHndl	m_xNest;

	export constructor()
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DiNe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xNest.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void SetReady()
		super.SetReady();
		if(m_xNest.IsValid()) then return; endif;
		var ^CNest pxNest = cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj("hu_dilopho_nest_spawn",GetOwner(),GetPos(),GetRotation()));
		if(pxNest!=null) then
			m_xNest = pxNest^.GetHandle();
			AdjustNestAreas(pxNest);
			pxNest^.SetVisible(false);
			var CFourCC xT="NOPE";
			pxNest^.LinkAction(GetHandle(), xT);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="DiNe";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xNest.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode()) then
			SetReady();
		endif;
	endproc;

	proc void AdjustNestAreas(^CNest p_pxNest)
		var ^CRegion pxRgn = p_pxNest^.GetActionAreaPtr();

		var vec3 vE; vE.SetXYZ(ACTION_RADIUS, ACTION_RADIUS, 0.0f);
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);

		//vE.SetXYZ(10.0f, 10.0f, 0.0f);
		pxRgn = p_pxNest^.GetSafeAreaPtr();
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);
	endproc;

	export proc void Die()
		var ^CNest pxN = cast<CNest>(m_xNest.GetObj());
		if(pxN!=null) then
			pxN^.Die();
		endif;
		super.Die();
	endproc;

endclass;


class CCornfield inherit CGrowingField

	export proc bool Register(CObjHndl p_xWorker)
		var bool bRes=super.Register(p_xWorker);
		if(m_xWorker.NumEntries()>0)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_SCARECROW,true);
		endif;
		return(bRes);
	endproc;

	export proc bool UnRegister(CObjHndl p_xWorker)
		var bool bRes=super.UnRegister(p_xWorker);
		if(m_xWorker.NumEntries()<=0)then
			SetRndInvMaskSingleFlagInv(VIS_FLAG_BLDG_SCARECROW,false);
		endif;
		return(bRes);
	endproc;

endclass;

class CGrowingField inherit CUnlimitedBuilding

	var int	m_iGrowStep;

	constructor()
	endconstructor;

	destructor()
	enddestructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_iGrowStep=0;
		m_bQuickHarvest=true;
	endproc;

	export proc int GetGrowStep()
		return(m_iGrowStep);
	endproc;

	export proc void SetGrowStep(int p_iGrowStep)
		m_iGrowStep=p_iGrowStep;
		if(m_iGrowStep>100)then
			m_iGrowStep=0;
		endif;
		//L KLog.LogSpam("Cornfield","Growstep: "+m_iGrowStep.ToString());
	endproc;

	export proc void SetPFBlocking()
	endproc;

endclass;

class CAjeUnlimitedBuilding inherit CUnlimitedBuilding

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_iMaxWorker = 4;
		//KLog.LogSpam("RoSt", "Setting free_worker_slots attrib to '4'...");
		SetAttrib("free_worker_slots", "4");

		var ^CAttribs pxAttr = GetAttribs();

		if(pxAttr!=null)then
			pxAttr^.SetValue("free_worker_slots",4);
		endif;
	endproc;

	export proc void SetPFBlocking()
	endproc;

endclass;

class CUnlimitedBuilding inherit CBuilding
	var CObjList m_xWorker;
	var int m_iMaxWorker;
	var array string m_asRes;

	constructor()
	endconstructor;

	destructor()
	enddestructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		UpdateTechTree();
		m_bQuickHarvest = true;
		m_iMaxWorker = 2;
		SetUnlimitedBuilding(true);
	endproc;

	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		super.OnTechTreeChange(p_rasChanges);
		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null)then
			pxAttr^.SetValue("free_worker_slots", (m_iMaxWorker - m_xWorker.NumEntries()));
		endif;
	endproc;

	export proc void UpdateTechTree()
		m_asRes = 0;
		var CTechTree xTechTree;
		var string sObjPath = GetObjPath();
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer!=null)then
			xTechTree = GetTechTree();
		endif;
		var ^CTechTree.CNode pxUnlimited=xTechTree.FindNode(sObjPath+"/unlimited");
		if(pxUnlimited!=null)then
			var int i,iC=pxUnlimited^.NumSubs();
			for(i=0)cond(i<iC)iter(i++)do
				m_asRes.AddEntry(pxUnlimited^.GetSub(i)^.GetName());
			endfor;
		endif;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ULmd")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xWorker.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ULmd";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xWorker.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc array string GetResourceArray()
		return m_asRes;
	endproc;

	export proc bool Register(CObjHndl p_xWorker)
		if((m_xWorker.NumEntries() < m_iMaxWorker) && (m_xWorker.FindEntry(p_xWorker) == -1))then
			m_xWorker.Include(p_xWorker);
			if(p_xWorker.IsValid())then
				var ^CAttribs pxAttr = GetAttribs();

				if(pxAttr!=null)then
					pxAttr^.SetValue("free_worker_slots", (m_iMaxWorker - m_xWorker.NumEntries()));
					pxAttr^.SetValue("worker_list", AddObjGuidToString(pxAttr^.GetValue("worker_list"),p_xWorker));
				endif;
			endif;
			//SetRndInvMaskSingleFlagInv(VIS_FLAG_SCARECROW,true);
			return true;
		else
			return false;
		endif;
	endproc;

	export proc int GetWorkerID(CObjHndl p_xWorker)
		return m_xWorker.FindEntry(p_xWorker);
	endproc;

	export proc bool UnRegister(CObjHndl p_xWorker)
		if(m_xWorker.FindEntry(p_xWorker) != -1)then
			m_xWorker.RemEntry(p_xWorker);
			if(p_xWorker.IsValid())then
				var ^CAttribs pxAttr = GetAttribs();

				if(pxAttr!=null)then
					pxAttr^.SetValue("free_worker_slots", (m_iMaxWorker - m_xWorker.NumEntries()));
					pxAttr^.SetValue("worker_list", RemObjGuidFromString(pxAttr^.GetValue("worker_list"),p_xWorker));
				endif;
			endif;
			//SetRndInvMaskSingleFlagInv(VIS_FLAG_SCARECROW,false);
			return true;
		else
			return false;
		endif;
	endproc;

	export proc real Mine(real p_fHit, string p_sType)
		if(!IsBuildMode())then
			OnWork();
			if(m_asRes.FindEntry(p_sType)!=-1)then
				return p_fHit;
			endif;
		endif;
		return 0.0;
	endproc;
	
	static proc string AddObjGuidToString(string p_sStringList, CObjHndl p_xHandle)
		if(!p_xHandle.IsValid())then return p_sStringList; endif;
		var string sTempString=";"+p_xHandle.GetObj()^.GetGuid().ToString();
		if(p_sStringList.Find(sTempString)!=-1)then return p_sStringList; endif;
		return (p_sStringList+sTempString);
	endproc;
	
	static proc string RemObjGuidFromString(string p_sStringList, CObjHndl p_xHandle)
		if(!p_xHandle.IsValid())then return p_sStringList; endif;
		var string sTempString=";"+p_xHandle.GetObj()^.GetGuid().ToString();
		if(p_sStringList.Find(sTempString)!=-1)then
			p_sStringList.Replace(sTempString,"");
		endif;
		return (p_sStringList);
	endproc;

endclass;

class CScareCrow inherit CBuilding

	const real 	EFFECT_RANGE = 50.0f;
	const real	EFFECT_BONUS_AMOUNT = 20.0f;

	static var array string ms_asTypes;

	export constructor()
		if (ms_asTypes.NumEntries()==0) then
			ms_asTypes.AddEntry("ANML");
		endif;
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd = ApplyBonus;
		m_xSink.m_xOnObjRem = RemoveBonus;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScCr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^<< xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	export proc void SetReady()
		super.SetReady();
		if(!HasPersonalRegion())then
			var vec3 vP;vP.SetXYZ(EFFECT_RANGE,EFFECT_RANGE,0.0f);
			CreatePersonalRegion("MagicCauldron_" + Random.GetInt().ToString(), vP, 010b);
		endif;
	endproc;

	proc bool ApplyBonus(CObjHndl p_xObj)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null && CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner())) then
			if (ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0) then
				var real fBonus = pxFO^.GetDmg()*0.01f*EFFECT_BONUS_AMOUNT;

				var ^CBoniBucket pxBB = pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
				pxBB^.AddEntry("ScareCrow", -fBonus);
				pxFO^.ForceBoniUpdate();
			endif;
		endif;
		return true;
	endproc;

	proc bool RemoveBonus(CObjHndl p_xObj)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null && CSrvWrap.GetDiplomacyMgr().GetIsEnemy(GetOwner(), pxFO^.GetOwner())) then
			if (ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0) then
				var ^CBoniBucket pxBB = pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
				pxBB^.RemEntry("ScareCrow");
				pxFO^.ForceBoniUpdate();
			endif;
		endif;
		return true;
	endproc;

endclass;

class CResiner inherit CUnlimitedBuilding

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetConvertBuilding(true);
	endproc;


	export proc real Mine(real p_fHit, string p_sType)
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return 0.0; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return 0.0; endif;
		var ^CBasePlayer pxBasePlayer = cast<CBasePlayer>(pxPlayer);
		var real fWood = pxBasePlayer^.GetWood().ToReal();
		if(!IsBuildMode())then
			OnWork();
			pxBasePlayer^.AddWood(-((p_fHit+0.5f).ToInt()));
			return Math.Min(p_fHit,(fWood-pxBasePlayer^.GetWood().ToReal())/1.0);
		else
			return 0.0;
		endif;
	endproc;

	export proc bool HasWood()
		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		if(pxLevel==null)then return false; endif;
		var ^CPlayer pxPlayer = pxLevel^.GetPlayer(GetOwner());
		if(pxPlayer==null)then return false; endif;
		var ^CBasePlayer pxBasePlayer = cast<CBasePlayer>(pxPlayer);
		//L KLog.LogSpam("TechTree","CResiner::HasWood()"+(!IsBuildMode() && pxBasePlayer^.GetWood().ToReal()>0.0).ToString());
		return (!IsBuildMode() && pxBasePlayer^.GetWood().ToReal()>0.0 );
	endproc;

endclass;

class CCauldron inherit CBuilding

	const real EFFECT_RANGE		=35.0;
	export const string EFFECT_PATH	="/Filters/Ninigi/Upgrades/ninigi_cauldron/change_weapons";

	var string m_sTTPath;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd = ApplyBonus;
		m_xSink.m_xOnObjRem = RemoveBonus;
	endproc;

	export proc void SetReady()
		super.SetReady();
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(EFFECT_RANGE, EFFECT_RANGE, 0.0f);
			CreatePersonalRegion("NinigiCauldron_"+Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_fire_arrows");
		endif;
	endproc;

	export proc bool CheckCauldronUnit(string p_sClassName)
		if(p_sClassName=="ninigi_archer")then
			return true;
		elseif(p_sClassName=="ninigi_marksman")then
			return true;
		elseif(p_sClassName=="aje_archer")then
			return true;
		elseif(p_sClassName=="hu_archer")then
			return true;
		elseif(p_sClassName=="hu_marksman")then
			return true;
		elseif(p_sClassName=="Bela_s0")then
			return true;
		endif;
		return false;
	endproc;

	proc bool ApplyBonus(CObjHndl p_xObj)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null && CheckCauldronUnit(pxFO^.GetClassName()) && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner()))then
			pxFO^.SetEffectFlag(CFightingObj.EFFECT_NINIGI_CAULDRON,true);
			m_xRegionObjects.Include(p_xObj);
		endif;
		return true;
	endproc;

	proc bool RemoveBonus(CObjHndl p_xObj)
		if(m_xRegionObjects.FindEntry(p_xObj)==-1)then return false; endif;
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null)then
			pxFO^.SetEffectFlag(CFightingObj.EFFECT_NINIGI_CAULDRON,false);
		endif;
		m_xRegionObjects.RemEntry(p_xObj);
		return true;
	endproc;

endclass;

class CTrap inherit CBuilding

	class CTrapEffect inherit CEvtSink

		var procref<bool, CObjHndl>		m_xOnTrapped;
		var procref<bool, CObjHndl>		m_xOnTick;
		var procref<bool, CObjHndl>		m_xOnReleased;

		var CObjHndl		m_xTrap;
		var CObjHndl 		m_xObj;
		var CGameTime		m_xStartTime;
		var real			m_fDuration;
		var int 			m_iTimer;
		var bool			m_bSkipTarget;

		export static proc ^CTrap.CTrapEffect CreateEffect(^CTrap p_pxTrap, CObjHndl p_xObj, procref<bool,CObjHndl> p_xOnTrap,
														   procref<bool,CObjHndl> p_xOnRel, procref<bool, CObjHndl> p_xOnTick )
			//KLog.LogSpam("Trap","CTrapEffect::CreateEffect");
			if(!p_xObj.IsValid()||p_pxTrap==null) then return null; endif;
			if((p_pxTrap^.m_xIgnoreList.FindEntry(p_xObj)>=0)||(p_pxTrap^.m_xCurTrappedObjs.FindEntry(p_xObj)>=0))then return null; endif;
			var ^CTrapEffect pxRet=new CTrap.CTrapEffect(p_pxTrap, p_xObj, p_xOnTrap, p_xOnRel, p_xOnTick);
			if(pxRet^.m_bSkipTarget) then
				delete pxRet; //delete internally sets pxRet=null
				pxRet=null;
			endif;
			return pxRet;
		endproc;

		// for use during loading only
		export static proc ^CTrap.CTrapEffect CreateEffect()
			//KLog.LogSpam("Trap","CTrapEffect::CreateEffect");
			var ^CTrapEffect pxRet=new CTrap.CTrapEffect();
			return pxRet;
		endproc;

		export proc void ReInit()
			//KLog.LogSpam("Trap","CTrapEffect::ReInit");
			if (!m_xOnTrapped.IsNull()) then
				if(!m_xOnTrapped.Call(m_xObj)) then
					//object can not be trapped -> skip
					m_bSkipTarget=true;
					return;
				endif;
			endif;

			m_iTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond(), true);
			//m_xStartTime = CTimeMgr.Get().GetTime();
			var ^CTimerObj pxT = CTimeMgr.Get().GetTimer(m_iTimer);
			if(pxT!=null) then
				pxT^.Subscribe(this);
			endif;
		endproc;

		constructor(^CTrap p_pxTrap, CObjHndl p_xObj, procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel,
					procref<bool, CObjHndl> p_xOnTick )
			//KLog.LogSpam("Trap","CTrapEffect::constructor start");
			m_xTrap 		= p_pxTrap^.GetHandle();
			m_xObj 			= p_xObj;
			m_fDuration		= p_pxTrap^.m_fDuration;
			m_xOnTrapped	= p_xOnTrap;
			m_xOnReleased	= p_xOnRel;
			m_xOnTick		= p_xOnTick;
			//KLog.LogSpam("Trap",m_xTrap.GetObj()^.GetName()+" procref write");
			m_bSkipTarget	= false;

			if (!m_xOnTrapped.IsNull()) then
				if(!m_xOnTrapped.Call(m_xObj)) then
					//object can not be trapped -> skip
					m_bSkipTarget=true;
					return;
				endif;
			endif;

			m_iTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond(), true);
			m_xStartTime = CTimeMgr.Get().GetTime();
			var ^CTimerObj pxT = CTimeMgr.Get().GetTimer(m_iTimer);
			if(pxT!=null) then
				pxT^.Subscribe(this);
			endif;
			p_pxTrap^.m_apxRunningEffects.AddEntry(this);
			p_pxTrap^.m_xCurTrappedObjs.Include(m_xObj);
			//KLog.LogSpam("Trap","CTrapEffect::constructor end");
		endconstructor;

		//for use during loading only
		constructor()
			//KLog.LogSpam("Trap","CTrapEffect::constructor for loading");
		endconstructor;

		destructor()
			//KLog.LogSpam("Trap","CTrapEffect::destructor");
			var ^CTimerObj pxT = CTimeMgr.Get().GetTimer(m_iTimer);
			if(pxT!=null) then
				pxT^.Unsubscribe(this);
				CTimeMgr.Get().DeleteTimer(m_iTimer);
				m_iTimer=-1;
			endif;
		enddestructor;

		export proc void Delete()
			if(m_xTrap.IsValid()) then
				var ^CTrap pxTrap = cast<CTrap>(m_xTrap.GetObj());
				if(pxTrap!=null) then
					pxTrap^.m_apxRunningEffects.RemEntryUS(this);
				endif;
			endif;
			delete this;
		endproc;

		export proc void DoKArc(ref CArc p_rxArc)
			//KLog.LogSpam("Trap","CTrapEffect::DoKArc");
			m_xTrap.DoKArc(p_rxArc);
			m_xObj.DoKArc(p_rxArc);
			m_xStartTime.DoKArc(p_rxArc);
			p_rxArc << m_fDuration;
			//p_rxArc << m_iTimer;
			p_rxArc << m_bSkipTarget;
			//p_rxArc << m_xOnTrapped;
			//p_rxArc << m_xOnTick;
			//p_rxArc << m_xOnReleased;
		endproc;

		//used to reinit after loading
		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel,
								  procref<bool, CObjHndl> p_xOnTick )
			//KLog.LogSpam("Trap","CTrapEffect::SetProcs 3");
			ReleaseProcs();
			m_xOnTrapped=p_xOnTrap;
			m_xOnTick=p_xOnTick;
			//KLog.LogSpam("Trap",m_xTrap.GetObj()^.GetName()+" procref write");
			m_xOnReleased=p_xOnRel;
		endproc;
		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel)
			//KLog.LogSpam("Trap","CTrapEffect::SetProcs 2");
			ReleaseProcs();
			m_xOnTrapped=p_xOnTrap;
			m_xOnReleased=p_xOnRel;
		endproc;
		export proc void ReleaseProcs()
			//KLog.LogSpam("Trap","CTrapEffect::ReleaseProcs");
			m_xOnTrapped.Clear();
			m_xOnReleased.Clear();
			m_xOnTick.Clear();
			//KLog.LogSpam("Trap",m_xTrap.GetObj()^.GetName()+" procref write");
		endproc;

		export proc bool OnPush (ref CEvtPointer  p_rxEP )
			//KLog.LogSpam("Trap","CTrapEffect::OnPush");
			if(!m_xTrap.IsValid()) then delete this; return false; endif;
			//KLog.LogSpam("Trap","CTrapEffect::OnPush "+m_xTrap.GetObj()^.GetName());
			//KLog.LogSpam("Trap","CTrapEffect::OnPush OnTrapped="+m_xOnTrapped.IsNull().ToString()+" OnTick="+m_xOnTick.IsNull().ToString()+" OnReleased="+m_xOnReleased.IsNull().ToString());


			var CGameTime xNow = CTimeMgr.Get().GetTime();

			if ((xNow - m_xStartTime).GetSecondsF() >= m_fDuration || !m_xObj.IsValid()) then
				OnRelease();
			else
				//KLog.LogSpam("Trap",m_xTrap.GetObj()^.GetName()+" procref read");
				if (!m_xOnTick.IsNull()) then
					//KLog.LogSpam("Trap",m_xTrap.GetObj()^.GetName()+" procref call "+m_xObj.IsValid().ToString());
					m_xOnTick.Call(m_xObj);
				endif;
			endif;
			return true;
		endproc;

		export proc bool OnRelease()
			//KLog.LogSpam("Trap","CTrapEffect::OnRelease");
			if (!m_xOnReleased.IsNull()) then
				m_xOnReleased.Call(m_xObj);
			endif;

			if(m_xTrap.IsValid()) then
				var ^CTrap pxTrap = cast<CTrap>(m_xTrap.GetObj());
				if(pxTrap!=null) then
					pxTrap^.m_xCurTrappedObjs.RemEntry(m_xObj);
					pxTrap^.m_xIgnoreList.Include(m_xObj);
					pxTrap^.m_apxRunningEffects.RemEntryUS(this);
					delete this;
					return true;
				endif;
			endif;
			return true;
		endproc;
	endclass;

	class CTrapQuery inherit CEvtSink

		var bool		m_bEnabled;
		var int			m_iRegion;				///< handle of region, where to make query
		var bool		m_bOnlyEnemies;			///< query affects only enemies of trap's owner
		var CObjQuery	m_xQuery;
		var CObjHndl	m_xTrap;
		var bool		m_bOneTime;				///< query runs only ones
		export var bool		m_bAlreadyReleased;	///< indicate trap was already trapped

		var procref<bool, CObjHndl> m_xOnTrap, m_xOnRelease, m_xOnTick;

		export constructor(^CTrap p_pxTrap)
			//KLog.LogSpam("Trap","CTrapQuery::constructor start");
			m_iRegion=-1;
			m_bOnlyEnemies=true;

			if(p_pxTrap!=null) then
				/*
				var CObjHndl xTrap = p_pxTrap^.GetHandle();
				if (xTrap.IsValid()) then
					KLog.LogSpam("Trap","CTrapQuery::constructor trap is valid");
				else
					KLog.LogSpam("Trap","CTrapQuery::constructor ERROR trap not valid");
				endif;
				*/
				m_xTrap=p_pxTrap^.GetHandle();
			endif;
			//KLog.LogSpam("Trap","CTrapQuery::constructor end");
		endconstructor;

		export destructor()
			//KLog.LogSpam("Trap","CTrapQuery::destructor");
			var ^CRegionMgr pxRgnMgr=^(CSrvWrap.GetRegionMgr());
			var ^CRegion pxRgn=pxRgnMgr^.GetRegion(m_iRegion);
			if(pxRgn!=null)then
				pxRgn^.Unsubscribe(this);
				pxRgnMgr^.DeleteRegion(m_iRegion);
			endif;
		enddestructor;

		export proc bool GetEnabled()
			//KLog.LogSpam("Trap","CTrapQuery::GetEnabled");
			return m_bEnabled;
		endproc;

		export proc void ReleaseProcs()
			//KLog.LogSpam("Trap","CTrapQuery::ReleaseProcs");
			m_xOnTrap.Clear();
			m_xOnRelease.Clear();
			m_xOnTick.Clear();
		endproc;

		export proc void SetEnabled(bool p_bEnabled)
			//KLog.LogSpam("Trap","CTrapQuery::SetEnabled A "+p_bEnabled.ToString());
			m_bEnabled=p_bEnabled;
			var ^CRegionMgr pxRgnMgr=^(CSrvWrap.GetRegionMgr());
			begin;
				var ^CRegion pxRgn=pxRgnMgr^.GetRegion(m_iRegion);
				if(pxRgn!=null)then
					pxRgn^.Unsubscribe(this);
					pxRgnMgr^.DeleteRegion(m_iRegion);
				endif;
			end;
			if(!m_xTrap.IsValid()) then
				m_bEnabled=false;
			endif;
			//KLog.LogSpam("Trap","CTrapQuery::SetEnabled B "+p_bEnabled.ToString());
			if(m_bEnabled)then
				var vec3 vR;
				var ^CTrap pxTrap = cast<CTrap>(m_xTrap.GetObj());
				if(pxTrap!=null) then
					vR.SetXYZ(pxTrap^.GetTrapRadius(),pxTrap^.GetTrapRadius(),0.0f);
					m_iRegion=pxRgnMgr^.CreateRegion(pxTrap^.GetName()+"_Region",CSubRegion.RT_Oval,pxTrap^.GetPos(),vR);
					var ^CRegion pxRgn=pxRgnMgr^.GetRegion(m_iRegion);
					if(pxRgn!=null)then
						pxRgn^.SetVolatile();
						// bind region to trap, may be we make moveable traps
						pxRgn^.BindToObj(pxTrap^.GetHandle());
						pxRgn^.Subscribe(this);
					else
						m_bEnabled=false;
					endif;
				endif;
			endif;
			//KLog.LogSpam("Trap","CTrapQuery::SetEnabled C "+p_bEnabled.ToString());
		endproc;

		export proc void SetOneTime(bool p_bOneTime)
			//KLog.LogSpam("Trap","CTrapQuery::SetOneTime");
			m_bOneTime = p_bOneTime;
		endproc;

		export proc bool GetOneTime()
			//KLog.LogSpam("Trap","CTrapQuery::GetOneTime");
			return m_bOneTime;
		endproc;

		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel)
			//KLog.LogSpam("Trap","CTrapQuery::SetProcs");
			m_xOnTrap = p_xOnTrap;
			m_xOnRelease = p_xOnRel;
		endproc;

		export proc void SetProcs(procref<bool,CObjHndl> p_xOnTrap, procref<bool,CObjHndl> p_xOnRel,
								  procref<bool, CObjHndl> p_xOnTick )
			//KLog.LogSpam("Trap","CTrapQuery::SetProcs");
			SetProcs(p_xOnTrap, p_xOnRel);
			m_xOnTick = p_xOnTick;
		endproc;

		export proc void SetEnemyOnly(bool p_bValue)
			//KLog.LogSpam("Trap","CTrapQuery::SetEnemyOnly");
			m_bOnlyEnemies=p_bValue;
		endproc;

		export proc void AddType(string p_sType)
			//KLog.LogSpam("Trap","CTrapQuery::AddType");
			m_xQuery.SetType(p_sType,true);
		endproc;

		export proc void ClearTypes()
			//KLog.LogSpam("Trap","CTrapQuery::ClearTypes");
			m_xQuery.ClearTypes();
		endproc;

		proc void UpdateObjQuery()
			//KLog.LogSpam("Trap","CTrapQuery::UpdateObjQuery");
			m_xQuery.SetOwner(-1,false);

			if(!m_xTrap.IsValid()) then
				SetEnabled(false);
				return;
			endif;
			var ^CTrap pxTrap = cast<CTrap>(m_xTrap.GetObj());
			if(pxTrap==null) then return; endif;

			var int i, iC = 8;
			var int iOwner = pxTrap^.GetOwner();
			for (i=0) cond(i<iC) iter(++i) do
				// friendly fire is off
				if(i==iOwner)then continue; endif;

				if(!m_bOnlyEnemies || CSrvWrap.GetDiplomacyMgr().GetIsEnemy(iOwner,i))then
					m_xQuery.SetOwner(i, true);
				endif;
			endfor;

			m_xQuery.SetRegion(m_iRegion);
		endproc;

		// here comes the notification about changes in the region
		proc bool OnPush(ref CEvtPointer p_rxEP)
			//KLog.LogSpam("Trap","CTrapQuery::OnPush");
			UpdateObjQuery();

			var CObjList xList, xEntered, xLeaved;
			m_xQuery.Execute(xList);

			var bitset dwWasFlagged=0b;

			if(!m_xTrap.IsValid()) then
				SetEnabled(false);
				return false;
			endif;
			var ^CTrap pxTrap = cast<CTrap>(m_xTrap.GetObj());
			if(pxTrap==null) then return false; endif;


			var int i, iC = xList.NumEntries();
			for (i=0) cond(i<iC) iter(++i) do
				var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
				if(pxObj==null)then continue; endif;

				if((pxTrap^.m_xIgnoreList.FindEntry(xList[i])<0)&&(pxTrap^.m_xCurTrappedObjs.FindEntry(xList[i])<0)&&(!pxObj^.GetTransportObj().IsValid()))then
					xEntered.Include(xList[i]);
				endif;
			endfor;

			iC=pxTrap^.m_xIgnoreList.NumEntries();
			for (i=0) cond(i<iC) iter(++i) do
				if (xList.FindEntry(pxTrap^.m_xIgnoreList[i])<0) then
					xLeaved.Include(pxTrap^.m_xIgnoreList[i]);
				endif;
			endfor;
			iC=xEntered.NumEntries();
			if(!m_bOneTime || !m_bAlreadyReleased)then
				for(i=0) cond(i<iC) iter(++i) do
					var ^CGameObj pxObj=xEntered[i].GetObj();
					if(pxObj==null)then continue; endif;

					if(CTrap.CTrapEffect.CreateEffect(pxTrap, xEntered[i], m_xOnTrap, m_xOnRelease, m_xOnTick)!=null)then

						//unhide trap only if "trappee" was accepted
						var int iOwner=pxObj^.GetOwner();
						if((dwWasFlagged&(01b<<iOwner))==0b) then
							dwWasFlagged|=01b<<iOwner;
							pxTrap^.TrapFound(iOwner);
						endif;

						if(m_bOneTime)then
							m_bAlreadyReleased=true;
							break;
						endif;
					endif;
				endfor;
			endif;

			iC=xLeaved.NumEntries();
			for (i=0) cond(i<iC) iter(++i) do
				pxTrap^.m_xIgnoreList.RemEntry(xLeaved[i]);
			endfor;

			return true;
		endproc;
	endclass;

	var bool						m_bWasLoaded; //volatile ; for init after loading
	var bool						m_bEnableQueryAfterLoading; //volatile ; for init after loading

	var ^CTrapQuery					m_pxQuery;
	export var array ^CTrapEffect	m_apxRunningEffects;

	export var CObjList	m_xCurTrappedObjs;				///< List of objects currently trapped
	export var CObjList	m_xIgnoreList;					///< List of Object to ignore ( ie. Objs trapped and released but in TrapZone )

	var real		m_fRadius;							///< radius where trap takes effect
	export var real	m_fDuration;
	var bool		m_bEnableOnReady;					///< trap is usable after build
	const  int		DELETE_TIMER=222;
	const int		DELAY_TIMER=223;

	export constructor()
		//KLog.LogSpam("Trap","CTrap::constructor start");

		//m_pxQuery=new CTrapQuery(this); RT#15528 init error of object handle, handle is only valid after objectmanager finished the CreateObj method; moved this line to OnInit
		m_bEnableOnReady=true;
		m_bWasLoaded=false;
		m_bEnableQueryAfterLoading=false;
	endconstructor;

	export destructor()
		//KLog.LogSpam("Trap","CTrap::destructor");
		delete m_pxQuery;
		var int i;
		for(i=0)cond(i<m_apxRunningEffects.NumEntries())iter(i++)do
			m_apxRunningEffects[i]^.Delete();
		endfor;
	enddestructor;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		//KLog.LogSpam("Trap","CTrap::Load "+GetName());
		if(p_pxReaderNode^.GetType()=="Trap")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());

			// trap query status
			m_bWasLoaded = true;
			pxArc^ << m_bEnableQueryAfterLoading;

			// running trap effects
			var int i, iCountRunningEffects;
			pxArc^ << iCountRunningEffects;
			for(i=0)cond(i<iCountRunningEffects)iter(i++)do
				var ^CTrap.CTrapEffect pxTrapEffect = CTrap.CTrapEffect.CreateEffect();
				pxTrapEffect^.DoKArc(pxArc^);
				m_apxRunningEffects.AddEntry(pxTrapEffect);
			endfor;

			m_xCurTrappedObjs.DoKArc(pxArc^);
			m_xIgnoreList.DoKArc(pxArc^);
			pxArc^ << m_fRadius;
			pxArc^ << m_fDuration;
			pxArc^ << m_bEnableOnReady;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		//KLog.LogSpam("Trap","CTrap::Save "+GetName());
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Trap"; // Trap base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,0);
		var ^CArc pxArc=^(pxWalk^.GetArc());

		// trap query status
		var bool bTmp = true;
		if (m_pxQuery != null) then
			bTmp = m_pxQuery^.GetEnabled();
			// fix trap placed in leveled won't initialze correctly (start)
			// SB#16935
			if(!m_bWasLoaded)then
				var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
				System.Assert(pxLevel!=null);
				if(pxLevel^.IsEditable())then
					bTmp = true; // can't place unfinished traps within leveleditor
				endif;
			endif;
			// fix trap placed in leveled won't initialze correctly (end)
		endif;
		pxArc^ << bTmp;

		// running trap effects
		var int i, iCountRunningEffects = m_apxRunningEffects.NumEntries();
		pxArc^ << iCountRunningEffects;
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
		//KLog.LogSpam("Trap","CTrap::Save "+GetName()+" saved effect");
			m_apxRunningEffects[i]^.DoKArc(pxArc^);
		endfor;

		m_xCurTrappedObjs.DoKArc(pxArc^);
		m_xIgnoreList.DoKArc(pxArc^);
		pxArc^ << m_fRadius;
		pxArc^ << m_fDuration;
		pxArc^ << m_bEnableOnReady;
		pxWalk^.Close();
	endproc;

	export proc string GetReleaseAnim()
		return "";
	endproc;

	export proc string GetCatchAnim()
		return "";
	endproc;

	export proc string GetDieInTrapAnim()
		return "";
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		//KLog.LogSpam("Trap","CTrap::OnInit start");
		if(!p_bLoad)then
		endif;

		// make traps invisible again if they gone in FOW
		// this shouldn't move to (!p_bLoad) section, because it isn't saved
		SetWallMapObj(true);
		SetIsTrap(true);
		m_pxQuery=new CTrapQuery(this);

		//KLog.LogSpam("Trap","CTrap::OnInit end");
	endproc;

	export proc void SetReady()
		//KLog.LogSpam("Trap","CTrap::SetReady");
		super.SetReady();
		if(m_bWasLoaded)then
			m_pxQuery^.SetEnabled(m_bEnableQueryAfterLoading);
		else
			SetVisibleMask(01b<<GetOwner());
			m_pxQuery^.SetEnabled(m_bEnableOnReady);
		endif;
		SetFOWTempVisible(true);
	endproc;

	export proc void SetTrapRadius(real p_fRadius)
		//KLog.LogSpam("Trap","CTrap::SetTrapRadius");
		m_fRadius=p_fRadius;
		m_pxQuery^.SetEnabled(m_pxQuery^.GetEnabled());
	endproc;

	export proc real GetTrapRadius()
		//KLog.LogSpam("Trap","CTrap::GetTrapRadius");
		return m_fRadius;
	endproc;

	export proc string GetTrappedAnim()
		//KLog.LogSpam("Trap","CTrap::GetTrappedAnim");
		return "";
	endproc;

	export proc void TrapFound(int p_iOwner)
		if(GetOwner()==p_iOwner)then return; endif;

		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType("smok");
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1 && m_axCamouflageLayers[iIdx].IsValid())then
			return;
		endif;

		//SetVisibleMask(GetVisibleMask()|(01b<<p_iOwner));
		SetVisible(true); //see DevTrack: WT8 or StarBugs #14194
	endproc;

	export proc void Die()
		//KLog.LogSpam("Trap","CTrap::Die");
		//CFeedback.Print("Falle wurde zerstört! -> "+GetName(),GetOwner());
		if(m_pxQuery!=null) then
			m_pxQuery^.SetEnabled(false);
		endif;

		while(m_apxRunningEffects.NumEntries()>0) do
			if(m_apxRunningEffects[0]!=null) then
				m_apxRunningEffects[0]^.OnRelease();
			endif;
		endwhile;

		super.Die();
	endproc;

	export proc bool StartDeleteTimer(real p_fDuration)
		//KLog.LogSpam("Trap","CTrap::StartDeleteTimer");
		if(HasTimer(DELETE_TIMER))then return false; endif;
		CreateTimer(DELETE_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
		return true;
	endproc;

	export proc bool StartDelayTimer(real p_fDuration)
		//KLog.LogSpam("Trap","CTrap::StartDelayTimer");
		if(HasTimer(DELAY_TIMER))then return false; endif;
		CreateTimer(DELAY_TIMER,CGameTimeSpan.OneSecond() * p_fDuration, false);
		return true;
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		//KLog.LogSpam("Trap","CTrap::HandleEvent");
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass) then
			if(p_rxEvtPtr.GetInt(0)==DELETE_TIMER) then
				Die();
				//KLog.LogSpam("Trap","CTrap::HandleEvent A");
				return;
			elseif(p_rxEvtPtr.GetInt(0)==DELAY_TIMER) then
				Activate();
				//KLog.LogSpam("Trap","CTrap::HandleEvent B");
				return;
			else
				super.HandleEvent(p_rxEvtPtr);
				//KLog.LogSpam("Trap","CTrap::HandleEvent C");
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;

	export proc void Activate()
		//KLog.LogSpam("Trap","CTrap::Activate");
		m_xIgnoreList = 0;
		m_pxQuery^.m_bAlreadyReleased = false;
		m_pxQuery^.SetEnabled(true);
	endproc;

	// do nothing implementation
	export proc bool OnTrap(CObjHndl p_xObj)
		//KLog.LogSpam("Trap","CTrap::OnTrap "+GetName());
		//KLog.LogSpam("AnTr","CTrap::OnTrap()");
		return true;
	endproc;

	export proc bool OnRelease(CObjHndl p_xObj)
		//KLog.LogSpam("Trap","CTrap::OnRelease");
		return true;
	endproc;

	// use it for traps, which holds the objects traped in
	export proc bool OnHoldTrap(CObjHndl p_xHndl)
		//KLog.LogSpam("Trap","CTrap::OnHoldTrap");
		var ^CGameObj pxO=p_xHndl.GetObj();
		if(pxO==null)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(pxO);
		if(pxFO!=null)then
			var ^CGameObj pxCurEnemy=pxFO^.GetCurEnemy().GetObj();
			if(pxCurEnemy==this)then
				//KLog.LogSpam("AnTr","CTrap::OnHoldTrap failed");
				return false;
			endif;
		endif;
		pxO=pxO^.GetGroupedParentObj();
		var ^CCharacter pxChar=cast<CCharacter>(pxO);
		if(pxChar!=null)then
			var ^CGameObj pxT=pxChar^.GetTransportObj().GetObj();
			if(pxT==null)then
				pxChar^.TerminateAction();
				pxChar^.SetTrapped(GetHandle());
			else
				var ^CTransportObj pxA = cast<CTransportObj>(pxT);
				if (pxA!=null) then
					pxA^.TerminateAction();
					pxA^.SetTrapped(GetHandle());
				endif;
			endif;
		endif;
		var ^CTransportObj pxA=cast<CTransportObj>(pxO);
		if(pxA!=null && pxA^.CanWalk())then
			pxA^.TerminateAction();
			pxA^.SetTrapped(GetHandle());
		endif;
		OnReveal();
		return true;
	endproc;

	export proc bool OnHoldRelease(CObjHndl p_xHndl)
		//KLog.LogSpam("Trap","CTrap::OnHoldRelease");
		var ^CGameObj pxO=p_xHndl.GetObj();
		if(pxO==null)then return false; endif;
		pxO=pxO^.GetGroupedParentObj();
		var ^CCharacter pxChar=cast<CCharacter>(pxO);
		if(pxChar!=null)then
			pxChar^.SetTrapped(CObjHndl.Invalid());
		endif;
		var ^CTransportObj pxA=cast<CTransportObj>(pxO);
		if(pxA!=null)then
			pxA^.SetTrapped(CObjHndl.Invalid());
		endif;
		return true;
	endproc;

	export proc void Delete()
		//KLog.LogSpam("Trap","CTrap::Delete");
		if(m_pxQuery!=null) then
			m_pxQuery^.ReleaseProcs();
		endif;
		super.Delete();
	endproc;

	export proc void SetPFBlocking()
		//KLog.LogSpam("Trap","CTrap::SetPFBlocking");
	endproc;

	export proc void OnReveal()
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType("smok");
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1)then
			m_axCamouflageLayers[iIdx].SetDisabled(true);
		endif;
		UpdateCamouflageLayers();
		var bitset dwBitset=011111111b;
		SetVisibleMask(dwBitset);
	endproc;

	export proc void OnHide()
		var CFightingObj.CCamouflageLayer xLayer;
		xLayer.SetType("smok");
		var int iIdx=m_axCamouflageLayers.FindEntry(xLayer);
		if(iIdx!=-1)then
			m_axCamouflageLayers[iIdx].SetDisabled(false);
		endif;
		UpdateCamouflageLayers();
	endproc;

endclass;


class CPoisonDung inherit CTrap

	const real		HITPOINTS_COST_PER_SEC = 5.0f;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		//KLog.LogSpam("Trap","CPoisonDung::OnInit");

		m_fDuration=1.0f;

		SetTrapRadius(5.0f);

		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("FGHT");
		m_pxQuery^.AddType("SHIP");

		m_pxQuery^.SetProcs(OnTrap, OnRelease);
		AddRangedBuff("owner_poison");
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		//KLog.LogSpam("Trap","CPoisonDung::OnPostLoad "+GetName());
		var int i, iCountRunningEffects = m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE = m_apxRunningEffects[i];
			if (pxTE != null) then
				pxTE^.SetProcs(OnTrap,OnRelease);
				pxTE^.ReInit();
			else
				//L KLog.LogSpam("Trap","CPoisonDung::OnPostLoad pointer is null");
				return;
			endif;
		endfor;
	endproc;


	export proc bool OnTrap(CObjHndl p_xHndl)
		//KLog.LogSpam("AnTr","CPoisonDung::OnTrap");
		var ^CFightingObj pxObj=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxObj==null)then return false; endif;
		var ^CGameObj pxCurEnemy=pxObj^.GetCurEnemy().GetObj();
		if(pxCurEnemy==this)then
			//KLog.LogSpam("AnTr","CPoisonDung::OnHoldTrap failed");
			return false;
		endif;
		if(pxObj^.GetTransportObj().IsValid())then return false; endif;
		if(!pxObj^.CanWalk())then return false; endif;
		pxObj^.TakeDmg(this);
		OnReveal();
		return true;
	endproc;

	export proc bool OnRelease(CObjHndl p_xObj)
		return true;
	endproc;
endclass;

class CImpResinField inherit CTrap
	const real		HITPOINTS_COST_PER_SEC	= 50.0f;
	const real		LIFETIME				= 30.0;
	const int		INFECT_TIMER=224;
	const int		BURN_TIMER=225;
	
	var bool		m_bFired;
	var string		m_sPath;
	
	
	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);

		m_fDuration = 1.0f;
		SetTrapRadius(5.0f);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.SetProcs(OnTrap, OnRelease, OnTick);
		if(!p_bLoad)then
			m_bFired=false;
		endif;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if((p_sCommand=="Action")&&(p_sMiscParams.Find("/Burn")!=(-1)))then
        	StartBurning(p_sMiscParams);
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ImRe";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_sPath;
		(pxArc^) << m_bFired;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ImRe")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			(pxArc^) << m_sPath;
			(pxArc^) << m_bFired;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void StartBurning(string p_sMiscParams)
		m_sPath=p_sMiscParams;
		if(CheckSpecialActionTimer(m_sPath))then
			AddSpecialActionTimer(m_sPath);
			if(!HasTimer(BURN_TIMER))then
				SetGFX("ninigi_resin_field_fire");
				m_pxQuery^.SetEnabled(true);
				if(!HasTimer(INFECT_TIMER))then
					CreateTimer(INFECT_TIMER,CGameTimeSpan.OneSecond() * 1.0, true);
				endif;
				CreateTimer(BURN_TIMER,CGameTimeSpan.OneSecond() * LIFETIME, false);
				OnReveal();
				m_bFired=false;
			endif;
		endif;
	endproc;

	proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			if(p_rxEvtPtr.GetInt(0) == INFECT_TIMER ) then
				if(!m_bFired)then
					InfectOther();
					m_bFired=true;
				endif;
				DoDamage();
				return;
			elseif(p_rxEvtPtr.GetInt(0) == BURN_TIMER ) then
				StopBurning();
				return;
			endif;
		endif;
		super.HandleEvent(p_rxEvtPtr);
	endproc;

	proc void InfectOther()
		var CObjQuery xQuery;
		xQuery.SetOwner(GetOwner());
		xQuery.SetClass("ninigi_resin_field");
		xQuery.SetAttribsNeg("CurTask","BuildUpB");
		xQuery.RegionCircle(GetPos(),13.0);
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int i, iC = xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CImpResinField pxField = cast<CImpResinField>(xList[i].GetObj());
				if(pxField!=null)then
					pxField^.StartBurning(m_sPath);
				endif;
			endfor;
		endif;
	endproc;
	
	export proc bool IsAbleToFight()
		return false;
	endproc;

	proc void StopBurning()
		SetGFX("ninigi_resin_field");
		m_pxQuery^.SetEnabled(false);
		DeleteTimer(BURN_TIMER);
		DeleteTimer(INFECT_TIMER);
		StartDelayTimer(20.0);
	endproc;
	
	export proc void DoDamage()			
		var CObjQuery xQuery;
		CSrvWrap.GetDiplomacyMgr().AddMyEnemiesToSearch(GetOwner(), xQuery);
		xQuery.SetType("ANML");
		xQuery.SetType("CHTR",true);
		xQuery.SetType("VHCL",true);
		xQuery.SetType("SHIP",true);
		xQuery.RegionCircle(GetPos(),GetHitRange());
		var CObjList xList;
		if(xQuery.Execute(xList))then
			var int i,iC=xList.NumEntries();
			for(i=0)cond(i<iC)iter(i++)do
				var ^CFightingObj pxObj=cast<CFightingObj>(xList[i].GetObj());
				if(pxObj==null)then continue; endif;
				pxObj^.TakeDmg(this);
			endfor;
		endif;
	endproc;

	export proc void Activate()
		super.Activate();
		OnHide();
	endproc;

	export proc bool OnTrap(CObjHndl p_xHndl)
		return false;
	endproc;

	export proc bool OnTick(CObjHndl p_xObj)
		return false;
	endproc;

	export proc bool OnRelease(CObjHndl p_xObj)
		return false;
	endproc;

endclass;


class CResinField inherit CTrap


endclass;

class CQuicksand inherit CTrap

	const real	LIFETIME		= 30.0f;	// in seconds
	const real	RADIUS			= 8.0f;		// in meter
	const real 	TRAPPED_TIME	= 5.0f;		// in seconds

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		//KLog.LogSpam("Trap","CQuicksand::OnInit");

		m_fDuration = TRAPPED_TIME;

		SetTrapRadius(RADIUS);

		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("SHIP");

		m_pxQuery^.SetProcs(OnHoldTrap,OnHoldRelease);
		AddRangedBuff("owner_hold_units");

		SetHitable(false);
		SetSelectable(false);

		if(!p_bLoad)then
			SetVisible(true);
		endif;

		StartDeleteTimer(LIFETIME);
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		//KLog.LogSpam("Trap","CQuicksand::OnPostLoad "+GetName());
		var int i, iCountRunningEffects = m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE = m_apxRunningEffects[i];
			if (pxTE != null) then
				pxTE^.SetProcs(OnHoldTrap,OnHoldRelease);
				pxTE^.ReInit();
			else
				//L KLog.LogSpam("Trap","CQuicksand::OnPostLoad pointer is null");
				return;
			endif;
		endfor;
	endproc;

endclass;

class CPitfall inherit CTrap

	const real DAMAGE = 350.0;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		//KLog.LogSpam("Trap","CPitfall::OnInit");
		SetTrapRadius(5.0f);
		m_fDuration = 1.0f;

		m_pxQuery^.SetOneTime(true);
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("SHIP");
		m_pxQuery^.SetProcs(OnTrap, OnRelease);
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		//KLog.LogSpam("Trap","CPitfall::OnPostLoad "+GetName());
		var int i, iCountRunningEffects = m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE = m_apxRunningEffects[i];
			if (pxTE != null) then
				pxTE^.SetProcs(OnTrap,OnRelease);
				pxTE^.ReInit();
			else
				//L KLog.LogSpam("Trap","CPitTrap::OnPostLoad pointer is null");
				return;
			endif;
		endfor;
	endproc;

	export proc bool OnTrap(CObjHndl p_xHndl)
		//KLog.LogSpam("AnTr","CPitfall::OnTrap");
		var ^CFightingObj pxFight = cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFight==null)then return false; endif;
		if(pxFight^.GetTransportObj().IsValid())then return false; endif;
		if(!pxFight^.CanWalk())then return false; endif;
		var ^CGameObj pxCurEnemy=pxFight^.GetCurEnemy().GetObj();
		if(pxCurEnemy==this)then
			//KLog.LogSpam("AnTr","OnTrap failed");
			return false;
		endif;
		if(HasAnim("attack_front"))then
			SetAnim("attack_front",1);
		endif;
		pxFight^.TakeDmg(this);
		OnReveal();
		return true;
	endproc;

	export proc bool OnRelease(CObjHndl p_xHndl)
		//KLog.LogSpam("Trap","CPitfall::OnRelease");
		StartDelayTimer(20.0);
		m_pxQuery^.SetEnabled(false);
		return true;
	endproc;

	export proc string GetTrappedAnim()
		//KLog.LogSpam("Trap","CPitfall::GetTrappedAnim");
		return "idle_4";
	endproc;

	proc void Activate()
		//KLog.LogSpam("Trap","CPitfall::Activate");
		if(HasAnim("reload"))then
			SetAnim("reload",1);
		endif;
		super.Activate();
		OnHide();
		return();
	endproc;
endclass;

class CMinefield inherit CTrap

	const real CENTER_DAMAGE = 200.0;
	const real EDGE_DAMAGE = 100.0;
	const real RADIUS = 10.0;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		//KLog.LogSpam("Trap","CMinefield::OnInit");

		SetTrapRadius(3.0f);
		m_fDuration = 1.0f;

		m_pxQuery^.SetOneTime(true);
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.AddType("ANML");
		m_pxQuery^.AddType("VHCL");
		m_pxQuery^.AddType("SHIP");
		m_pxQuery^.SetProcs(OnTrap, OnRelease);
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		//KLog.LogSpam("Trap","CMinefield::OnPostLoad "+GetName());
		var int i, iCountRunningEffects = m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE = m_apxRunningEffects[i];
			if (pxTE != null) then
				pxTE^.SetProcs(OnTrap,OnRelease);
				pxTE^.ReInit();
			else
				//L KLog.LogSpam("Trap","CMinefield::OnPostLoad pointer is null");
				return;
			endif;
		endfor;
	endproc;

	export proc bool OnTrap(CObjHndl p_xHndl)
		//KLog.LogSpam("AnTr","CMinefield::OnTrap");
		var ^CFightingObj pxFO=cast<CFightingObj>(p_xHndl.GetObj());
		if(pxFO!=null)then
			var ^CGameObj pxCurEnemy=pxFO^.GetCurEnemy().GetObj();
			if(pxCurEnemy==this)then
				//KLog.LogSpam("AnTr","CMineFieldOnTrap failed");
				return false;
			endif;
		endif;
		var ^CObjList pxEnemies=CSrvWrap.GetObjMgr()^.GetOwnerEnemyList(GetOwner());
		if(pxEnemies==null) then return false; endif;		
		var CObjList xList;

		pxEnemies^.CopySorted(xList,GetPos(),RADIUS);

		var ^CAreaDamage pxDmg = new CAreaDamage(this, GetPos());

		var string sSetting=CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValue("Setting");
		if(sSetting=="Northland")then
			sSetting = "nor";
		elseif(sSetting=="Savanna")then
			sSetting = "sav";
		elseif(sSetting=="Jungle")then
			sSetting = "jng";
		elseif(sSetting=="Icewaste")then
			sSetting = "ice";
		elseif(sSetting=="Ashvalley")then
			sSetting = "ash";
		else
			sSetting = "sav";
		endif;
		AddFX("hit_land_"+sSetting+"_explo_big",2.0);
		OnReveal();
		return true;
	endproc;

	export proc bool OnRelease(CObjHndl p_xHndl)
		//KLog.LogSpam("Trap","CMinefield::OnRelease");
		StartDelayTimer(20.0);
		m_pxQuery^.SetEnabled(false);
		return true;
	endproc;

	export proc string GetTrappedAnim()
		//KLog.LogSpam("Trap","CMinefield::GetTrappedAnim");
		return "idle_4";
	endproc;

	proc void Activate()
		super.Activate();
		OnHide();
	endproc;

endclass;

class CSnareTrap inherit CTrap

	const real DAMAGE_PER_SECOND = 3.0;
	var int m_iState;
	var CObjHndl m_xLastVictimHndl;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		//KLog.LogSpam("Trap","CSnareTrap::OnInit");

		m_xLastVictimHndl=CObjHndl.Invalid();
		SetTrapRadius(3.0f);
		m_fDuration = 9999999.0f;

		m_pxQuery^.SetOneTime(true);
		m_pxQuery^.ClearTypes();
		m_pxQuery^.AddType("CHTR");
		m_pxQuery^.SetProcs(OnHoldTrap,OnHoldRelease,OnTick);
		m_iState = 0;
		AddRangedBuff("owner_hold_units");
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		//KLog.LogSpam("Trap","CSnareTrap::OnPostLoad "+GetName());
		var int i, iCountRunningEffects = m_apxRunningEffects.NumEntries();
		for(i=0)cond(i<iCountRunningEffects)iter(i++)do
			var ^CTrap.CTrapEffect pxTE = m_apxRunningEffects[i];
			if (pxTE != null) then
				pxTE^.SetProcs(OnHoldTrap,OnHoldRelease,OnTick);
				pxTE^.ReInit();
			else
				//L KLog.LogSpam("Trap","CSnareTrap::OnPostLoad pointer is null");
				return;
			endif;
		endfor;
		if (iCountRunningEffects>0) then
			m_pxQuery^.m_bAlreadyReleased = true;
		endif;
	endproc;


	export proc void OnActionEnd(bool p_bBroken)
		//KLog.LogSpam("Trap","CSnareTrap::OnActionEnd state="+m_iState.ToString());
		if(m_iState==0)then
			//hanging anim for trap
			SetAnim("hanging",3);
			if(m_xLastVictimHndl.IsValid())then
				var ^CFightingObj pxFO = cast<CFightingObj>(m_xLastVictimHndl.GetObj());
				//hanging anim for victim
				if(pxFO!=null)then
					pxFO^.SetAnim(GetTrappedAnim(),3);
				endif;
			endif;
		else
			SetAnim("standanim",3);
		endif;
	endproc;

	export proc string GetReleaseAnim()
		//KLog.LogSpam("Trap","CSnareTrap::GetReleaseAnim");
		return "all_snar_trap_end";
	endproc;

	export proc string GetCatchAnim()
		//KLog.LogSpam("Trap","CSnareTrap::GetCatchAnim");
		return "all_snar_trap_catching";
	endproc;

	export proc string GetDieInTrapAnim()
		//KLog.LogSpam("Trap","CSnareTrap::GetDieInTrapAnim");
		return "snare_trap_dying";
	endproc;

	export proc void SetReady()
		//KLog.LogSpam("Trap","CSnareTrap::SetReady");
		AnimAction("bending");
		m_iState = 1;
		super.SetReady();
	endproc;

	export proc bool OnHoldRelease(CObjHndl p_xObj)
		//KLog.LogSpam("Trap","CSnareTrap::OnHoldRelease");
		m_xLastVictimHndl=CObjHndl.Invalid();
		StartDelayTimer(1.0);
		AnimAction("bending");
		m_iState = 1;

		var ^CCharacter pxChar=cast<CCharacter>(p_xObj.GetObj());
		if(pxChar!=null)then
			//KLog.LogSpam("Tarp","snare trap: fall to ground "+GetReleaseAnim());
	/*		var vec3 vImpulse = {1.0,1.0,1.0};
			pxChar^.FallActionDest(GetPos()+vImpulse,"hit_back","getting_up",0.0);*/
			pxChar^.ShowWeapons();
			pxChar^.SetAnim(GetReleaseAnim(),1);
		endif;
		OnHide();
		return super.OnHoldRelease(p_xObj);
	endproc;

	export proc bool OnHoldTrap(CObjHndl p_xObj)
		//KLog.LogSpam("AnTr","CSnareTrap::OnHoldTrap");
		//KLog.LogWarn("Manni","OnHoldTrap!");
		m_xLastVictimHndl=p_xObj;
		AnimAction("catching");
		m_iState = 0;

		var ^CGameObj pxO=p_xObj.GetObj();
		if(pxO==null)then return false; endif;
		var ^CFightingObj pxFO=cast<CFightingObj>(pxO);
		if(pxFO!=null)then
			var ^CGameObj pxCurEnemy=pxFO^.GetCurEnemy().GetObj();
			if(pxCurEnemy==this)then
				//KLog.LogSpam("AnTr","CSnareTrap::OnHoldTrap failed");
				return false;
			endif;
		endif;
		
		pxO=pxO^.GetGroupedParentObj();
		var ^CCharacter pxChar=cast<CCharacter>(pxO);
		if(pxChar!=null)then
			var ^CGameObj pxT=pxChar^.GetTransportObj().GetObj();
			if(pxT==null)then
				pxChar^.TerminateAction();
				pxChar^.SetTrapped(GetHandle());
				pxChar^.HideWeapons();
				pxChar^.SetAnim(GetCatchAnim(),1);

				var CFourCC xL="we";
				pxChar^.LinkAction(GetHandle(),xL);
				var vec3 vRot = {0.0,0.0,0.0};
				vRot.SetY(3.14f);
				var Quat qRot;
				qRot.FromVec3(vRot);
				pxChar^.SetRot(qRot);
				return true;
			endif;
		endif;
		return false;
	endproc;

	export proc bool OnTick(CObjHndl p_xObj)
		//KLog.LogSpam("Trap","CSnareTrap::OnTick");
		m_xLastVictimHndl=p_xObj;
		var ^CGameObj pxO = p_xObj.GetObj();
		if (pxO!=null) then
		    // deal direct damage to unit in trap and notify this unit who dealt the damage (skulls calculation)
			cast<CFightingObj>(pxO)^.TakeDmg(this);
			OnReveal();
			return true;
		endif;
		return false;
	endproc;

	export proc string GetTrappedAnim()
		//KLog.LogSpam("Trap","CSnareTrap::GetTrappedAnim");
		return "all_snar_trap_hanging";
	endproc;

endclass;


class CMarketplace inherit CWarehouse

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;

endclass;

class CHarbour inherit CBuilding

//	var CObjList		m_xDockedShips;
	var int				m_iMaxShipsInDock;
	var int 			m_iShipsInConstruction;
	var array CObjHndl  m_axDockedShips;
	var int 			m_iNumDockedShips;
	var CObjHndl		m_xCraneObj1;
	var CObjHndl		m_xCraneObj2;
	var CObjHndl		m_xHarbourCrane;

	export constructor()
		m_iMaxShipsInDock = 1;
		m_axDockedShips = 1;
		m_iShipsInConstruction = 0;
		m_iNumDockedShips = 0;
	endconstructor;

	export destructor()
		if(m_xCraneObj1.IsValid())then m_xCraneObj1.GetObj()^.Delete();endif;
		if(m_xCraneObj2.IsValid())then m_xCraneObj2.GetObj()^.Delete();endif;
		if(m_xHarbourCrane.IsValid())then m_xHarbourCrane.GetObj()^.Delete();endif;
	enddestructor;

	export proc void OnInit(bool p_bLoad)
		m_bHealthBuilding = true;
		super.OnInit(p_bLoad);
		SetRallySite(true);

		// overwrite types in objquery used for healing
		m_xFunctionUnits.SetType("SHIP");										// ... this are Ships ...

		var ^CAttribs pxAttr = GetAttribs();
		if(pxAttr!=null) then
			pxAttr^.SetValue("fishDelivery",true);
		endif;

		var int iNumDocks = 0;
		var vec3 vDummy;
		var CFourCC xLink;
		var int i;
		for(i=1)cond(i<6)iter(i++)do
			xLink = "Do_" + i.ToString();
			if (!GetLinkPosObj(xLink, vDummy)) then
				iNumDocks = i-1;
				break;
			endif;
		endfor;

		if(iNumDocks<2)then iNumDocks = 2; endif;


		//KLog.LogSpam("Harbour", "Number of docks:"+iNumDocks.ToString());

		m_iMaxShipsInDock = iNumDocks;
		m_axDockedShips = iNumDocks;
		for(i=0)cond(i<m_iMaxShipsInDock)iter(i++)do
			m_axDockedShips[i] = CObjHndl.Invalid();
		endfor;

		AddRangedBuff("owner_healing_harbour");
	endproc;

	export proc void SetReady()
		if(HasAnim("standanim"))then
			SetAnim("standanim",3);
		endif;
		if(GetTribeName()=="Hu")then
			if(!m_xHarbourCrane.IsValid())then
				var ^CGameObj pxHarbourCrane=CSrvWrap.GetObjMgr()^.CreateObj("hu_harbour_crane",GetOwner(),GetPos());
				if(pxHarbourCrane!=null)then
					m_xHarbourCrane=pxHarbourCrane^.GetHandle();
					var CFourCC xLink="Cr_3";
					pxHarbourCrane^.LinkAction(GetHandle(),xLink);
				endif;
			endif;
		endif;
		super.SetReady();
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Hrbr"; //Harbour base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xCraneObj1.DoKArc(pxArc^);
		m_xCraneObj2.DoKArc(pxArc^);
		m_xHarbourCrane.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Hrbr")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xCraneObj1.DoKArc(pxArc^);
			m_xCraneObj2.DoKArc(pxArc^);
			m_xHarbourCrane.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	export proc void ShipBuildFinished()
		//m_iShipsInConstruction--;
		if (m_iShipsInConstruction<0) then
			m_iShipsInConstruction = 0;
			KLog.LogWarn("Harbour", "There is something fishy in the harbour");
		endif;
	endproc;

	proc int GetFreeDockIndex()
		var int iIndex = -1;
		var int i;
		for(i=0)cond(i<m_iMaxShipsInDock)iter(i++)do
			if (!m_axDockedShips[i].IsValid()) then
				iIndex = i+1;
				break;
			endif;
		endfor;
		//KLog.LogSpam("Harbour", "GetFreeDockIndex:"+iIndex.ToString());
		return iIndex;
	endproc;

	export proc bool GetDockPos(ref vec3 po_rvPos, ref Quat po_rqRot)
		var int iIndex = GetFreeDockIndex();
		if (iIndex>0) then
			var CFourCC xLink = "Do_"+iIndex.ToString();
			return GetLinkPosRotWorld(xLink, po_rvPos, po_rqRot);
		else
			return false;
		endif;
	endproc;

	export proc CFourCC GetDockLink()
		var int iIndex = GetFreeDockIndex();
		if (iIndex>0) then
			var CFourCC xLink = "Do_"+iIndex.ToString();
			return xLink;
		else
			var CFourCC xLink = "";
			return xLink;
		endif;
	endproc;

	export proc bool CheckCanBuildAndIncrease(string p_sTTPath)
		if (p_sTTPath.Find("Build/SHIP")!=-1) then
			if (!HasFreeDocks()) then
				CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "Feedback\tHarbour is full!");
				return false;
			endif;
			//m_iShipsInConstruction++;
		endif;
		return true;
	endproc;

	export proc bool CanDeliver(string p_sClassName)
			if (!HasFreeDocks()) then
				return false;
			endif;
		return super.CanDeliver(p_sClassName);
	endproc;

	export proc void Action(string p_sTTPath)
		//KLog.LogSpam("Harbour", "Enter Action()"+p_sTTPath);
		if (CheckCanBuildAndIncrease(p_sTTPath)) then
			super.Action(p_sTTPath);
		endif;
		return;
	endproc;

	export proc void CheckCancelBuildDecrease(string p_sTTPath)
		if (p_sTTPath.Find("Build/SHIP")!=-1) then
			//m_iShipsInConstruction--;
			if (m_iShipsInConstruction<0) then
				m_iShipsInConstruction = 0;
			endif;
		endif;
	endproc;

	export proc void CancelAction(string p_sTTPath)
		super.CancelAction(p_sTTPath);
		CheckCancelBuildDecrease(p_sTTPath);
	endproc;

	export proc void StartWorkAnim()
		//if(m_xCraneObj1.IsValid())then SetCraneAnim(m_xCraneObj1,true);endif;
		//if(m_xCraneObj2.IsValid())then SetCraneAnim(m_xCraneObj2,true);endif;
		if(m_xHarbourCrane.IsValid())then SetCraneAnim(m_xHarbourCrane,true);endif;
	endproc;

	export proc void StopWorkAnim()
		//if(m_xCraneObj1.IsValid())then SetCraneAnim(m_xCraneObj1,false);endif;
		//if(m_xCraneObj2.IsValid())then SetCraneAnim(m_xCraneObj2,false);endif;
		if(m_xHarbourCrane.IsValid())then SetCraneAnim(m_xHarbourCrane,false);endif;
	endproc;

	proc bool SetCraneAnim(CObjHndl p_xCraneHandle, bool p_bStart)
		var ^CGameObj pxCrane=p_xCraneHandle.GetObj();
		if(pxCrane!=null)then
			if(p_bStart)then
				if(pxCrane^.GetCurrentAnimName()!=WORK_ANIM_NAME&&pxCrane^.HasAnim(WORK_ANIM_NAME)) then
					pxCrane^.SetAnim(WORK_ANIM_NAME,3);
					return(true);
				else
					return(false);
				endif;
			else
				if(pxCrane^.GetCurrentAnimName()==WORK_ANIM_NAME) then
					pxCrane^.EndCurrentLoopAnim();
					return(true);
				else
					return(false);
				endif;
			endif;
		else
			return(false);
		endif;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		//KLog.LogSpam("Harbour", "Enter HandleGamePlayCommand()"+p_sCommand);
		if (p_sCommand=="SetRallyPoint") then
			if (p_vPos.GetZ() > CSrvWrap.GetScapeMgr().GetSeaLevel() ) then
				CSrvWrap.SendGenericEvtToPlayer(GetOwner(), "Feedback\tSet RallyPoint on water!");
	        else
	        	var CObjHndl xInvalid;
	        	if(p_pxObject!=null)then
	        		xInvalid=p_pxObject^.GetHandle();
	        	endif;
	            SetRallyPoint(p_vPos,xInvalid);
	        endif;
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;

	export proc bool AddDockedShip(^CGameObj p_pxShip, CFourCC p_xLink)
		//KLog.LogSpam("Harbour", "AddDockedShip() at:"+p_xLink.AsString());
		if (p_pxShip != null) then
			if (m_iNumDockedShips >= m_iMaxShipsInDock) then return false; endif;
			var string sDock = p_xLink.AsString();
			var int iDock = (sDock.Mid(3)).ToInt() - 1;
			if (iDock<0) then return false; endif;
			if (iDock>=m_iMaxShipsInDock) then return false; endif;

			if (m_axDockedShips[iDock].IsValid()) then
				return false;
			endif;

			m_axDockedShips[iDock] = p_pxShip^.GetHandle();
			m_iNumDockedShips++;
			//KLog.LogSpam("Harbour", "AddDockedShip() at:"+iDock.ToString());
			return true;
		endif;
		return false;
	endproc;

	export proc void RemDockedShip(^CGameObj p_pxShip)
		if (p_pxShip!=null) then
			var CObjHndl xHandle = p_pxShip^.GetHandle();

			var int i;
			for(i=0)cond(i<m_iMaxShipsInDock)iter(i++)do
				if (m_axDockedShips[i] == xHandle) then
					m_axDockedShips[i] = CObjHndl.Invalid();
					m_iNumDockedShips--;

					var CFourCC xLink = "Do_"+(i+1).ToString();
					var vec3 vPos;
					var Quat qRot;
					GetLinkPosRotWorld(xLink, vPos, qRot);
					p_pxShip^.SetPos(vPos);
					p_pxShip^.SetRot(qRot);

					//L KLog.LogSpam("Harbour", "RemDockedShip() at:"+i.ToString());
					return;
				endif;
			endfor;
		endif;
	endproc;

	export proc bool HasFreeDocks()
		if (m_iNumDockedShips < m_iMaxShipsInDock) then
			return true;
		endif;
		return false;
	endproc;

endclass;

class CVirtualProduceUnit inherit CBuilding

	export var CObjHndl m_xParent;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);
		SetHitable(false);
		SetSelectable(false);
		SetVisible(false);
		SetPlaceBlocker(false);
		if(!p_bLoad)then
			SetCanFightAttrib(false);
		endif;
	endproc;

	proc void OnActionStart()
	endproc;

	export proc void Die()
		Delete();
	endproc;

	export proc void Init(CObjHndl p_xParent)
		m_xParent = p_xParent;
		var CFourCC xLink;
		LinkAction(m_xParent, xLink);
	endproc;

	export proc bool IsAbleToWalk()
		return false;
	endproc;

	export proc bool IsAbleToFight()
		return false;
	endproc;

	export proc void Damage(real p_fDamage)
	endproc;

	export proc void Action(string p_sTTPath)
		var CObjHndl xPyCO;
		var CAction.CResourceCosts xCosts;
		if(CRequirementsMgr.Get().CheckConditionsAndPay(this, p_sTTPath, xPyCO, xCosts))then
			var ^CAction pxTask= cast<CAction>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Action"));
			pxTask^.Init(m_xParent,p_sTTPath, xCosts);
			pxTask^.SetPyCO(xPyCO);
			AddTask(pxTask,true);
	    endif;
    endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ViPU";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,0);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xParent.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ViPU")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xParent.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();

		var string sObjName = GetName();
		var string sParentName = "Invalid";
		var string sObjPos = GetPos().ToString();
		if(m_xParent.IsValid())then
			sParentName = m_xParent.GetObj()^.GetName();
		endif;
		var string sMessage ="CVirtualProduceUnit name='"+sObjName+"' parent='"+sParentName+"' pos='"+sObjPos+"'";
		if(!m_xParent.IsValid())then
			var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
			System.Assert(pxLevel!=null);
			if(pxLevel^.IsEditable())then
				Windows.DbgPrint("DETECTED orphant virtual produce unit: "+sMessage);
				if(Windows.MessageBox("Orphant CVirtualProduceUnit detected",sMessage+"\n\n    Delete Object?",050004h)==6)then
					Windows.DbgPrint("DELETED orphant virtual produce unit: "+sMessage);
					Delete();
					return;
				endif;
			endif;
		endif;
		GetFSM()^.Enable(true);
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(!m_bBuildingReady)then
			return;
		else
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;
	endproc;

	export proc CObjHndl GetParent()
		return m_xParent;
	endproc;

	export proc void SetPFBlocking()
	endproc;

endclass;

class CBunker inherit CTower

	const int	MAX_CHARS = 4;

	var CObjList	m_xChars;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="BUba"; //Bunker base
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xChars.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BUba")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=2)then
				m_xChars.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);

		SetCanWalk(false);
		SetCanSwim(false);
		SetCanFly(false);
		SetRallySite(false);

		if(!p_bLoad)then
			SetTransportClass(1);
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("max_passengers",MAX_CHARS);
			endif;
		endif;
	endproc;


	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sMiscParams.Find("/DismountAll") != -1)then
			DismountAll();
			return;
		elseif(p_sMiscParams.Find("/Dismount")>=0) then
			if(p_pxObject!=null) then
				RemChar(p_pxObject^.GetHandle());
			endif;
		endif;
		super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
	endproc;

	export proc void AddChar(CObjHndl p_xO)
		if (p_xO.IsValid() && m_xChars.FindEntry(p_xO)<0 && m_xChars.NumEntries() < MAX_CHARS) then
			m_xChars.Include(p_xO);

			var ^CCharacter pxC = cast<CCharacter>(p_xO.GetObj());
			if (pxC!=null) then
				var CFourCC xL = "NOPE";
				pxC^.LinkAction(GetHandle(), xL);
				pxC^.SetPos(GetPos());
				pxC^.SetVisible(false);
				pxC^.SetSelectable(false);
				pxC^.SetTransportObj(GetHandle());
			endif;
			UpdateCharsAttr();
		endif;
	endproc;

	export proc void RemChar(CObjHndl p_xO)
		if (m_xChars.RemEntry(p_xO)) then
			var ^CCharacter pxC = cast<CCharacter>(p_xO.GetObj());
			if(pxC!=null) then
				pxC^.SetTransportObj(CObjHndl.Invalid());
				pxC^.SetPos(GetPos());
				pxC^.SetVisible(true);
				pxC^.SetSelectable(true);
				var vec3 vP;
				CSrvWrap.GetObjMgr()^.GetFreePos(vP,this,GetPos(),null,true,false,false);
				pxC^.GoTo(vP,true,pxC^.GetDefaultSpeed(),true,true);
			endif;
			UpdateCharsAttr();
		endif;
	endproc;

	export proc void DismountAll()
		while(m_xChars.NumEntries() > 0) do
			RemChar(m_xChars[0]);
		endwhile;
	endproc;

	proc void UpdateCharsAttr()
		var string sM = "";

		var int i, iC = m_xChars.NumEntries();
		for(i=0) cond(i<iC) iter(++i) do
			var ^CGameObj pxO = m_xChars[i].GetObj();
			if(pxO!=null) then
				sM += pxO^.GetGuid().ToString() + "\n";
			endif;
		endfor;

		var ^CAttribs pxA = GetAttribs();
		if(pxA!=null) then
			pxA^.SetValue("passenger_guids", sM);
		endif;
	endproc;

	export proc void SetReady()
		super.SetReady();
	endproc;

	export proc void Die()
		while(m_xChars.NumEntries() > 0) do
			RemChar(m_xChars[0]);
		endwhile;
		super.Die();
	endproc;

	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(IsBuildMode())then return false; endif;
		if(m_xChars.NumEntries() <= 0)then return false; endif;
		if(GetProjectile()!="" && p_pxEnemy!=null) then

			var int i, iC = m_xChars.NumEntries();
			for(i=0) cond(i<iC) iter(++i) do
				var ^CArrow pxArrow=cast<CArrow>(CSrvWrap.GetObjMgr()^.CreateObj(GetProjectile(),GetOwner(),GetProjectileStartPos()));
				if(pxArrow!=null)then
					pxArrow^.SetXtraDelay(this, p_pxEnemy, 1.0f +0.1f * i.ToReal());
					pxArrow^.LinkAction(GetHandle(),GetProjectileLink());
				endif;
			endfor;

		endif;
		return false;
	endproc;

endclass;

class CSeasCarrier inherit CSwimmingHarbour

	var int m_iBuildUpType;
	var ^CBuildUpBase m_pxBuildUp;

	export proc void SetReady()
		super.SetReady();

		//SB#9309 HOTFIX moved from OnInit because non visible links corrupt selection circle and health bar rendering
		if(m_bBuildingReady && (m_pxBuildUp==null || m_iBuildUpType==CBuildUpBase.TYPE_NONE))then
			m_iBuildUpType = CBuildUpBase.TYPE_WEAPON;
			m_pxBuildUp = CBuildUpFactory.Get().CreateBuildUp(m_iBuildUpType);
			m_pxBuildUp^.SetParent(GetHandle());
			var ^CGameObj pxO = CSrvWrap.GetObjMgr()^.CreateObj("seas_carrier_turret", GetOwner());
			m_pxBuildUp^.AddObj(pxO^.GetHandle(), "we");
			cast<CBuildUpWeapon>(m_pxBuildUp)^.SetWeaponClass(GetClassName());
			cast<CBuildUpWeapon>(m_pxBuildUp)^.SetCanRotate(true);
			//cast<CBuildUpWeapon>(m_pxBuildUp)^.SetAdditionalWeapon(true);
			cast<CBuildUpWeapon>(m_pxBuildUp)^.SetAutoAttack(true);
		endif;
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null)then
				pxAttr^.SetValue("AttackBuilding", true);
			endif;
			SetCanFightAttrib(true);
			m_iBuildUpType=CBuildUpBase.TYPE_NONE;
			m_pxBuildUp=null;
		endif;
	endproc;

	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)

		if(HasBuildUp())then
			var ^CBuildUpWeapon pxWeapon = cast<CBuildUpWeapon>(GetBuildUp());
			if(pxWeapon!=null)then
				if(GetRightHandWeapon()==GetCurrentWeapon())then
					if(pxWeapon^.AttackEnemy(p_pxEnemy, p_vTarget))then
						if(HasAnim("attack_front_secondary"))then
							SetAnim("attack_front_secondary",1);
						endif;
						return false;
					endif;
				endif;
			endif;
		endif;

		DoCaptainAttackAnim();
		return super.AttackEnemy(p_pxEnemy, p_vTarget, p_rbRotated);

	endproc;

	proc void OnDefend(^CGameObj p_pxEnemy)
		if(p_pxEnemy!=null)then
			HandleGamePlayCommand("Action",p_pxEnemy, p_pxEnemy^.GetPos(), "/AttackSrv");
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);

		var CFourCC xBase="SCar"; //SeasCarrier
		var int iVersion = CTransportObj.KARCVERSION; // !!! be really carefull if you change something here (version shared with CTransportObj)
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,iVersion);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		(pxArc^) << m_iBuildUpType;
		if(m_iBuildUpType!=CBuildUpBase.TYPE_NONE)then
			m_pxBuildUp^.DoKArc(pxArc^, iVersion);
		endif;
		pxWalk^.Close();
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SCar")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVer=p_pxReaderNode^.GetVersion();
			if(iVer>=1)then
				(pxArc^) << m_iBuildUpType;
				if(m_iBuildUpType!=CBuildUpBase.TYPE_NONE)then
					m_pxBuildUp = CBuildUpFactory.Get().CreateBuildUp(m_iBuildUpType);
					m_pxBuildUp^.SetParent(GetHandle());
					m_pxBuildUp^.DoKArc(pxArc^, iVer);

					//reset buildup because of ivalid sharing of DoKArc version in buildup
					if(iVer==1)then
						m_pxBuildUp^.Kill();
						m_iBuildUpType=CBuildUpBase.TYPE_NONE;
						m_pxBuildUp=null;
					endif;
				endif;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc ^CBuildUpBase GetBuildUp()
		return m_pxBuildUp;
	endproc;

	export proc bool HasBuildUp()
		return m_iBuildUpType!=CBuildUpBase.TYPE_NONE;
	endproc;

endclass;

class CSwimmingHarbour inherit CHarbour

	var CObjList m_xTurtles;
	var real m_fAdditionalHitpoints;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="SHba")then //obsolete
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CObjHndl xInvalid;
			xInvalid.DoKArc(pxArc^);
			if(p_pxReaderNode^.GetVersion()==2) then
				xInvalid.DoKArc(pxArc^);
			endif;
		elseif(p_pxReaderNode^.GetType()=="SHab")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			if(p_pxReaderNode^.GetVersion()>=1)then
				m_xTurtles.DoKArc(pxArc^);
			endif;
			if(p_pxReaderNode^.GetVersion()>=2)then
				pxArc^ << m_fAdditionalHitpoints;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="SHab";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xTurtles.DoKArc(pxArc^);
		pxArc^ << m_fAdditionalHitpoints;
		pxWalk^.Close();
	endproc;

	export destructor()
		var int i,iC=m_xTurtles.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xTurtles[i].IsValid())then continue; endif;
			m_xTurtles[i].GetObj()^.Delete();
		endfor;
	enddestructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);

		SetCanWalk(false);
		SetCanSwim(true);
		SetCanFly(false);
		SetRallySite(true);

		if(!p_bLoad)then
			var ^CAttribs pxAttr = GetAttribs();
			if(pxAttr!=null) then
				pxAttr^.SetValue("MovingBuilding",true);
			endif;
			CreatePersonalProduceUnit(false);
			if(GetClassName()=="aje_floating_harbour")then
				SetCanFightAttrib(false);
			endif;
		else
			UpdateAdditionalHitpoints();
		endif;
	endproc;

	export proc real GetTechTreeHitpoints()
		return super.GetTechTreeHitpoints()+m_fAdditionalHitpoints;
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode()) then SetReady(); endif;
	endproc;

	export proc void SetReady()
		var ^CVirtualProduceUnit pxUnit = cast<CVirtualProduceUnit>(m_xProduceUnit.GetObj());
		if(pxUnit!=null)then
			pxUnit^.SetReady();
		endif;
		super.SetReady();

		//SB#16526 HOTFIX moved from OnInit because non visible links corrupt selection circle and health bar rendering
		if(GetClassName()=="aje_floating_harbour" && m_bBuildingReady && m_xTurtles.NumEntries()==0)then

			var ^CGameObj pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			var CFourCC xLink="Cr_1";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());

			pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			xLink="Cr_2";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());

			pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			xLink="Cr_3";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());

			pxObj=CSrvWrap.GetObjMgr()^.CreateObj("aje_floating_harbour_macrolemys",GetOwner());
			xLink="Cr_4";
			pxObj^.FlexLinkAction(GetHandle(),xLink,0.0,{0.0,0.0,0.0},"swim_1");
			AddGroupedChildren(pxObj^.GetGuid());
			m_xTurtles.Include(pxObj^.GetHandle());

		endif;
	endproc;

	export proc void UpdateAdditionalHitpoints()
		var int iLevel=GetLevel();
		if(iLevel==0)then
			m_fAdditionalHitpoints=0.0;
		elseif(iLevel==1)then
			m_fAdditionalHitpoints=100.0;
		elseif(iLevel==2)then
			m_fAdditionalHitpoints=300.0;
		elseif(iLevel==3)then
			m_fAdditionalHitpoints=600.0;
		elseif(iLevel==4)then
			m_fAdditionalHitpoints=1100.0;
		endif;
	endproc;

	export proc void OnTechTreeChange()
		super.OnTechTreeChange();
	endproc;

	export proc void OnTechTreeChange(ref CStringArray p_rasChanges)
		UpdateAdditionalHitpoints();
		super.OnTechTreeChange(p_rasChanges);
	endproc;

	export proc bool SetLevelClean(int p_iLevel)
		if(!m_bBuildingReady)then
			return false;
		endif;
		return super.SetLevelClean(p_iLevel);
	endproc;

	export proc bool DoesCountInUnitLimit()
		return true;
	endproc;


	export proc void Die()
		super.Die();
		Delete();
	endproc;

	export proc void SailToTask(vec3 p_vDest)

		if(!m_bBuildingReady)then return; endif;

		var vec3 vDestination = p_vDest;

		var real fSeaLevel = CSrvWrap.GetScapeMgr().GetSeaLevel();
		var vec3 vPos = GetPos();
		vPos.SetZ(Math.Max(vPos.GetZ(),fSeaLevel));

		SetPos(vPos);

		vDestination.SetZ(fSeaLevel - 1.0);


		GoTo(vDestination,true,GetDefaultSpeed(),true,false);
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)

		var ^CVirtualProduceUnit pxUnit = cast<CVirtualProduceUnit>(GetProduceUnit().GetObj());
		if(pxUnit==null)then
			if(m_bBuildingReady)then
				super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
			endif;
			return;
		endif;

		if(p_sCommand == "Action")then
			if(p_sMiscParams.Find("/Build/SHIP/aje")!=-1) then
				pxUnit^.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
				return;
			elseif(p_sMiscParams.Find("/Build/SHIP/seas")!=-1) then
				pxUnit^.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
				return;
			elseif(p_sMiscParams.Find("/Build/VHCL/seas")!=-1) then
				pxUnit^.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
				return;
			endif;
		elseif(p_sCommand == "BuildUp")then
			BuildUp(p_sMiscParams);
			return;
		elseif(p_sCommand == "Fishing")then
			Fishing(p_pxObject, false);
			return;
		elseif (p_sCommand.Find("SetRallyPoint")!=-1) then
			var CObjHndl xHndl;
			if(p_pxObject!=null)then
				xHndl = p_pxObject^.GetHandle();
			endif;
            SetRallyPoint(p_vPos,xHndl);
            return;
		elseif(p_sCommand == "Cancel")then
			if(pxUnit!=null)then
				pxUnit^.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
				CheckCancelBuildDecrease(p_sMiscParams);
				return;
			endif;
		endif;

		if((p_sMiscParams.Find("/Kill")!=-1 || p_sCommand=="Kill") || m_bBuildingReady)then
			super.HandleGamePlayCommand(p_sCommand, p_pxObject, p_vPos, p_sMiscParams);
		endif;

	endproc;

	export proc void Fishing(^CGameObj p_pxObject, bool p_bQueue)
		if(!m_bBuildingReady)then return; endif;
		var ^CFishing pxTask=cast<CFishing>(CSrvWrap.GetUSLFactoryMgr().CreateState(GetFSM(),"Fishing"));
	   	pxTask^.Init(GetHandle(),p_pxObject^.GetHandle());
    	AddTask(pxTask, p_bQueue);
	endproc;

endclass;

class CMagicCauldron inherit CBuilding

	const real 	EFFECT_RANGE = 30.0f;
	const real	EFFECT_BONUS_AMOUNT = 10.0f;

	static var array string ms_asTypes;

	export constructor()
		if (ms_asTypes.NumEntries()==0) then
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("VHCL");
		endif;
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd = ApplyBonus;
		m_xSink.m_xOnObjRem = RemoveBonus;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MgCl")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^<< xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	export proc void SetReady()
		super.SetReady();
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(EFFECT_RANGE, EFFECT_RANGE, 0.0f);
			CreatePersonalRegion("MagicCauldron_" + Random.GetInt().ToString(), vE, 010b);
			AddRangedBuff("owner_more_damage");
		endif;
	endproc;


	proc bool ApplyBonus(CObjHndl p_xObj)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner())) then
			if (ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0) then
				var real fBonus = pxFO^.GetDmg()*0.01f*EFFECT_BONUS_AMOUNT;

				var ^CBoniBucket pxBB = pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
				pxBB^.AddEntry("Cauldron", fBonus);
				pxFO^.ForceBoniUpdate();
			endif;
		endif;
		return true;
	endproc;

	proc bool RemoveBonus(CObjHndl p_xObj)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner())) then
			if (ms_asTypes.FindEntry(pxFO^.GetType().AsString())>=0) then
				var ^CBoniBucket pxBB = pxFO^.GetBoniBucket(CFightingObj.BONUS_DAMAGE);
				pxBB^.RemEntry("Cauldron");
				pxFO^.ForceBoniUpdate();
			endif;
		endif;
		return true;
	endproc;

endclass;

class CSkullProtector inherit CBuilding

	//BadGun Tuning: Skull Protector
	const real 	EFFECT_RANGE = 30.0f;
	export const string PATH = "/Filters/Aje/Upgrades/aje_skull_protector/protect_skulls";

	static var array string ms_asTypes;

	export constructor()
		if (ms_asTypes.NumEntries()==0) then
			ms_asTypes.AddEntry("CHTR");
			ms_asTypes.AddEntry("ANML");
			ms_asTypes.AddEntry("VHCL");
			ms_asTypes.AddEntry("SHIP");
			ms_asTypes.AddEntry("BLDG");
			ms_asTypes.AddEntry("NEST");
		endif;
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		m_xSink.m_xOnObjAdd = ApplyBonus;
		m_xSink.m_xOnObjRem = RemoveBonus;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="MgCl")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var CGuid xG;
			pxArc^<< xG;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	export proc void SetReady()
		super.SetReady();
		if(!HasPersonalRegion())then
			var vec3 vE;vE.SetXYZ(EFFECT_RANGE, EFFECT_RANGE, 0.0f);
			CreatePersonalRegion("SkullProtector_" + Random.GetInt().ToString(), vE, 010b);
			//AddRangedBuff("owner_more_damage");
		endif;
	endproc;


	proc bool ApplyBonus(CObjHndl p_xObj)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null && pxFO^.GetClassName()!="aje_skull_protector")then
			if(CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner())) then
				pxFO^.SetEffectFlag(CFightingObj.EFFECT_SKULL_PROTECTOR,true);
			endif;
		endif;
		return true;
	endproc;

	proc bool RemoveBonus(CObjHndl p_xObj)
		var ^CFightingObj pxFO = cast<CFightingObj>(p_xObj.GetObj());
		if(pxFO!=null && CSrvWrap.GetDiplomacyMgr().GetIsFriend(GetOwner(), pxFO^.GetOwner())) then
			pxFO^.SetEffectFlag(CFightingObj.EFFECT_SKULL_PROTECTOR,false);
		endif;
		return true;
	endproc;

endclass;

class CKennel inherit CBuilding

	const real		ACTION_RADIUS		= 50.0f;	// the action radius

	var CObjHndl	m_xNest;

	export constructor()
	endconstructor;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="DiKn")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xNest.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void SetReady()
		super.SetReady();
		if(m_xNest.IsValid()) then return; endif;
		var ^CNest pxNest = cast<CNest>(CSrvWrap.GetObjMgr()^.CreateObj(GetClassName()+"_nest",GetOwner(),GetPos(),GetRotation()));
		if(pxNest!=null) then
			m_xNest = pxNest^.GetHandle();
			AdjustNestAreas(pxNest);
			pxNest^.SetVisible(false);
			var CFourCC xT="NOPE";
			pxNest^.LinkAction(GetHandle(), xT);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="DiKn";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xNest.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void OnPostLoad()
		super.OnPostLoad();
		if(!IsBuildMode()) then
			SetReady();
		endif;
	endproc;

	proc void AdjustNestAreas(^CNest p_pxNest)
		var ^CRegion pxRgn = p_pxNest^.GetActionAreaPtr();

		var vec3 vE; vE.SetXYZ(ACTION_RADIUS, ACTION_RADIUS, 0.0f);
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);

		//vE.SetXYZ(10.0f, 10.0f, 0.0f);
		pxRgn = p_pxNest^.GetSafeAreaPtr();
		pxRgn^.Clear();
		pxRgn^.AddSubRegion(010b, GetPos(), vE);
	endproc;

	export proc void Die()
		var ^CNest pxN = cast<CNest>(m_xNest.GetObj());
		if(pxN!=null) then
			pxN^.Die();
		endif;
		super.Die();
	endproc;
endclass;

class CDecoBuilding inherit CBuilding

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetHitable(false);
		SetSelectable(false);
	endproc;

	export proc int GetTechTreeAggressiv()
		return -1;
	endproc;

	export proc void Damage(real p_fDamage)
	endproc;

endclass;

class CBuildingCorpse inherit CUniversalCorpse

	var string	m_sGfx;
	var int		m_iState;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="BCor")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			pxArc^ << m_iState;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="BCor";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,2);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_iState;
		pxWalk^.Close();
	endproc;

	export proc bool ShouldStay(string p_sGfxName)
		if(p_sGfxName=="hcl13_gate")then
			return true;
		elseif(p_sGfxName=="PT_Citywall_Gate_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_bunker_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_big_cannon_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_big_cannon_rotator_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_defense_turret_dest")then
			return true;
		elseif(p_sGfxName=="seas_hq_machinegun_nest_dest")then
			return true;
		endif;
		return false;
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		SetVisible(true);
	endproc;

	export proc void Init(string p_sGfx, string p_sName, real p_fDuration, int p_iAge)
		m_sGfx = p_sGfx;
		super.Init(p_sGfx+"_dest", p_sName, p_fDuration);
		m_iState=1;
		SetAge(p_iAge);
	endproc;

	export proc void OnPostLoad()
		if(ShouldStay(GetGfxName()))then
			m_iState=0;
			return;
		endif;
		if(m_iState==2 || m_iState==1)then
			Delete();
		endif;
	endproc;

	export proc void SetGFX(string p_sString)
		super.SetGFX(p_sString);
	endproc;

	proc void PlayAnim(int p_iPlayMode)
		AnimAction("destroy");
	endproc;

	export proc void OnActionEnd(bool p_bBroken)
		if(m_iState == 2)then
			Delete();
		endif;
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if (p_rxEvtPtr.GetClass() == ms_xTimerClass) then
			var int iTimerID = p_rxEvtPtr.GetInt(0);
			if(iTimerID == TIMER_DELETE)then
				// HACK
				if(ShouldStay(GetGfxName()))then
					m_iState=0;
					return;
				endif;
				//ENDHACK
				m_iState=2;
				var vec3 vP = GetPos();
				vP.SetZ(0.0f);
				MoveAction(vP, 1.0f);
			endif;
		endif;
	endproc;

	export destructor()
	enddestructor;

endclass;

class CLaunchPad inherit CBuilding

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
	endproc;

	export proc void OnPostLoad()
		if(!CSrvWrap.GetCurLevel()^.IsEditable() && !IsReady() && m_pxTaskMgr^.GetCurTaskName()!="BuildUpB")then
			BuildUp("/Actions/"+GetTribeName()+"/Build/BLDG/"+GetClassName());
			if(GetClassName()=="ninigi_telescope_tower_ruins")then
				var ^CBuildUpBuilding pxTask=cast<CBuildUpBuilding>(m_pxTaskMgr^.GetCurTask());
				if(pxTask!=null)then
					pxTask^.AddProgress(49.0);
				endif;
			endif;
		endif;
	endproc;

endclass;

class CWarpMgr inherit CEvtSink

	static var ^CWarpMgr 		ms_pxInst;
	var array CObjHndl			m_axHndlList;
	var CGameTimeSpan			m_xGameOverDuration;
	var int						m_iTimer;
	var bool					m_bWarpGateBuild;
	var array bool				m_abGateReady;
	var CEvtSource				m_xSource;


	constructor()
		var CObjHndl xInvalid = CObjHndl.Invalid();
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);
		m_axHndlList.AddEntry(xInvalid);

		m_xGameOverDuration = 600.0;
		m_iTimer = -1;
		m_bWarpGateBuild = false;

		m_abGateReady = 8;
	endconstructor;

	destructor()
		if(m_iTimer!=-1)then
			CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
			CTimeMgr.Get().DeleteTimer(m_iTimer);
		endif;
	enddestructor;

	export static proc ref CWarpMgr Get()
		if (ms_pxInst==null)then
			ms_pxInst=new CWarpMgr;
		endif;

		return(ms_pxInst^);
	endproc;

	export static proc void Kill()
		if (ms_pxInst!=null)then
			delete ms_pxInst;
			ms_pxInst=null;
		endif;
	endproc;

	export proc bool Update()
		return CSrvWrap.GetCurLevel()^.GetLevelInfo().GetAttribs().GetValueBool("DimGateAvailable");
	endproc;

	export proc void Subscribe(^CEvtSink p_pxSink)
		m_xSource.Subscribe(p_pxSink);
	endproc;

	export proc void Unsubscribe(^CEvtSink p_pxSink)
		m_xSource.Unsubscribe(p_pxSink);
	endproc;

	proc void MarkForAllStarted(^CWarpGate p_pxTransit)
		//L KLog.LogSpam("CWarpMgr","MarkForAllStarted()");
		var string sPlayerName = "unknown";
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		if(pxLevel!=null && p_pxTransit!=null)then
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(p_pxTransit^.GetOwner());
			if(pxPlayer!=null)then
				sPlayerName = pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
			endif;
		endif;
		CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_NT_WarpGateStarted\t"+sPlayerName);
	endproc;

	proc void MarkForAllFinished(^CWarpGate p_pxTransit)
		//L KLog.LogSpam("CWarpMgr","MarkForAllFinished()");
		var string sPlayerName = "unknown";
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		if(pxLevel!=null && p_pxTransit!=null)then
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(p_pxTransit^.GetOwner());
			if(pxPlayer!=null)then
				sPlayerName = pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
			endif;
		endif;
		CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_NT_WarpGateFinished\t"+sPlayerName);
	endproc;

	proc void MarkForAllDestroyed(^CWarpGate p_pxTransit)
		//L KLog.LogSpam("CWarpMgr","MarkForAllDestroyed()");
		var string sPlayerName = "unknown";
		var ^CLevel pxLevel = CSrvWrap.GetCurLevel();
		if(pxLevel!=null && p_pxTransit!=null)then
			var ^CPlayer pxPlayer = pxLevel^.GetPlayer(p_pxTransit^.GetOwner());
			if(pxPlayer!=null)then
				sPlayerName = pxLevel^.GetLevelInfo().GetPlayerSlot(pxPlayer^.GetPlayerSlotID()).GetName();
			endif;
		endif;
		CFeedback.Print(CFeedback.ALL, CFeedback.ATTACK, "_NT_WarpGateDestroyed\t"+sPlayerName);
	endproc;

	proc void StartGameOverTimer()
		if(!Update())then return; endif;
		//L KLog.LogSpam("CWarpMgr","StartGameOverTimer()");
		if(m_iTimer==-1)then
			m_iTimer = CTimeMgr.Get().CreateTimer(CGameTimeSpan.OneSecond() * 5.0, true);
			CTimeMgr.Get().GetTimer(m_iTimer)^.Subscribe(this);
		endif;
	endproc;

	proc void StopGameOverTimer()
		if(!Update())then return; endif;

		//L KLog.LogSpam("CWarpMgr","StopGameOverTimer()");
		if(m_iTimer==-1)then return; endif;

		var int i, iC = m_axHndlList.NumEntries();
		var bool bAllTransitsDestroyed = true;
		if(!m_bWarpGateBuild)then
			for(i=0)cond(i<iC)iter(i++)do
				if(m_axHndlList[i].IsValid())then
					bAllTransitsDestroyed = false;
					break;
				endif;
			endfor;
		endif;

		if(bAllTransitsDestroyed)then
			CTimeMgr.Get().GetTimer(m_iTimer)^.Unsubscribe(this);
			CTimeMgr.Get().DeleteTimer(m_iTimer);
			m_iTimer = -1;
		endif;

	endproc;

	export proc bool OnPush(ref CEvtPointer p_rxEP)
		//L KLog.LogSpam("CWarpMgr","OnPush()");
		CheckTimer();
		return true;
	endproc;

	proc void CheckTimer()
		//L KLog.LogSpam("CWarpMgr","CheckTimer()");
		var int i, iC = m_axHndlList.NumEntries();
		var CGameTime xNow = CTimeMgr.Get().GetTime();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_axHndlList[i].IsValid() && m_abGateReady[i])then
				var ^CWarpGate pxGate = cast<CWarpGate>(m_axHndlList[i].GetObj());
				if(pxGate!=null)then
					var CGameTimeSpan xDiff = xNow-pxGate^.m_xStartTime;
					if(xDiff<m_xGameOverDuration)then
					else
						var CEvtPointer xE = CEvtPointer.CreateEvent("WarpGate");
						xE.SetInt(0,i);
						m_xSource.Broadcast(xE);
						m_bWarpGateBuild = true;
						StopGameOverTimer();
						break;
					endif;
				endif;
			endif;
		endfor;
	endproc;

	//someone has started a warp gate
	export proc bool Register(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Register()");

		if(!p_xHndl.IsValid())then return false; endif;

		var ^CWarpGate pxTransit = cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;

		var int iOwner = pxTransit^.GetOwner();
		if(iOwner<0 || iOwner>7)then return false; endif;

		if(m_axHndlList[iOwner].IsValid())then return false; endif;

		m_axHndlList[iOwner] = p_xHndl;
		MarkForAllStarted(pxTransit);

		return true;

	endproc;

	//someone has destroyed a not yet finished warp gate
	export proc bool Unregister(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Unregister()");
		if(!p_xHndl.IsValid())then return false; endif;

		var ^CWarpGate pxTransit = cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;

		var int iOwner = pxTransit^.GetOwner();
		if(iOwner<0 || iOwner>7)then return false; endif;

		if(!(m_axHndlList[iOwner]==p_xHndl))then return false; endif;

		m_axHndlList[iOwner] = CObjHndl.Invalid();
		return true;
	endproc;


	//someone has finished a warp gate
	export proc bool Finished(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Finished()");

		if(!p_xHndl.IsValid())then return false; endif;

		var ^CWarpGate pxTransit = cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;

		var int iOwner = pxTransit^.GetOwner();
		if(iOwner<0 || iOwner>7)then return false; endif;

		if(!(m_axHndlList[iOwner]==p_xHndl))then return false; endif;

		m_abGateReady[iOwner] = true;
		StartGameOverTimer();
		MarkForAllFinished(pxTransit);

		return true;

	endproc;

	//someone has destroyed a finished warp gate
	export proc bool Destroyed(CObjHndl p_xHndl)
		if(!Update())then return false; endif;
		//L KLog.LogSpam("CWarpMgr","Destroyed()");
		if(!p_xHndl.IsValid())then return false; endif;

		var ^CWarpGate pxTransit = cast<CWarpGate>(p_xHndl.GetObj());
		if(pxTransit==null)then return false; endif;

		var int iOwner = pxTransit^.GetOwner();
		if(iOwner<0 || iOwner>7)then return false; endif;

		if(!(m_axHndlList[iOwner]==p_xHndl))then return false; endif;

		m_axHndlList[iOwner] = CObjHndl.Invalid();

		m_abGateReady[iOwner] = false;
		StopGameOverTimer();
		MarkForAllDestroyed(pxTransit);

		return true;
	endproc;

endclass;

class CWarpGate inherit CBuilding

	var CObjList m_xFOWObjs;
	export var CGameTime m_xStartTime;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!CWarpMgr.Get().Register(GetHandle()))then
			Delete();
			return;
		endif;
		if(!p_bLoad)then
			var int i, iC = 8;
			for(i=0)cond(i<iC)iter(i++)do
				var ^CShowFOWObj pxO = cast<CShowFOWObj>(CSrvWrap.GetObjMgr()^.CreateObj("ShowFOW_Obj",i,GetPos()));
				if (pxO!=null) then
					m_xFOWObjs.Include(pxO^.GetHandle());
					pxO^.SetFOWRange(20.0);
				endif;
			endfor;
		endif;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="Warp")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			m_xFOWObjs.DoKArc(pxArc^);
			m_xStartTime.DoKArc(pxArc^);
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;


	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="Warp";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		m_xFOWObjs.DoKArc(pxArc^);
		m_xStartTime.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void SetReadyBuild()
		super.SetReadyBuild();
		m_xStartTime = CTimeMgr.Get().GetTime();
	endproc;

	export proc void SetReady()
		super.SetReady();
		if(HasAnim("standanim"))then
			SetAnim("standanim",3);
			SetShowSpeedLines(true);
		endif;
		if(!CWarpMgr.Get().Finished(GetHandle()))then
			Delete();
		endif;
	endproc;

	export proc void Die()
		if(m_bBuildingReady)then
			CWarpMgr.Get().Destroyed(GetHandle());
		else
			CWarpMgr.Get().Unregister(GetHandle());
		endif;
		super.Die();
	endproc;

	export proc void Delete()
		var int i, iC = m_xFOWObjs.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(m_xFOWObjs[i].IsValid())then
				m_xFOWObjs[i].GetObj()^.Delete();
			endif;
		endfor;
		super.Delete();
	endproc;

endclass;

class CBuildingCost
	static var array string 	ms_asBuilding;
	static var array int 	 	ms_aiWood;
	static var array int 	 	ms_aiFood;
	static var array int 	 	ms_aiStone;

	export static proc void Register(^CGameObj p_pxObj)
		var ^CBuilding pxBldg = cast<CBuilding>(p_pxObj);

		if(p_pxObj==null || pxBldg==null) then
			return;
		endif;

		var string sClass = p_pxObj^.GetClassName();
		var int iIdx = ms_asBuilding.BinarySearch(sClass);
		if(iIdx<0) then
			var string sPath = pxBldg^.GetBuildAction()+"/conditions/rescosts";

			var ^CBasePlayer pxPlayer = CBasePlayer.GetPlayer(p_pxObj^.GetOwner());
			if(pxPlayer!=null)then
				var ^CTechTree.CNode pxCostNode = pxPlayer^.GetPlayerTechTree().FindNode(sPath);
				if(pxCostNode!=null) then
					iIdx = ms_asBuilding.BinaryInsert(sClass);
					ms_aiWood.InsertEntry(iIdx);	ms_aiWood[iIdx] = pxCostNode^.GetSubValueI("wood",0);
					ms_aiFood.InsertEntry(iIdx);	ms_aiFood[iIdx] = pxCostNode^.GetSubValueI("food",0);
					ms_aiStone.InsertEntry(iIdx);	ms_aiStone[iIdx] = pxCostNode^.GetSubValueI("stone",0);
				endif;
			endif;
		endif;
	endproc;

	export static proc bool GetCost(string p_sClass, ref int po_riWood, ref int po_riFood, ref int po_riStone)
		var int iIdx = ms_asBuilding.BinarySearch(p_sClass);
		if(iIdx<0) then
			po_riWood = 0;
			po_riFood = 0;
			po_riStone = 0;
			return false;
		endif;
		po_riWood = ms_aiWood[iIdx];
		po_riFood = ms_aiFood[iIdx];
		po_riStone = ms_aiStone[iIdx];
		return true;
	endproc;
endclass;

class CRepairDesc

	static var array string ms_asResNameMapping;

	var array real 	m_afOverallCost;
	var array real 	m_afCostPerHP;
	var array real 	m_afBuildingCost;

	var array real 	m_afToPay;
	var bool 		m_bValidCost;

	var CObjHndl   m_xBuilding;

	export constructor()
		if(ms_asResNameMapping.NumEntries()==0) then
			ms_asResNameMapping.AddEntry("wood");
			ms_asResNameMapping.AddEntry("food");
			ms_asResNameMapping.AddEntry("stone");
		endif;
		m_afOverallCost = 3;
		m_afCostPerHP = 3;
		m_afBuildingCost = 3;
		m_afToPay = 3;
	endconstructor;

	export proc void Init(CObjHndl p_xObj)
		m_xBuilding = p_xObj;

		if(p_xObj.IsValid()) then
			var int iW, iF, iS;
			m_bValidCost = CBuildingCost.GetCost(p_xObj.GetObj()^.GetClassName(), iW, iF, iS);
			if(m_bValidCost) then
				m_afBuildingCost[0] = iW.ToReal()*0.5f;
				m_afBuildingCost[1] = iF.ToReal()*0.5f;
				m_afBuildingCost[2] = iS.ToReal()*0.5f;
			endif;
		endif;
	endproc;

	export proc bool GetCost(string p_sResource, ref real po_rfOverall, ref real po_rfPerHP)
		po_rfOverall = 0.0f;
		po_rfPerHP = 0.0f;

		var int iIdx = ms_asResNameMapping.FindEntry(p_sResource);
		if(iIdx<0) then return false; endif;

		po_rfOverall = m_afOverallCost[iIdx];
		po_rfPerHP = m_afCostPerHP[iIdx];
		return true;
	endproc;


	export proc void Update()
		if(!m_xBuilding.IsValid()) then return; endif;
		var ^CBuilding pxO = cast<CBuilding>(m_xBuilding.GetObj());

		var real fCurHP = pxO^.GetHitpoints();
		var real fMaxHP = pxO^.GetMaxHitpoints();
		if(fCurHP==fMaxHP) then return; endif;
		var real fPercent = fCurHP / (fMaxHP*0.01f);

		if(!m_bValidCost) then
			var int iW, iF, iS;
			m_bValidCost = CBuildingCost.GetCost(pxO^.GetClassName(), iW, iF, iS);
			if(m_bValidCost) then
				m_afBuildingCost[0] = iW.ToReal()*0.5f;
				m_afBuildingCost[1] = iF.ToReal()*0.5f;
				m_afBuildingCost[2] = iS.ToReal()*0.5f;
			endif;
		endif;

		var real fW = m_afBuildingCost[0]*(100.0f-fPercent)*0.01f;
		var real fF = m_afBuildingCost[1]*(100.0f-fPercent)*0.01f;
		var real fS = m_afBuildingCost[2]*(100.0f-fPercent)*0.01f;

		m_afOverallCost[0] = fW;
		m_afOverallCost[1] = fF;
		m_afOverallCost[2] = fS;

		var real fDiff = fMaxHP-fCurHP;
		m_afCostPerHP[0] = fW/fDiff;
		m_afCostPerHP[1] = fF/fDiff;
		m_afCostPerHP[2] = fS/fDiff;
	endproc;

	export proc bool PayForRepair(real p_fHealedHP)
		if(!m_xBuilding.IsValid()) then return false; endif;
		var ^CGameObj pxO = m_xBuilding.GetObj();
		if((CCharacter.ms_iRepairNoCost-2)==pxO^.GetOwner()) then return true; endif;

		var bool bNoRes = false;

		var ^CLevel pxLevel=CSrvWrap.GetCurLevel();
		var ^CPlayer pxPlayer=pxLevel^.GetPlayer(pxO^.GetOwner());
		if(pxPlayer!=null) then
			var ^CAttribs pxA=pxPlayer^.GetAttribs();
			if(pxA!=null) then
				var int i, iC = ms_asResNameMapping.NumEntries();
				for(i=0)cond(i<iC)iter(i++)do
					var int iValue = pxA^.GetValueInt(ms_asResNameMapping[i]);
					if(m_afCostPerHP[i]==0.0f) then continue; endif;
					m_afToPay[i] += m_afCostPerHP[i] * p_fHealedHP;
					if(m_afToPay[i]>=1.0f) then
						var int iV = m_afToPay[i].ToInt();
						iValue-=iV;
						m_afToPay[i]-=iV.ToReal();
					endif;

					if(iValue<=0)then
						iValue=0;
						bNoRes=true;
					endif;

					pxA^.SetValue(ms_asResNameMapping[i], iValue);
				endfor;
			endif;
		endif;
		return !bNoRes;
	endproc;


	export proc void DoKArc(^CArc p_pxArc)
		var int i, iC = ms_asResNameMapping.NumEntries();
		p_pxArc^ << iC;
		m_afOverallCost=iC;
		m_afCostPerHP=iC;
		m_afBuildingCost=iC;
		for(i=0) cond(i<iC) iter(++i) do
			p_pxArc^ << m_afOverallCost[i];
			p_pxArc^ << m_afCostPerHP[i];
			p_pxArc^ << m_afBuildingCost[i];
			p_pxArc^ << m_afToPay[i];
		endfor;
		p_pxArc^ << m_bValidCost;
		m_xBuilding.DoKArc(p_pxArc^);
	endproc;
endclass;

class CScorpionBoss inherit CBuilding

	const int TIMER_ATTACK_START	=547;
	const int TIMER_ATTACK_TICK		=548;
	const int TIMER_ATTACK_END		=549;
	const int TIMER_DESTROY			=550;

	const int TIMER_OPEN			=551;
	const int TIMER_CLOSE			=552;

	var bool			m_bActive,m_bStateChange;
	var int				m_iAttack;
	var int				m_iState;		//3 - full attack
										//2 - 33% dmg
										//1 - 66% attack

	var int				m_iHitState;	//3 - attack
										//2 - prepare
										//1 - wait
										//0 - prepare

	var CObjHndl		m_xPanelA;
	var CObjHndl		m_xPanelB;
	var CObjHndl		m_xPanelC;
	var CObjList		m_xPanels;
	var int				m_iPrepareCount;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			m_bActive=false;
			m_iAttack=-1;
			m_bStateChange=false;
			SetVisInFOW(true);
			SetHitable(false);
			SetSelectable(false);
			var ^CScorpionPanel pxPanel=cast<CScorpionPanel>(CSrvWrap.GetObjMgr()^.CreateObj("scorpion_panel_a",GetOwner(),GetPos()+{-20.0,20.0,0.0}));
			m_xPanelA=pxPanel^.GetHandle();
			pxPanel^.SetBoss(GetHandle());
			pxPanel^.SetState(2);
			pxPanel=cast<CScorpionPanel>(CSrvWrap.GetObjMgr()^.CreateObj("scorpion_panel_b",GetOwner(),GetPos()+{-20.0,0.0,0.0}));
			m_xPanelB=pxPanel^.GetHandle();
			pxPanel^.SetBoss(GetHandle());
			pxPanel^.SetState(1);
			pxPanel=cast<CScorpionPanel>(CSrvWrap.GetObjMgr()^.CreateObj("scorpion_panel_c",GetOwner(),GetPos()+{-20.0,-20.0,0.0}));
			m_xPanelC=pxPanel^.GetHandle();
			pxPanel^.SetBoss(GetHandle());
			pxPanel^.SetState(0);
			SetAnim("stand_up",0,2);
			m_xPanels.AddEntry(m_xPanelA);
			m_xPanels.AddEntry(m_xPanelB);
			m_xPanels.AddEntry(m_xPanelC);
		endif;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScBo")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_bActive;
			endif;
			if(iVersion>=2)then
				pxArc^ << m_iAttack;
			endif;
			if(iVersion>=3)then
				pxArc^ << m_iState;
				pxArc^ << m_bStateChange;
				m_xPanelA.DoKArc(pxArc^);
				m_xPanelB.DoKArc(pxArc^);
				m_xPanelC.DoKArc(pxArc^);
			endif;
			if(iVersion==4)then
				var CObjHndl xInvalid;
				xInvalid.DoKArc(pxArc^);
			endif;
			if(iVersion>=5)then
				m_xPanels.DoKArc(pxArc^);
			endif;
			if(iVersion>=6)then
				pxArc^ << m_iPrepareCount;
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ScBo";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,6);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^ << m_bActive;
		pxArc^ << m_iAttack;
		pxArc^ << m_iState;
		pxArc^ << m_bStateChange;
		m_xPanelA.DoKArc(pxArc^);
		m_xPanelB.DoKArc(pxArc^);
		m_xPanelC.DoKArc(pxArc^);
		m_xPanels.DoKArc(pxArc^);
		pxArc^ << m_iPrepareCount;
		pxWalk^.Close();
	endproc;

	proc void OnDefend(^CGameObj p_pxEnemy)
		if(p_pxEnemy!=null)then
			HandleGamePlayCommand("Action",p_pxEnemy, p_pxEnemy^.GetPos(), "/AttackSrv");
		endif;
	endproc;

	export proc bool AttackEnemy(^CFightingObj p_pxEnemy, vec3 p_vTarget, ref bool p_rbRotated)
		if(!m_bActive)then return false; endif;
		if(m_bStateChange)then
			if(m_iState==2)then
				SetDestructLevel(1);
			elseif(m_iState==1)then
				SetDestructLevel(2);
			endif;
			StartDestructionAnim();
			m_iAttack=4;
			m_iHitState=0;
			m_bStateChange=false;
			return false;
		endif;
		if(m_iState==4)then
			SetAnim("standanim",1);
			m_iState=3;
			return false;
		endif;
		if(p_pxEnemy!=null)then

			if(m_iPrepareCount>0)then
				Prepare();
				return false;
			endif;

			if(m_iHitState==0)then
				m_iAttack=Random.GetInt()%Math.Max(m_iState,1);
				m_iPrepareCount=1;
				Prepare();
				return false;
			elseif(m_iHitState==1)then
				Wait();
				return false;
			elseif(m_iHitState==2)then
				m_iPrepareCount=1;
				Prepare();
				return false;
			endif;

			m_iHitState=0;

			DeleteTimer(TIMER_ATTACK_START);
			DeleteTimer(TIMER_ATTACK_END);

			if(m_iAttack==0)then	//Legs
				if(HasAnim("attack_3"))then
					SetAnim("attack_3",1);
				endif;
				CreateTimer(TIMER_ATTACK_START,CGameTimeSpan.OneSecond()*2.8,false);
				CreateTimer(TIMER_ATTACK_END,CGameTimeSpan.OneSecond()*3.2,false);
				return false;
			endif;

			if(m_iAttack==1)then	//Flamethrower
				if(HasAnim("attack_2"))then
					SetAnim("attack_2",1);
				endif;
				CreateTimer(TIMER_ATTACK_START,CGameTimeSpan.OneSecond()*5.2,false);
				CreateTimer(TIMER_ATTACK_END,CGameTimeSpan.OneSecond()*11.0,false);
				return false;
			endif;

			if(m_iAttack==2)then	//Scissors
				if(HasAnim("attack_1"))then
					SetAnim("attack_1",1);
				endif;
				CreateTimer(TIMER_ATTACK_START,CGameTimeSpan.OneSecond()*1.0,false);
				CreateTimer(TIMER_ATTACK_END,CGameTimeSpan.OneSecond()*1.4,false);
				return false;
			endif;
		endif;
		return false;
	endproc;

	proc void Prepare()
		var string sAnim;
		if(m_iAttack==0)then
			sAnim="prepare_3";
		elseif(m_iAttack==1)then
			sAnim="prepare_2";
		elseif(m_iAttack==2)then
			sAnim="prepare_1";
		endif;
		if(HasAnim(sAnim))then
			SetAnim(sAnim,1);
		endif;
		m_iPrepareCount--;
		m_iHitState++;
	endproc;

	proc void Wait()
		var string sAnim="standanim";
		if(HasAnim(sAnim))then
			SetAnim(sAnim,1);
		endif;
		m_iHitState=2;
	endproc;

	export proc void SetIdleAnim()
		if(!m_bActive)then return; endif;
		super.SetIdleAnim();
	endproc;


	proc void StartDestructionAnim()
		InvokeGenericSCEvent(14,4.0f);
		if(m_iState==3)then
			SetAnim("standanim",1);
		elseif(m_iState==2)then
			SetAnim("destroy_1",1);
		elseif(m_iState==1)then
			SetAnim("destroy_2",1);
		else
			if(HasAnim("dying"))then
				SetAnim("dying",1);
			endif;
		endif;
		//create dest objs, play both dest anims
	endproc;

	export proc void UpdateState()
		m_iState--;
		m_bStateChange=true;
		if(m_iState<=0)then
			Die();
		endif;
		DeleteTimer(TIMER_OPEN);
		DeleteTimer(TIMER_CLOSE);
		ClosePanel();
	endproc;

	export proc void SetState(int p_iState)
		m_iState=p_iState;
	endproc;

	proc void OpenRandomPanel()
		ValidatePanels();
		if(m_xPanels.NumEntries()<=0)then return; endif;
		var int iRandom=Random.GetInt()%m_xPanels.NumEntries();
		var ^CGameObj pxObj=m_xPanels[iRandom].GetObj();
		DeleteTimer(TIMER_OPEN);
		CreateTimer(TIMER_CLOSE,CGameTimeSpan.OneSecond()*25.0, false);
		if(pxObj==null)then return; endif;
		pxObj^.SetHitable(true);
		pxObj^.SetSelectable(true);
		pxObj^.SetAnim("open",1);
	endproc;

	proc void ValidatePanels()
		var int i,iC=m_xPanels.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			if(!m_xPanels[i].IsValid())then
				m_xPanels.DeleteEntry(i);i--;iC--;
			endif;
		endfor;
	endproc;

	proc void ClosePanel()
		ValidatePanels();
		var int i,iC=m_xPanels.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CGameObj pxObj=m_xPanels[i].GetObj();
			if(pxObj==null)then continue; endif;
			if(pxObj^.IsHitable())then
				pxObj^.SetHitable(false);
				pxObj^.SetSelectable(false);
				pxObj^.SetAnim("open",2);
			endif;
		endfor;
		DeleteTimer(TIMER_CLOSE);
		CreateTimer(TIMER_OPEN,CGameTimeSpan.OneSecond()*10.0, false);
	endproc;

	export proc real GetWeaponDuration()
/*		if(m_iAttack==4)then	//Destruction
			if(m_iState==2)then
				return 16.0;
			else
				return 5.0;
			endif;
		elseif(m_iAttack==0)then
			return 4.0;
		elseif(m_iAttack==1)then
			return 12.0;
		elseif(m_iAttack==2)then
			return 2.8;
		else
			return 2.0;
		endif;

*/		return GetCurrentAnimLength();
	endproc;

	proc bool UpdateDestructionFlags()
		if(m_iState==2)then
			SetDestructLevel(1);
		elseif(m_iState==1)then
			SetDestructLevel(2);
		endif;
		return false;
	endproc;

	export proc void HandleGamePlayCommand(string p_sCommand, ^CGameObj p_pxObject, vec3 p_vPos, string p_sMiscParams)
		if(p_sMiscParams.Find("/JumpOffWall")!=-1)then
			if(!m_bActive)then
				OpenRandomPanel();
				SetState(4);
				OnTechTreeChange();
				var bool bInvalid;
				AttackEnemy(null, GetPos(), bInvalid);
			endif;
			m_bStateChange=false;
			m_bActive=true;
			//AnimAction("");
		else
			super.HandleGamePlayCommand(p_sCommand,p_pxObject,p_vPos,p_sMiscParams);
		endif;
	endproc;

	export proc bool FollowEnemy(^CFightingObj p_pxEnemy, bool p_bAttackScape)
		return true;
	endproc;

	export proc void HandleEvent(ref CGameEvtPtr p_rxEvtPtr)
		if(p_rxEvtPtr.GetClass()==ms_xTimerClass)then
			if(p_rxEvtPtr.GetInt(0)==TIMER_ATTACK_START)then
				DoDamage();
				DeleteTimer(TIMER_ATTACK_TICK);
				CreateTimer(TIMER_ATTACK_TICK,CGameTimeSpan.OneSecond()*1.0,true);
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_ATTACK_END)then
				DeleteTimer(TIMER_ATTACK_TICK);
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_ATTACK_TICK)then
				DoDamage();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_OPEN)then
				OpenRandomPanel();
			elseif(p_rxEvtPtr.GetInt(0)==TIMER_CLOSE)then
				ClosePanel();
			else
				super.HandleEvent(p_rxEvtPtr);
			endif;
		else
			super.HandleEvent(p_rxEvtPtr);
		endif;
	endproc;

	export proc void DoDamage()
		var string sRegionName;
		var real fDamage;
		if(m_iAttack==0)then
			sRegionName="scorpion_legs";
			fDamage=250.0;
		elseif(m_iAttack==1)then
			sRegionName="scorpion_flamethrower";
			fDamage=50.0;	//per tick
		elseif(m_iAttack==2)then
			sRegionName="scorpion_scissors";
			fDamage=250.0;
		else
			return;
		endif;
		var ^CRegion pxRegion=CSrvWrap.GetRegionMgr().GetRegion(sRegionName);
		if(pxRegion==null)then return; endif;
		var CObjList xObjList;
		var int i,iC=pxRegion^.NumObjects();
		for(i=0)cond(i<iC)iter(i++)do
			xObjList.AddEntry(pxRegion^.GetObject(i));
		endfor;
		iC=xObjList.NumEntries();
		for(i=0)cond(i<iC)iter(i++)do
			var ^CFightingObj pxFighter=cast<CFightingObj>(xObjList[i].GetObj());
			if(xObjList[i]==GetHandle())then continue; endif;
			if(pxFighter==null)then continue; endif;
			if(pxFighter^.GetTransportObj().IsValid())then continue; endif;
			if(cast<CScorpionPanel>(pxFighter)!=null)then continue; endif;
			pxFighter^.TakeDirectMeleeDmg(fDamage);
		endfor;
	endproc;

	export proc int GetAggressive()
		return GetTechTreeAggressiv();
	endproc;

	export proc bool IsAbleToFight()
  		return true;
  	endproc;

endclass;

class CScorpionPanel inherit CBuilding

	var CObjHndl	m_xBoss;
	var int			m_iState;

	export proc void SetBoss(CObjHndl p_xBoss)
		m_xBoss=p_xBoss;
	endproc;

	export proc void SetState(int p_iState)
		m_iState=p_iState;
	endproc;

	export proc void OnInit(bool p_bLoad)
		super.OnInit(p_bLoad);
		if(!p_bLoad)then
			SetVisInFOW(true);
			SetHitable(false);
			SetSelectable(false);
		endif;
		if(!IsHitable())then
			SetAnim("open",0,0);
		endif;
	endproc;

	export proc void Load(^CUOFReaderNode p_pxReaderNode)
		if(p_pxReaderNode^.GetType()=="ScPa")then
			var ^CArc pxArc=^(p_pxReaderNode^.GetArc());
			var int iVersion=p_pxReaderNode^.GetVersion();
			if(iVersion>=1)then
				pxArc^<<m_iState;
				m_xBoss.DoKArc(pxArc^);
			endif;
		else
			super.Load(p_pxReaderNode);
		endif;
	endproc;

	export proc void Save(^CUOFWriterNode p_pxWriterNode)
		super.Save(p_pxWriterNode);
		var CFourCC xBase="ScPa";
		var ^CUOFWriterNode pxWalk=p_pxWriterNode^.AddSubChunk(xBase,1);
		var ^CArc pxArc=^(pxWalk^.GetArc());
		pxArc^<<m_iState;
		m_xBoss.DoKArc(pxArc^);
		pxWalk^.Close();
	endproc;

	export proc void Die()
		if(!IsDead())then
			var ^CScorpionBoss pxBoss=cast<CScorpionBoss>(m_xBoss.GetObj());
			if(pxBoss!=null)then
				pxBoss^.UpdateState();
			endif;
		endif;
		super.Die();
	endproc;

endclass;
